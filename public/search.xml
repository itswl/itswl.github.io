<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[有关于@property]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F%E6%9C%89%E5%85%B3%E4%BA%8E%40property%2F</url>
    <content type="text"><![CDATA[有关于@property1. 将方法改为属性这种类型的attributes并不会被实际的存储，而是在需要的时候计算出来 1234567891011121314151617181920import mathclass Circle: def __init__(self, radius): self.radius = radius def area(self): return math.pi * self.radius ** 2 @property def diameter(self): return self.radius * 2 @property def perimeter(self): return 2 * math.pi * self.radiusc = Circle(3)print(c.area()) # 方法调用print(c.diameter) # 属性访问print(c.perimeter) 2. 做限定参考前文 3.]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[上下文管理器]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[上下文管理器让对象支持上下文管理器对象需要定义 __enter__ 和 __exit__1234567891011121314151617181920212223242526272829303132333435from socket import socket, AF_INET, SOCK_STREAMclass LazyConnection: def __init__(self, address, family=AF_INET, type=SOCK_STREAM): self.address = address self.family = family self.type = type self.sock = None def __enter__(self): if self.sock is not None: raise RuntimeError(&apos;Already connected&apos;) self.sock = socket(self.family, self.type) self.sock.connect(self.address) return self.sock def __exit__(self, exc_ty, exc_val, tb): # 异常类型，异常值和异常的trackback self.sock.close() self.sock = None #return True 如果这里返回True 则代表不处理with中的异常if __name__ == &apos;__main__&apos;: from functools import partial conn = LazyConnection((&apos;www.python.org&apos;, 80)) # Connection closed with conn as s: # conn.__enter__() executes: connection open s.send(b&apos;GET /index.html HTTP/1.0\r\n&apos;) s.send(b&apos;Host: www.python.org\r\n&apos;) s.send(b&apos;\r\n&apos;) resp = b&apos;&apos;.join(iter(partial(s.recv, 8192), b&apos;&apos;)) print(resp) # conn.__exit__() executes: connection closed 线程安全修改版12345678910111213141516171819202122232425262728293031323334353637383940from socket import socket, AF_INET, SOCK_STREAMimport threadingclass LazyConnection: def __init__(self, address, family=AF_INET, type=SOCK_STREAM): self.address = address self.family = AF_INET self.type = SOCK_STREAM self.local = threading.local() def __enter__(self): if hasattr(self.local, &apos;sock&apos;): raise RuntimeError(&apos;Already connected&apos;) self.local.sock = socket(self.family, self.type) self.local.sock.connect(self.address) return self.local.sock def __exit__(self, exc_ty, exc_val, tb): self.local.sock.close() del self.local.sockfrom functools import partialdef test(conn): with conn as s: s.send(b&apos;GET /index.html HTTP/1.0\r\n&apos;) s.send(b&apos;Host: www.huawei.com\r\n&apos;) s.send(b&apos;\r\n&apos;) resp = b&apos;&apos;.join(iter(partial(s.recv, 8192), b&apos;&apos;)) print(&apos;Got &#123;&#125; bytes&apos;.format(len(resp)))if __name__ == &apos;__main__&apos;: conn = LazyConnection((&apos;www.huawei.com&apos;, 80)) t1 = threading.Thread(target=test, args=(conn,)) t2 = threading.Thread(target=test, args=(conn,)) t1.start() t2.start() t1.join() t2.join() 使用 contexlib 模块中的 @contextmanager装饰器实现一个新的上下文管理器的最简单的方法 yield 之前的代码会在上下文管理器中作为 __enter__() 方法执行，所有在 yield 之后的代码会作为 __exit__() 方法执行 先执行print(&#39;《&#39;, end=&#39;&#39;)，遇到yeild ,执行 print(&#39;挪威的森林&#39;,end=&#39;&#39;) , 最后执行 print(&#39;》&#39;, end=&#39;&#39;)123456789101112from contextlib import contextmanager@contextmanagerdef book_mark(): print(&apos;《&apos;, end=&apos;&apos;) yield print(&apos;》&apos;, end=&apos;&apos;)with book_mark(): print(&apos;挪威的森林&apos;,end=&apos;&apos;) # 《挪威的森林》 123456789101112131415161718import timeclass timethis: def __init__(self, label): self.label = label def __enter__(self): self.start = time.time() print(f&apos;start = &#123;self.start&#125;&apos;) def __exit__(self, exc_ty, exc_val, exc_tb): end = time.time() print(f&apos;&#123;end = &#125;&apos;) print(&apos;&#123;&#125;: &#123;&#125;&apos;.format(self.label, end - self.start)) with timethis(&apos;counting&apos;): n = 10000000 while n &gt; 0: n -= 1 使用from contextlib import contextmanager12345678910111213141516171819import timefrom contextlib import contextmanager@contextmanagerdef timethis(label): start = time.time() print(f&apos;&#123;start = &#125;&apos;) try: yield finally: end = time.time() print(f&apos;&#123;end = &#125;&apos;) print(f&apos;&#123;label&#125; : &#123;end - start&#125;&apos;)# Example usewith timethis(&apos;counting&apos;): n = 10000000 while n &gt; 0: n -= 1 任何对列表的修改只有当所有代码运行完成并且不出现异常的情况下才会生效123456789101112131415161718192021222324 from contextlib import contextmanager@contextmanagerdef list_transaction(orig_list): working = list(orig_list) yield working orig_list[:] = working # 任何对列表的修改只有当所有代码运行完成并且不出现异常的情况下才会生效items = [1,2,3]with list_transaction(items) as working: working.append(4) working.append(5)print(items) # [1,2,3,4,5]with list_transaction(items) as working: working.append(6) working.append(7) working是[1,2,3,4,5,6,7] raise RuntimeError(&apos;oops&apos;) 执行不了orig_list[:] = workingprint(items) ## 还是 [1,2,3,4,5]]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[待解决dataclass + __solts__的问题 __solts__ 使用slots一个不好的地方就是我们不能再给实例添加新的属性了，只能使用在 __slots__ 中定义的那些属性名 使用__solts__,python实例通过一个很小的固定大小的数组来构建，而不是为每个实例定义一个字典，这跟元组或列表很类似.Python的很多特性都依赖于普通的基于字典的实现。另外，定义了slots后的类不再支持一些普通类特性了，比如多继承。 尽量不要使用 __solts__ github上相关问题 多加一个装饰器 基础1234567891011121314151617181920212223class Color(): r = 200 def __init__(self,r=250): self.r = r self.g = self.get_g() self.b = self.get_b def get_g(self): g = 223 return g @property def get_b(self): b = 222 return b def __str__(self): return f&apos;&#123;self.__class__.__name__&#125;(class_r = &#123;self.__class__.r&#125;, r = &#123;self.r&#125;, g = &#123;self.g&#125;, b = &#123;self.b&#125;)&apos;color = Color(255)color1 = Color()print(color) # Color(class_r = 200, r = 255, g = 223, b = 222)print(color1) # Color(class_r = 200, r = 250, g = 223, b = 222) 1234567891011121314151617181920class Color(): r = 200 def __init__(self): self.g = self.get_g() self.b = self.get_b def get_g(self): g = 223 return g @property def get_b(self): b = 222 return b def __str__(self): return f&apos;&#123;self.__class__.__name__&#125;(class_r = &#123;self.__class__.r&#125;, r = &#123;self.r&#125;, g = &#123;self.g&#125;, b = &#123;self.b&#125;)&apos;color = Color()print(color) # Color(class_r = 200, r = 255, g = 223, b = 222) 使用第三方插件修改一下1234567891011121314151617from attr import attrs, attrib # dataclass 内置库可替代&apos;&apos;&apos;attrs 修饰符，可以自动实现__init__,__repr__,__eq__,__ne__,__it__,__le__,__gt__,__ge__,__hash__,这几个方法&apos;&apos;&apos;@attrsclass Color(): r = attrib(type=int, default=100) g = attrib(type=int, default=200) b = attrib(type=int, default=222)color = Color(255,254,253)color1 = Color()print(color) # Color(class_r = 200, r = 255, g = 223, b = 222)print(color1) # Color(class_r = 200, r = 250, g = 223, b = 222) 声明和比较123456789101112131415from attr import attrs, attrib # dataclass内置库可替代&apos;&apos;&apos;attrs 修饰符，可以自动实现__init__,__repr__,__eq__,__ne__,__it__,__le__,__gt__,__ge__,__hash__,这几个方法&apos;&apos;&apos;@attrsclass Point(): x = attrib() y = attrib()p1 = Point(1,2)p2 = Point(y=3,x=4)print(p1,p2) # Point(x=1, y=2) Point(x=4, y=3) 使用python3.7 的内置库12345678910from dataclasses import dataclass@dataclassclass Point(): x:int = 0 y:int = 0p1 = Point(1,2)p2 = Point(y=3,x=4)print(p1,p2) # Point(x=1, y=2) Point(x=4, y=3) 1234567891011# 默认init,repr,eq 为True， 其余为False@dataclass(init=1,repr=1,eq=1,order=1,unsafe_hash=0,frozen=0)class Point(): x:int = 0 y:int = 0p1 = Point(1,2)p2 = Point(y=3,x=4)p3 = Point(x=1,y=2)print(p1&gt;p2) # fasleprint(p1==p3) # True 1234567891011from dataclasses import dataclass@dataclass(frozen=1)class Point(): x:int = 0 y:int = 0p1 = Point(1,2)print(p1) # 当实例化一个frozen 对象时，任何企图修改对象属性的行为都会引发 FrozenInstanceError#p1.x = 10 # dataclasses.FrozenInstanceError: cannot assign to field &apos;x&apos; 1234567891011121314from dataclasses import dataclass@dataclass()class Point(): x:int = 0 y:int = 0 def x_add_1(self): self.x += 1p1 = Point(1,2)print(p1) # Point(x=1, y=2)p1.x_add_1()print(p1) # Point(x=2, y=2) __init__方法在返回前会调用__post_init__123456789101112from dataclasses import dataclass@dataclass()class Point(): x:int = 0 y:int = 0 def __post_init__(self): self.x += 1 p1 = Point(1,2)print(p1) # Point(x=2, y=2) 有关继承12345678910111213141516from dataclasses import dataclass@dataclassclass Point: x:int = 0 y:int = 0 def __post_init__(self): self.x += 1@dataclassclass ThirdPonit(Point): z:int =0ppp = ThirdPonit(1,3,4)print(ppp) # ThirdPonit(x=2, y=3, z=4) super1234567891011121314151617181920from dataclasses import dataclass@dataclassclass Point: x:int = 0 y:int = 0 def __post_init__(self): self.x += 1@dataclassclass ThirdPonit(Point): z:int =0 def __post_init__(self): super().__post_init__() # 调用 父类的__post_init__() self.x += 10ppp = ThirdPonit(1,3,4)print(ppp) # ThirdPonit(x=12, y=3, z=4) 复合初始化12345678910111213141516import randomfrom dataclasses import dataclassdef get_random_marks(): return [random.randint(1,10) for _ in range(5)]@dataclassclass Student: marks:list = list def __post_init__(self): # 额外的工作 self.marks = get_random_marks()a = Student()print(a) # Student(marks=[2, 9, 8, 8, 2])print(a.marks) # [2, 9, 8, 8, 2] 修改123456789101112131415161718192021import randomfrom dataclasses import dataclass, fielddef get_random_marks(): return [random.randint(1,10) for _ in range(5)]@dataclassclass Student: marks:int = field(default_factory= get_random_marks) # int 不建议，建议使用数据类型 # default_factory ：如果在创建对象时没赋值，则使用该方法初始化该字段 （必须是可以调用的无参数方法） # 使用 get_random_marks 方法 初始化 marks a = Student()print(a) # Student(marks=[7, 2, 4, 7, 4])print(a.marks) # [7, 2, 4, 7, 4]print(type(a.marks)) # &lt;class &apos;list&apos;&gt;b = Student(&apos;b&apos;) # 传参则不影响print(b) # Student(marks=&apos;b&apos;)print(b.marks) # bprint(type(b.marks)) # &lt;class &apos;str&apos;&gt; filed 更多操作123456789101112131415from dataclasses import dataclass, field@dataclass(order=1)class Number: number:int = field(compare= False,repr= False) # number 不进行比较,不打印 val:int verified:1 = field(default=0,init=0) # 默认为 1，不进行初始化a = Number(3,4)b = Number(4,3)print(a &lt; b) # Falseprint(a) # Number(val=4, verified=0)print(b) # Number(val=3, verified=0)b.verified = 1print(b) # Number(val=3, verified=1)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多进程]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多进程多进程 Multiprocessing 和多线程 threading 类似，用来弥补 threading 的一些劣势（例如GIL）， Python 出了一个 multiprocessing 多进程与多线程使用方法几乎一致1234567891011121314151617import multiprocessingimport threadingdef job_t(a,d): print(&apos;tttt&apos;)def job_p(a,d): print(&apos;pppp&apos;)t1 = threading.Thread(target=job_t,args=(1,2))p1 = multiprocessing.Process(target=job_p,args=(1,2))t1.start()p1.start()t1.join()p1.join() 进程结果 Queue()123456789101112131415161718192021import multiprocessing as mpdef job(q): res=0 for i in range(1000): res+=i+i**2+i**3 q.put(res) #queueif __name__==&apos;__main__&apos;: q = mp.Queue() p1 = mp.Process(target=job,args=(q,)) p2 = mp.Process(target=job,args=(q,)) p1.start() p2.start() p1.join() p2.join() res1 = q.get() print(res1) res2 = q.get() print(res2) print(res1+res2) 效率对比1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import timeimport multiprocessing import threadingdef _cost_time(func): def warpper(*args,**kw): start_time = time.time() func(*args,**kw) end_time = time.time() print(&apos;cost time :&apos;,end_time - start_time) return warpper def job(q): res = 0 for i in range(1000000): res += i + i**2 + i**3 q.put(res) # queue@_cost_timedef normal(): res = 0 for _ in range(2): for i in range(1000000): res += i + i**2 + i**3 print(&apos;normal:&apos;, res) @_cost_timedef multithread(): q = multiprocessing.Queue() t1 = threading.Thread(target=job, args=(q,)) t2 = threading.Thread(target=job, args=(q,)) t1.start() t2.start() t1.join() t2.join() res1 = q.get() res2 = q.get() print(&apos;multithread:&apos;, res1 + res2)@_cost_timedef multicore(): q = multiprocessing.Queue() p1 = multiprocessing .Process(target=job, args=(q,)) p2 = multiprocessing .Process(target=job, args=(q,)) p1.start() p2.start() p1.join() p2.join() res1 = q.get() res2 = q.get() print(&apos;multicore:&apos;,res1 + res2)normal()multithread()multicore() 打印结果123456(&apos;normal:&apos;, 499999666667166666000000L)(&apos;cost time :&apos;, 0.8630490303039551)(&apos;multithread:&apos;, 499999666667166666000000L)(&apos;cost time :&apos;, 1.8854999542236328)(&apos;multicore:&apos;, 499999666667166666000000L)(&apos;cost time :&apos;, 0.47038793563842773) 耗时 多进程 &lt; 普通 &lt; 多线程 。 多线程不适合计算密集型]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[调用父类方法]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[调用父类方法super() 为了调用父类(超类)的一个方法，可以使用 super() 函数 12345678910111213141516class A: def spam(self): print(&apos;A.spam&apos;)class B(A): def spam(self): print(&apos;B.spam&apos;) super().spam() # Call parent spam()b = B()b.spam()&apos;&apos;&apos; 输出结果B.spam 先调用 B 的 spamA.spam 然后再调用 A 的 spam&apos;&apos;&apos; super() 函数的一个常见用法是在 __init__() 方法中确保父类被正确的初始化了1234567891011class A: def __init__(self): self.x = 0class B(A): def __init__(self): super().__init__() self.y = 1b = B()print(b.x,b.y) # 0,1 使用dataclasses改写123456789101112from dataclasses import dataclass@dataclassclass A: x:int = 0@dataclassclass B(A): y:int = 1b = B()print(b) # B(x=0, y=1) 123456789101112131415161718192021222324class Father: def __init__(self, name): self.name = name print(&quot;init Father&apos;s name&quot;)class Mather: def __init__(self, age): self.age = age print(&quot;init Mather&apos;s age&quot;)class Son(Father, Mather): def __init__(self, name, age, sex): super().__init__(name) # 先继承 Father 的 name super(Father, self).__init__(age) # 继承后 再继承 Mother 的age self.sex = sex # 最后 实例化自己的 sex print(&quot;init Son&apos;s sex&quot;)if __name__ == &quot;__main__&quot;: son = Son(&quot;Tom&quot;, 5, &quot;Male&quot;) print(Son.__mro__) # (&lt;class &apos;__main__.Son&apos;&gt;, &lt;class &apos;__main__.Father&apos;&gt;, &lt;class &apos;__main__.Mather&apos;&gt;, &lt;class &apos;object&apos;&gt;) print(son.name, son.age, son.sex) 12345678910111213141516171819202122from dataclasses import dataclass@dataclassclass Father: name:str print(&quot;init Father&apos;s name&quot;)@dataclassclass Mather: age:int print(&quot;init Mather&apos;s age&quot;)@dataclassclass Son(Father, Mather): sex:str print(&quot;init Son&apos;s sex&quot;)if __name__ == &quot;__main__&quot;: son = Son(name=&quot;Tom&quot;, age=5, sex=&quot;Male&quot;) # 这个会先实例化age,再name,再sex print(Son.__mro__) # (&lt;class &apos;__main__.Son&apos;&gt;, &lt;class &apos;__main__.Father&apos;&gt;, &lt;class &apos;__main__.Mather&apos;&gt;, &lt;class &apos;object&apos;&gt;) print(son) MRO列表Python会在MRO列表上继续搜索下一个类。只要每个重定义的方法统一使用 super() 并只调用它一次，那么控制流最终会遍历完整个MRO列表，每个方法也只会被调用一次super()有个令人吃惊的地方是它并不一定去查找某个类在MRO中下一个直接父类，你甚至可以在一个没有直接父类的类中使用它 123456789101112131415161718class A: def spam(self): print(&apos;A.spam&apos;) super().spam()class B: def spam(self): print(&apos;B.spam&apos;)class C(A,B): passc = C()print(C.__mro__) # (&lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;object&apos;&gt;)c.spam() &apos;&apos;&apos;A.spamB.spam&apos;&apos;&apos; 12345678910class C(B,A): passc = C()print(C.__mro__) # (&lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;object&apos;&gt;)c.spam() &apos;&apos;&apos;B.spam&apos;&apos;&apos;# 不会报错，只会执行 B下面的 关于super()由于 super() 可能会调用不是你想要的方法，你应该遵循一些通用原则。首先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)。这样可以确保 super() 调用一个非直接父类方法时不会出错。其次，最好确保最顶层的类提供了这个方法的实现，这样的话在MRO上面的查找链肯定可以找到某个确定的方法。 在Python社区中对于 super() 的使用有时候会引来一些争议。尽管如此，如果一切顺利的话，你应该在你最新代码中使用它。Raymond Hettinger为此写了一篇非常好的文章Python’s super() Considered Super通过大量的例子向我们解释了为什么 super() 是极好的。]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[格式化字符串]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[实例的字符串显示1234567891011121314class Pair: def __init__(self, x, y): self.x = x self.y = y def __repr__(self): return f&apos;(&#123;self.x&#125;, &#123;self.y&#125;)&apos; def __str__(self): return f&apos;Pair(&#123;self.x=&#125;, &#123;self.y=&#125;)&apos;p = Pair(3, 4)print(p) 12345678from dataclasses import dataclass@dataclassclass Pair: x:int y:int = 0 # y 默认值为0p = Pair(3, 4)print(p) 对象自定义格式化12345678910111213141516171819202122232425_formats = &#123; &apos;ymd&apos;: &apos;&#123;d.year&#125;-&#123;d.month&#125;-&#123;d.day&#125;&apos;, &apos;mdy&apos;: &apos;&#123;d.month&#125;/&#123;d.day&#125;/&#123;d.year&#125;&apos;, &apos;dmy&apos;: &apos;&#123;d.day&#125;/&#123;d.month&#125;/&#123;d.year&#125;&apos;&#125;class Date: def __init__(self, year, month, day): self.year = year self.month = month self.day = day def __format__(self, code): if code == &apos;&apos;: code = &apos;ymd&apos; fmt = _formats[code] return fmt.format(d=self)d = Date(2012, 12, 21)print(d)print(format(d, &apos;mdy&apos;))print(&apos;The date is &#123;:ymd&#125;&apos;.format(d))print(&apos;The date is &#123;:mdy&#125;&apos;.format(d)) 修改后12345678910111213141516171819202122232425from dataclasses import dataclass_formats = &#123; &apos;ymd&apos;: &apos;&#123;d.year&#125;-&#123;d.month&#125;-&#123;d.day&#125;&apos;, &apos;mdy&apos;: &apos;&#123;d.month&#125;/&#123;d.day&#125;/&#123;d.year&#125;&apos;, &apos;dmy&apos;: &apos;&#123;d.day&#125;/&#123;d.month&#125;/&#123;d.year&#125;&apos;&#125;@dataclassclass Date: year:int month:int day:int def __format__(self, code): if code == &apos;&apos;: code = &apos;ymd&apos; fmt = _formats[code] return fmt.format(d=self)a = Date(2012, 12, 21)print(a)print(format(a, &apos;mdy&apos;))print(&apos;The date is &#123;:ymd&#125;&apos;.format(a))print(&apos;The date is &#123;:mdy&#125;&apos;.format(a))]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[添加线程1234567891011121314151617import threadingdef main1(): print(threading.active_count()) # 获取已激活的线程数 print(threading.enumerate()) # 查看所有线程信息 print(threading.current_thread()) # 查看现在正在运行的线程def thread_job(): print(&apos;This is a thread of %s&apos; % threading.current_thread())def main(): thread = threading.Thread(target=thread_job,) # 定义线程 thread.start() # 让线程开始工作 if __name__ == &apos;__main__&apos;: main1() main() join功能使用join()主线程一直等待全部的子线程结束之后，主线程自身才结束( print(&#39;all done\n&#39;))，程序退出123456789101112131415161718192021222324import threadingimport timedef T1_job(): print(&apos;T1 start\n&apos;) for i in range(10): time.sleep(0.1) print(&apos;T1 finish\n&apos;)def T2_job(): print(&apos;T2 start\n&apos;) print(&apos;T2 finish\n&apos;)def main(): T1_thread = threading.Thread(target=T1_job, name=&apos;T1&apos;) T2_thread = threading.Thread(target=T2_job, name=&apos;T2&apos;) T1_thread.start() T2_thread.start() T1_thread.join() T2_thread.join() print(&apos;all done\n&apos;) if __name__ == &apos;__main__&apos;: main() 线程锁不使用线程锁1234567891011121314151617181920212223import threadingdef job1(): global A for i in range(10): A+=1 print(&apos;job1&apos;,A)def job2(): global A for i in range(10): A+=10 print(&apos;job2&apos;,A)if __name__== &apos;__main__&apos;: lock=threading.Lock() A=0 t1=threading.Thread(target=job1) t2=threading.Thread(target=job2) t1.start() t2.start() t1.join() t2.join() 打印结果,很杂乱12345678910111213141516171819job1 job2111job1 job21222job1job2 3323job2job1 4344job2job1 5554job2job1 6566job2job1 7677job2job1 8788job2job1 9899job2job1 110109 使用线程锁lock在不同线程使用同一共享内存时，能够确保线程之间互不影响123456789101112131415161718192021222324252627import threadingdef job1(): global A,lock lock.acquire() # 在每个线程执行运算修改共享内存之前，执行lock.acquire()将共享内存上锁， 确保当前线程执行时，内存不会被其他线程访问 for i in range(10): A+=1 print(&apos;job1&apos;,A) lock.release() # 执行运算完毕后，使用lock.release()将锁打开， 保证其他的线程可以使用该共享内存def job2(): global A,lock lock.acquire() for i in range(10): A+=10 print(&apos;job2&apos;,A) lock.release()if __name__== &apos;__main__&apos;: lock=threading.Lock() A=0 t1=threading.Thread(target=job1) t2=threading.Thread(target=job2) t1.start() t2.start() t1.join() t2.join() 打印结果1234567891011121314151617181920job1 1job1 2job1 3job1 4job1 5job1 6job1 7job1 8job1 9job1 10job2 20job2 30job2 40job2 50job2 60job2 70job2 80job2 90job2 100job2 110 储存进程结果 Queue123456789101112131415161718192021222324252627282930313233import threadingimport timefrom queue import Queuedef job(l,q): &apos;&apos;&apos; 对列表的每个元素进行平方计算，将结果保存在队列中 &apos;&apos;&apos; for i in range (len(l)): l[i] = l[i]**2 q.put(l) # 多线程调用的函数不能用return返回值def multithreading(): q = Queue() # q 中存放返回值，代替return的返回值 data = [[1,2,3],[3,4,5],[4,4,4],[5,5,5]] threads = [] for i in range(4): t = threading.Thread(target=job,args=(data[i],q)) # 被调用的job函数没有括号，只是一个索引，参数在后面 t.start() # 开始线程 threads.append(t) # 把每个线程append到线程列表中 for thread in threads: thread.join() # 分别join四个线程到主线程 results = [] # 定义一个空的列表results，将四个线运行后保存在队列中的结果返回给空列表results for _ in range(4): results.append(q.get()) print(results)if __name___==&apos;__main__&apos;: multithreading()]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[staticmethod和classmethod]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F%40staticmethod%E5%92%8C%40classmethod%2F</url>
    <content type="text"><![CDATA[一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。 而使用 @staticmethod或 @classmethod，就可以不需要实例化，直接类名.方法名()来调用。 123456789101112131415161718class A: bar = 1 def foo(self): print &apos;foo&apos; @staticmethod def static_foo(): print &apos;static_foo&apos; print A.bar @classmethod def class_foo(cls): print &apos;class_foo&apos; print cls.bar cls().foo() A.static_foo()A.class_foo() 如果在@staticmethod中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名。 而@classmethod因为持有cls参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码 这两个方法的用法是类似的，大多数情况下，classmethod也可以通过staticmethod代替，在通过类调用时，这两者对于调用者来说是不可区分的。 这两者的区别在于，classmethod增加了一个对实际调用类的引用，这带来了很多方便的地方： 方法可以判断出自己是通过基类被调用，还是通过某个子类被调用 通过子类调用时，方法可以返回子类的实例而非基类的实例 通过子类调用时，方法可以调用子类的其他classmethod]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python判断是否json格式]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2Fis_json%2F</url>
    <content type="text"><![CDATA[is_json.py1234567891011121314151617181920212223242526272829#!/usr/bin/env python#-*-coding:utf-8-*-import jsonimport sysimport osimport globscript_path = os.path.split(os.path.realpath(__file__))[0]def is_json(json_file): try: with open(json_file,&apos;r&apos;) as f: load_dict = json.load(f) print(json_file + &apos; True&apos;) except Exception as e: print(json_file + &apos; ERROR&apos;) print(e)def json_list(): try: json_name = sys.argv[1] json_list = [] for json_name in sys.argv[1:]: json_list.append(json_name) except: json_list = glob.glob(os.path.join(script_path,&apos;*.json&apos;)) return json_list[is_json(json_file) for json_file in json_list()]]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python里的特殊方法]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2Fpython%E9%87%8C%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[特殊方法是什么是一种具有特殊魅力的正常方法，python通过这些方法可以赋予你的class魔力。 这些魔法方法 都是以双下划线__作为 前缀和后缀。 初始化__new__()创造实例， __init__()初始化实例。 __init__() 是一个类 (class) 的第一个方法，也叫构造函数。 是第一个被创建，但不是第一个被执行的。 __new__() 才是最早被调用的方法 __new__() : 先读取参数( 如类名称,args,和kwargs）, 然后 new() 方法把这些参数传递给 __init__() , __new__(class_name, args, kwargs) __init__() : 类的初始化方法或构造方法, 几乎用于 全局的初始化目的。 __init__(slef, args, kwargs) __del__() : 类的析构函数，定义一个对象被垃圾回收的行为。 __del__(self) 12345678910111213141516171819202122232425262728293031323334353637class SimpleInit: def __new__(cls): print(&quot;__new__ is called&quot;) return super(SimpleInit, cls).__new__(cls) # 不过与python3.7后的dataclass 不兼容，dataclass 机制得好好看一下 def __init__(self, value=10): print(&apos;__init__ is called&apos;) print(&quot;self is: &quot;, self) self._list = [value] def __del__(self): print(self._list) del self._list print(self._list)a = SimpleInit()a.__del__()&apos;&apos;&apos;输出如下：__new__ is called # __new__()创造实例， __init__()初始化实例__init__ is calledself is: &lt;__main__.SimpleInit object at 0x0000017E8A132470&gt;[10]---------------------------------------------------------------------------AttributeError Traceback (most recent call last)&lt;ipython-input-22-3666a9307d4d&gt; in &lt;module&gt;----&gt; 1 a.__del__()&lt;ipython-input-21-cb926d3eed30&gt; in __del__(self) 12 print(self._list) 13 del self._list---&gt; 14 print(self._list) 15 16 a = SimpleInit()AttributeError: &apos;SimpleInit&apos; object has no attribute &apos;_list&apos;&apos;&apos;&apos; 算术运算,增量赋值 __add__(self.other) + __iadd__(self.other) += __sub__(self.other) - __isub__(self.other) -= __mul__(self.other) * __imul__(self.other) *= __floordiv__(self.other) // __ifloordiv__(self.other) //= __div__(self.other) / __idiv__(self.other) /= __mod__(self.other) % __imod__(self.other) %= __and__(self.other) &amp; __iand__(self.other) &amp;= __or__(self.other) | __ior__(self.other) |= __xor__(self.other) ^ __ixor__(self.other) ^= __pow__(self.other) ** __ipow__(self.other) **= __lshift__(self.other) &lt;&lt; __ilshift__(self.other) &lt;&lt;= __rshift__(self.other) &gt;&gt; __irshift__(self.other) &gt;&gt;=1234567891011121314from dataclasses import dataclass, field@dataclassclass Simpleadder: _elements:list = list def __add__(self, other): return self._elements + other._elementsa = Simpleadder([1,2,3,4,5])b = Simpleadder([4,5,6,7,8])print(a, b) # Simpleadder(_elements=[1, 2, 3, 4, 5]) Simpleadder(_elements=[4, 5, 6, 7, 8])print(a + b) # [1, 2, 3, 4, 5, 4, 5, 6, 7, 8] 比较运算python3.7 可使用dataclass __eq__(self.other) == __ne__(self.other) != __lt__(self.other) &lt; __gt__(self.other) &gt; __le__(self.other) &lt;= __ge__(self.other) &gt;= 类型转换 __int__(self) int __long__(self) long __float__(self) float __complex__(self) complex __oct__(self) octal (八进制) __hex__(self) (十六进制) __index__(self) 转为int, 当对象被用于切片表达式 最常用 __str__(self) __repr__(self) 类似__str__() str()主要用于人类可读, repr() 机器可读 __hash__(self) 定义了行为调用hash() __len__(self) 返回容器长度 __getitem__(self) setitem(self) __delitem__(self) 定义一个删除一个项目的行为 __iter__(self) 返回一个迭代容器 __call__(self) 使实例能够像函数一样被调用，同时不影响实例本身的生命周期 __call__()不影响一个实例的构造和析构。但是__call__()可以用来改变实例的内部成员的值123456789101112131415from dataclasses import dataclass@dataclass()class X: a:int b:int range:int def __call__(self): print(&apos;__call__ with （&#123;&#125;, &#123;&#125;）&apos;.format(self.a, self.b))x = X(1,2,3)print(x)x() # 把实例直接当函数调用]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python里的一些函数]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2Fpython%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[参考 1. lambda 函数 （匿名函数）没有函数名的函数12x = lambda a,b : a*bprint(x(2,3)) 2. Map 函数Map() 是 python 里的内置函数，它可以将 函数应用于各种数据结构中的元素123x = map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10,11])print(x) # &lt;map object at 0x00000255474D24A8&gt; 迭代器print(list(x)) # [3, 7, 11, 15, 19] 3. filter 函数与 map()类似，但只返回True的元素1234567891011numbers = [1, 2, 3, 4, 5, 6, 7, 8]def filter_odd_numbers(num): if num % 2 == 0: return True else: return False filtered_numbers = filter(filter_odd_numbers, numbers)print(filtered_numbers) # &lt;filter object at 0x00000237EFD62438&gt; print(list(filtered_numbers)) # [2, 4, 6, 8] 4. any(),all()123x = [0, 2, 1]print(all(x)) # Falseprint(any(x)) # True 5. zip()zip() 函数 用于将可迭代对象作为参数，将对象中对应的元素打包成一个个元组，然后返回这些元组组成的列表12345678910keys = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]values = [1, 2, 3, 3]zipped = dict(zip(keys, values))print(zipped) # &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3, &apos;d&apos;: 3&#125;d = &#123;k:v for k,v in zip(zipped.values(),zipped.keys())&#125;print(d) # &#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;d&apos;&#125;# 根据字典值的大小，对字典的项从大到小排序print(dict(sorted(d.items(),key=lambda x:x[1],reverse=True))) # &#123;3: &apos;d&apos;, 2: &apos;b&apos;, 1: &apos;a&apos;&#125;]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[装饰器]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[绝大多数装饰器都是基于函数和 闭包 实现的，但这并非制造装饰器的唯一方式. Python 对某个对象是否能通过装饰器（@decorator）形式使用只有一个要求：decorator 必须是一个“可被调用（callable）的对象123def foo(): passtype(foo) # functioncallable(foo) # True 只要自定义类的 __call__ 魔法方法即可让任意类变成可被调用123456789101112131415161718from dataclasses import dataclass@dataclass()class X: a:int b:int range:int def __call__(self): # 定义类的 `__call__` 方法 print(&apos;__call__ with （&#123;&#125;, &#123;&#125;）&apos;.format(self.a, self.b)) def __del__(self): del self.a del self.b del self.rangex = X(1,2,3)x() # 像函数一样调用 1234567891011121314151617181920212223242526272829303132333435363738import timeimport randomimport functoolsdef timer(wrapped): &quot;&quot;&quot;装饰器：记录并打印函数耗时&quot;&quot;&quot; @functools.wraps(wrapped) # 可以使函数保持原有签名 def decorated(*args, **kwargs): st = time.time() ret = wrapped(*args, **kwargs) print(&apos;execution take: &#123;&#125; seconds&apos;.format(time.time() - st)) return ret return decorateddef counter(func): &quot;&quot;&quot;装饰器：记录并打印调用次数&quot;&quot;&quot; count = 0 @functools.wraps(func) def decorated(*args, **kwargs): # 次数累加 nonlocal count count += 1 print(f&quot;Count: &#123;count&#125;&quot;) return func(*args, **kwargs) return decorated@counter@timerdef random_sleep(): &apos;德玛西亚&apos; time.sleep(random.random())random_sleep()random_sleep()print(random_sleep.__name__)print(random_sleep.__doc__) 1234567891011121314151617181920def provide_number(min_num, max_num): &quot;&quot;&quot;装饰器：随机生成一个在 [min_num, max_num] 范围的整数，追加为函数的第一个位置参数 &quot;&quot;&quot; def wrapper(func): def decorated(*args, **kwargs): num = random.randint(min_num, max_num) # 将 num 作为第一个参数追加后调用函数 return func(num, *args, **kwargs) return decorated return wrapper@provide_number(1, 100)def print_random_number(num): print(num) wrapt 模块是一个专门帮助编写装饰器的工具库。可以非常方便的改造 provide_number 装饰器，完美解决“嵌套层级深”和“无法通用”两个问题123456789101112131415161718192021222324252627282930import wraptimport randomdef provide_number(min_num, max_num): @wrapt.decorator def wrapper(wrapped, instance, args, kwargs): # 参数含义： # # - wrapped：被装饰的函数或类方法 # - instance： # - 如果被装饰者为普通类方法，该值为类实例 # - 如果被装饰者为 classmethod 类方法，该值为类 # - 如果被装饰者为类/函数/静态方法，该值为 None # # - args：调用时的位置参数（注意没有 * 符号） # - kwargs：调用时的关键字参数（注意没有 ** 符号） # num = random.randint(min_num, max_num) # 无需关注 wrapped 是类方法或普通函数，直接在头部追加参数 args = (num,) + args return wrapped(*args, **kwargs) return wrapper@provide_number(1,100)def number(num): print(num)number() 1234567891011121314151617181920212223242526272829303132333435import timeimport functoolsclass DelayFunc: def __init__(self, duration, func): self.duration = duration self.func = func def __call__(self, *args, **kwargs): print(f&apos;Wait for &#123;self.duration&#125; seconds...&apos;) time.sleep(self.duration) return self.func(*args, **kwargs) def eager_call(self, *args, **kwargs): print(&apos;Call without delay&apos;) return self.func(*args, **kwargs)def delay(duration): &quot;&quot;&quot;装饰器：推迟某个函数的执行。同时提供 .eager_call 方法立即执行 &quot;&quot;&quot; # 此处为了避免定义额外函数，直接使用 functools.partial 帮助构造 # DelayFunc 实例 return functools.partial(DelayFunc, duration)@delay(duration=2)def add(a, b): return a + b# 这次调用将会延迟 2 秒print(add(1, 2))# 这次调用将会立即执行print(add.eager_call(1, 2)) # 还是进入了类，duration=2， 但调用类里面的eager_call()方法直接返回函数 123456def add(a, b): return a + bimport functoolsadd_3 = functools.partial(add, 3)print(add_3(1))]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python拾遗_函数]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2Fpython%E6%8B%BE%E9%81%97_%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数 函数有机会给一组语句命名 函数可以减少重复代码 一长段程序可以拆分为多个函数，组合起来使用 一次书写, 多次调用。 在函数内部 实参会赋值给形参的变量 12345def print_twice(x): print(x) print(x)a = print_twice(&apos;haha&apos;)a == None # True # 没有return,返回None 只会实现函数作用 增量开发每次只增加和测试一小部分代码，来避免长时间的调试过程 eg: 圆心坐标(x1,y1)例如(0,0),圆上一点的坐标(x2,y2)例如(2,2), 计算圆的面积。 圆的面积 12345import mathdef area(radius): return math.pi * radius **2a = area(2) # a 等于return的值print(area(2),a) 圆的半径 123456789def distance(x1, y1, x2, y2): &apos;&apos;&apos; 计算两点之间的距离 文档字符串，一般用来简明的解释函数是用来做什么的 &apos;&apos;&apos; dx = x2 -x1 dy = y2 -y1 # 临时变量，在计算中可以用来保存中间计算值 dsquared = dx ** 2 + dy ** 2 result = math.sqrt(dsquared) # 脚手架代码，构建时有用，最终可以删除 return result 计算结果 12radius = distance(x1, y1, x2, y2)result = area(radius) 封装成一个函数1234def circle_area(x1, y1, x2, y2): radius = distance(x1, y1, x2, y2) result = area(radius) return result 简化123def circle_area(x1, y1, x2, y2): return area(distance(x1, y1, x2, y2))circle_area(0, 0, 2, 2) # 25.132741228718352 递归调用自己的函数称为 递归的函数，执行过程称为递归 无限递归,会在递归深度到上限时报错123def recurse(): recurse()recurse() # RecursionError: maximum recursion depth exceeded 123456def print_n(s, n): if n &lt;= 0: retrun print(s) print_n(s,n-1)print_n(&apos;haha&apos;, 5) 12345678910def countdown(n): if n &gt; 100000: # 守卫,保护后面代码，避免出现错误 print(&apos;over limit&apos;) return elif n &lt;= 0: print(&apos;haha&apos;) else: print(n) countdown(n-1)countdown(10000000000000) while 循环123456789def countdown(n): if n &gt; 100000: # 守卫,保护后面代码，避免出现错误 print(&apos;over limit&apos;) return while n &gt; 0: print(n) n -= 1 print(&apos;haha&apos;)countdown(10000000000000) 12345while 1: line = input(&apos;&gt;&apos;) if line == &apos;done&apos;: break # 使用 break 退出循环 print(line)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java简介]]></title>
    <url>%2Fjava%2Freadme%2F</url>
    <content type="text"><![CDATA[java简介Java分为三个体系： JavaSE(J2SE)(Java2 Platform Standard Edition，java平台标准版) JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版) JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版) 开发环境配置(windows下)java下载 下载后安装，配置系统环境变量 此电脑 &gt; 右键属性 &gt; 高级 &gt; 环境变量12345678变量名：JAVA_HOME变量值：C:\Program Files (x86)\Java\jdk1.8.0_91 // 要根据自己的实际路径配置变量名：CLASSPATH变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; //记得前面有个&quot;.&quot;变量名：Path变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;windows10 变量值已有的上面点开，然后新建加到下方，以免破坏原有的环境变量 重启后生效 测试JDK是否安装成功 “开始”-&gt;”运行”，键入”cmd”； 键入命令: java -version、java、javac 几个命令]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java基础语法]]></title>
    <url>%2Fjava%2Fjava%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[hello worldHelloWorld.java (源文件名必须和类名相同)12345678public class HelloWorld &#123; /* 第一个Java程序. * 它将打印字符串 Hello World */ public static void main(String []args) &#123; // 主方法入口：所有的Java 程序由public static void main(String args[])方法开始执行 System.out.println(&quot;Hello World&quot;); // 打印 Hello World &#125;&#125; （cmd在java文件的同一路径下） 编译 javac -encoding utf-8 HelloWorld.java (含中文最好使用 -encoding utf-8编译，以免出现错误) 运行 java HelloWorld 打印 HelloWorld 类和对象123456789101112131415161718192021222324252627public class Puppy&#123; // Puppy 类 一个源文件中只能有一个public类 int puppyAge; public Puppy(String name)&#123; // 这个构造器仅有一个参数：name System.out.println(&quot;Passed Name is :&quot; + name ); &#125; public void setAge( int age )&#123; puppyAge = age; &#125; public int getAge( )&#123; System.out.println(&quot;Puppy&apos;s age is :&quot; + puppyAge ); return puppyAge; &#125; public static void main(String []args)&#123; /* 创建对象 */ Puppy myPuppy = new Puppy( &quot;tommy&quot; ); // 声明：声明一个对象，包括对象名称和对象类型 实例化：使用关键字new来创建一个对象 初始化：使用new创建对象时，会调用构造方法初始化对象 /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println(&quot;Variable Value :&quot; + myPuppy.puppyAge ); &#125;&#125; importEmployee.java1234567891011import java.io.*; //下面的命令行将会命令编译器载入java_installation/java/io路径下的所有类public class Employee&#123; //salary是静态的私有变量 private static double salary; // DEPARTMENT是一个常量 public static final String DEPARTMENT = &quot;Development &quot;; public static void main(String args[])&#123; salary = 1000; System.out.println(DEPARTMENT+&quot;average salary:&quot;+salary); &#125;&#125; EmployeeTest.java1234567891011121314151617181920import java.io.*;public class EmployeeTest&#123; public static void main(String args[])&#123; /* 使用构造器创建两个对象 */ Employee empOne = new Employee(&quot;James Smith&quot;); Employee empTwo = new Employee(&quot;Mary Anne&quot;); // 调用这两个对象的成员方法 empOne.empAge(26); empOne.empDesignation(&quot;Senior Software Engineer&quot;); empOne.empSalary(1000); empOne.printEmployee(); empTwo.empAge(21); empTwo.empDesignation(&quot;Software Engineer&quot;); empTwo.empSalary(500); empTwo.printEmployee(); &#125;&#125; 编译后，执行EmployeeTest就可以得到结果]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java修饰符]]></title>
    <url>%2Fjava%2F%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Java修饰符主要分为以下两类： 访问修饰符 非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端 123456789public class className &#123; // ...&#125;private boolean myFlag;static final double weeks = 9.5;protected static final int BOXWIDTH = 42;public static void main(String[] arguments) &#123; // 方法体&#125; 访问控制修饰符默认访问修饰符-不使用任何关键字使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为public static final,而接口里的方法默认情况下访问权限为public。1234String version = &quot;1.5.1&quot;;boolean processOrder() &#123; return true;&#125; 私有访问修饰符-private私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。 声明为私有访问类型的变量只能通过类中公共的getter方法被外部类访问。 Private访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。123456789public class Logger &#123; private String format; public String getFormat() &#123; return this.format; &#125; public void setFormat(String format) &#123; this.format = format; &#125;&#125; 公有访问修饰符-public被声明为public的类、方法、构造方法和接口能够被任何其他类访问。 如果几个相互访问的public类分布在不同的包中，则需要导入相应public类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。123public static void main(String[] arguments) &#123; // ...&#125; 受保护的访问修饰符-protected被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。 Protected访问修饰符不能修饰类和接口，方法和成员变量能够声明为protected，但是接口的成员变量和成员方法不能声明为protected。 子类能访问Protected修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。 下面的父类使用了protected访问修饰符，子类重载了父类的openSpeaker()方法 1234567891011class AudioPlayer &#123; protected boolean openSpeaker(Speaker sp) &#123; // 实现细节 &#125;&#125;class StreamingAudioPlayer &#123; boolean openSpeaker(Speaker sp) &#123; // 实现细节 &#125;&#125; 如果把openSpeaker()方法声明为private，那么除了AudioPlayer之外的类将不能访问该方法。如果把openSpeaker()声明为public，那么所有的类都能够访问该方法。如果我们只想让该方法对其所在类的子类可见，则将该方法声明为protected。 访问控制和继承请注意以下方法继承的规则： 父类中声明为public的方法在子类中也必须为public。 父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。 父类中声明为private的方法，不能够被继承。非访问修饰符 static : 用来创建类方法和类变量。 final : 用来修饰类、方法和变量，final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract : 用来创建抽象类和抽象方法。 synchronized和volatile : 主要用于线程的编程。 static修饰符 静态变量 ： 也被称为类变量。用来声明独立于对象的静态变量,局部变量不能被声明为static变量 静态方法 ： 来声明独立于对象的静态方法12345678910111213141516171819202122public class InstanceCounter &#123; private static int numInstances = 0; protected static int getCount() &#123; return numInstances; &#125; private static void addInstance() &#123; numInstances++; &#125; InstanceCounter() &#123; InstanceCounter.addInstance(); &#125; public static void main(String[] arguments) &#123; System.out.println(&quot;Starting with &quot; + InstanceCounter.getCount() + &quot; instances&quot;); for (int i = 0; i &lt; 500; ++i)&#123; new InstanceCounter(); &#125; System.out.println(&quot;Created &quot; + InstanceCounter.getCount() + &quot; instances&quot;); &#125; &#125; final修饰符final变量:12345678910public class Test&#123; final int value = 10; // 下面是声明常量的实例 public static final int BOXWIDTH = 6; static final String TITLE = &quot;Manager&quot;; public void changeValue()&#123; value = 12; //将输出一个错误 &#125;&#125; final方法:类中的Final方法可以被子类继承，但是不能被子类修改。 声明final方法的主要目的是防止该方法的内容被修改12345public class Test&#123; public final void changeName()&#123; // 方法体 &#125;&#125; final类： 不能被继承123public final class Test &#123; // 类体&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java变量类型]]></title>
    <url>%2Fjava%2F%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[变量类型在Java语言中 局部变量 实例变量 类变量 所有的变量在使用前必须声明。声明变量的基本格式如下： type identifier [ = value][, identifier [= value] ...] ; 12345int a, b, c; // 声明三个int型整数：a、b、c。int d = 3, e, f = 5; // 声明三个整数并赋予初值。byte z = 22; // 声明并初始化z。double pi = 3.14159; // 声明了pi。char x = &apos;x&apos;; // 变量x的值是字符&apos;x&apos;。 局部变量123456789101112public class Test&#123; public void pupAge()&#123; int age = 0; // age是一个局部变量。定义在pupAge()方法中，它的作用域就限制在这个方法中 age = age + 7; System.out.println(&quot;Puppy age is : &quot; + age); &#125; public static void main(String args[])&#123; Test test = new Test(); test.pupAge(); &#125;&#125; 实例变量1234567891011121314151617181920212223242526import java.io.*;public class Employee&#123; // 这个成员变量对子类可见 public String name; // 私有变量，仅在该类可见 private double salary; //在构造器中对name赋值 public Employee (String empName)&#123; name = empName; &#125; //设定salary的值 public void setSalary(double empSal)&#123; salary = empSal; &#125; // 打印信息 public void printEmp()&#123; System.out.println(&quot;name : &quot; + name ); System.out.println(&quot;salary :&quot; + salary); &#125; public static void main(String args[])&#123; Employee empOne = new Employee(&quot;Ransika&quot;); empOne.setSalary(1000); empOne.printEmp(); &#125;&#125; 类变量12345678910111213import java.io.*;public class Employee&#123; //salary是静态的私有变量 private static double salary; // DEPARTMENT是一个常量 public static final String DEPARTMENT = &quot;Development &quot;; public static void main(String args[])&#123; salary = 1000; System.out.println(DEPARTMENT+&quot;average salary:&quot;+salary); &#125;&#125;// 如果其他类想要访问该变量，可以这样访问：Employee.DEPARTMENT]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java基本数据类型]]></title>
    <url>%2Fjava%2F%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本数据类型两大数据类型： 内置数据类型 引用数据类型 内置数据类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class PrimitiveTypeTest &#123; public static void main(String[] args) &#123; // byte System.out.println(&quot;基本类型：byte 二进制位数：&quot; + Byte.SIZE); System.out.println(&quot;包装类：java.lang.Byte&quot;); System.out.println(&quot;最小值：Byte.MIN_VALUE=&quot; + Byte.MIN_VALUE); System.out.println(&quot;最大值：Byte.MAX_VALUE=&quot; + Byte.MAX_VALUE); System.out.println(); // short System.out.println(&quot;基本类型：short 二进制位数：&quot; + Short.SIZE); System.out.println(&quot;包装类：java.lang.Short&quot;); System.out.println(&quot;最小值：Short.MIN_VALUE=&quot; + Short.MIN_VALUE); System.out.println(&quot;最大值：Short.MAX_VALUE=&quot; + Short.MAX_VALUE); System.out.println(); // int System.out.println(&quot;基本类型：int 二进制位数：&quot; + Integer.SIZE); System.out.println(&quot;包装类：java.lang.Integer&quot;); System.out.println(&quot;最小值：Integer.MIN_VALUE=&quot; + Integer.MIN_VALUE); System.out.println(&quot;最大值：Integer.MAX_VALUE=&quot; + Integer.MAX_VALUE); System.out.println(); // long System.out.println(&quot;基本类型：long 二进制位数：&quot; + Long.SIZE); System.out.println(&quot;包装类：java.lang.Long&quot;); System.out.println(&quot;最小值：Long.MIN_VALUE=&quot; + Long.MIN_VALUE); System.out.println(&quot;最大值：Long.MAX_VALUE=&quot; + Long.MAX_VALUE); System.out.println(); // float System.out.println(&quot;基本类型：float 二进制位数：&quot; + Float.SIZE); System.out.println(&quot;包装类：java.lang.Float&quot;); System.out.println(&quot;最小值：Float.MIN_VALUE=&quot; + Float.MIN_VALUE); System.out.println(&quot;最大值：Float.MAX_VALUE=&quot; + Float.MAX_VALUE); System.out.println(); // double System.out.println(&quot;基本类型：double 二进制位数：&quot; + Double.SIZE); System.out.println(&quot;包装类：java.lang.Double&quot;); System.out.println(&quot;最小值：Double.MIN_VALUE=&quot; + Double.MIN_VALUE); System.out.println(&quot;最大值：Double.MAX_VALUE=&quot; + Double.MAX_VALUE); System.out.println(); // char System.out.println(&quot;基本类型：char 二进制位数：&quot; + Character.SIZE); System.out.println(&quot;包装类：java.lang.Character&quot;); // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台 System.out.println(&quot;最小值：Character.MIN_VALUE=&quot; + (int) Character.MIN_VALUE); // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台 System.out.println(&quot;最大值：Character.MAX_VALUE=&quot; + (int) Character.MAX_VALUE);&#125;&#125; 引用数据类型 引用类型变量由类的构造函数创建，可以使用它们访问所引用的对象。这些变量在声明时被指定为一个特定的类型，比如Employee、Pubby等。变量一旦声明后，类型就不能被改变了。 对象、数组都是引用数据类型。 所有引用类型的默认值都是null。 一个引用变量可以用来引用与任何与之兼容的类型。 例子：Animal animal = new Animal(“giraffe”） 常量1final double PI = 3.1415927; //常量指不能改变的量,用final标志,通常用大写标识 123int decimal = 100; // 十进值int octal = 0144; // 8进值int hexa = 0x64; // 16进值 字符串双引号 123&quot;Hello World&quot;&quot;two\nlines&quot;&quot;\&quot;This is in quotes\&quot;&quot; 12char a = &apos;\u0001&apos;; // 变量a 的值为 &apos;\u0001&apos;String a = &quot;\u0001&quot;;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java分支结构]]></title>
    <url>%2Fjava%2F%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[if elseIfElse.java12345678910111213141516171819public class Test &#123; public static void main(String args[])&#123; int x = 30; if( x == 10 )&#123; System.out.print(&quot;Value of X is 10&quot;); &#125; else if( x == 20 )&#123; System.out.print(&quot;Value of X is 20&quot;); &#125; else if( x == 30 )&#123; System.out.print(&quot;Value of X is 30&quot;); &#125; else&#123; System.out.print(&quot;这是 else 语句&quot;); &#125; &#125;&#125; 嵌套的if…else语句12345678910111213public class Test &#123; public static void main(String args[])&#123; int x = 30; int y = 10; if( x == 30 )&#123; if( y == 10 )&#123; System.out.print(&quot;X = 30 and Y = 10&quot;); &#125; &#125; &#125;&#125; switch语句1234567891011121314151617181920212223242526public class Test &#123; public static void main(String args[])&#123; //char grade = args[0].charAt(0); char grade = &apos;C&apos;; switch(grade) &#123; case &apos;A&apos; : System.out.println(&quot;优秀&quot;); break; case &apos;B&apos; : case &apos;C&apos; : System.out.println(&quot;良好&quot;); break; case &apos;D&apos; : System.out.println(&quot;及格&quot;); case &apos;F&apos; : System.out.println(&quot;你需要继续努力&quot;); break; default : System.out.println(&quot;无效等级&quot;); &#125; System.out.println(&quot;你的等级是 &quot; + grade); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java运算符]]></title>
    <url>%2Fjava%2F%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Java 运算符主要分为一下几种 算术运算符 关系运算符 位运算符 逻辑运算符 赋值运算符 其他运算符 算术运算符ArithmeticOperator.java1234567891011121314151617181920public class ArithmeticOperator &#123; public static void main(String args[]) &#123; int a = 10; int b = 20; int c = 25; int d = 25; System.out.println(&quot;a + b = &quot; + (a + b) ); System.out.println(&quot;a - b = &quot; + (a - b) ); System.out.println(&quot;a * b = &quot; + (a * b) ); System.out.println(&quot;b / a = &quot; + (b / a) ); System.out.println(&quot;b % a = &quot; + (b % a) ); System.out.println(&quot;c % a = &quot; + (c % a) ); System.out.println(&quot;a++ = &quot; + (a++) ); System.out.println(&quot;a-- = &quot; + (a--) ); // 查看 d++ 与 ++d 的不同 System.out.println(&quot;d++ = &quot; + (d++) ); // 当前语句后 +1 System.out.println(&quot;++d = &quot; + (++d) ); // 当前语句前 +1 &#125; &#125; 关系运算符RelationalOperator.java12345678910111213public class RelationalOperator &#123; public static void main(String args[]) &#123; int a = 10; int b = 20; System.out.println(&quot;a == b = &quot; + (a == b) ); System.out.println(&quot;a != b = &quot; + (a != b) ); System.out.println(&quot;a &gt; b = &quot; + (a &gt; b) ); System.out.println(&quot;a &lt; b = &quot; + (a &lt; b) ); System.out.println(&quot;b &gt;= a = &quot; + (b &gt;= a) ); System.out.println(&quot;b &lt;= a = &quot; + (b &lt;= a) ); &#125; &#125; 逻辑运算符LogicalOperators.java123456789public class LogicalOperators &#123; public static void main(String args[]) &#123; boolean a = true; boolean b = false; System.out.println(&quot;a &amp;&amp; b = &quot; + (a&amp;&amp;b)); System.out.println(&quot;a || b = &quot; + (a||b) ); System.out.println(&quot;!(a &amp;&amp; b) = &quot; + !(a &amp;&amp; b)); &#125; &#125; 赋值运算符AssignmentOperator.java123456789101112131415161718public class AssignmentOperator &#123; public static void main(String args[]) &#123; int a = 10; int b = 20; int c; c = a + b; System.out.println(&quot;c = a + b is &quot; + (a + b)); System.out.println(&quot;c += a is &quot; + (c+=a) ); System.out.println(&quot;c -= a is &quot; + (c -=a)); System.out.println(&quot;c *= a is &quot; + (c *= a)); a = 10; c = 15; System.out.println(&quot;c /= a is &quot; + (c/=a) ); a = 10; c = 15; System.out.println(&quot;c %= a is &quot; + (c %= a)); &#125; &#125; 条件运算符ConditionalOperator.java12345678910public class ConditionalOperator &#123; public static void main(String args[])&#123; int a , b; a = 10; b = (a == 1) ? 20: 30; // 不成立 System.out.println( &quot;Value of b is : &quot; + b ); // 30 b = (a == 10) ? 20: 30; // 成立 System.out.println( &quot;Value of b is : &quot; + b ); // 20 &#125;&#125; instanceOf 运算符Car.java123456789class Vehicle &#123;&#125;public class Car extends Vehicle &#123; // Car 继承了Vehicle所有属性和方法 public static void main(String args[])&#123; Vehicle a = new Car(); boolean result = a instanceof Car; // 被比较的对象兼容于右侧类型,该运算符仍然返回true System.out.println( result); // true &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安装Chrome浏览器和ChromeDriver]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F%E5%AE%89%E8%A3%85Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8CChromeDriver%2F</url>
    <content type="text"><![CDATA[一、 安装Chrome浏览器1、安装依赖 sudo apt-get install libxss1 libappindicator1 libindicator7 2、下载Chrome安装包 (最新稳定版) wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 3、安装 12sudo dpkg -i google-chrome*.debsudo apt-get install -f 二、安装ChromeDriver1、安装xvfb以便我们可以无头奔跑地运行Chrome sudo apt-get install xvfb 2、安装依赖 sudo apt-get install unzip 3、下载安装包 wget -N http://chromedriver.storage.googleapis.com/2.26/chromedriver_linux64.zip 要下载对应版本 http://chromedriver.storage.googleapis.com/index.html 4、解压缩+添加执行权限 unzip chromedriver_linux64.zip 5、移动 sudo mv -f chromedriver /usr/local/share/chromedriver 6、建立软连接 sudo ln -s /usr/local/share/chromedriver /usr/local/bin/chromedriversudo ln -s /usr/local/share/chromedriver /usr/bin/chromedriver 三、无头运行Chrome1、安装Python依赖 pip3 install selenium pip3 install pyvirtualdisplay]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go的package与import]]></title>
    <url>%2Fgolang%2Fpackage%E4%B8%8Eimport%2F</url>
    <content type="text"><![CDATA[package package 是最基本的分发单位 和 工程管理中依赖关系的体现 每个 GO 语言源代码文件开头 都拥有一个 package 声明，表示源代码所属的代码包 要生成 GO 语言可执行程序，必须要有main 的 package包，且必须在该包下 有 main()函数 同一个路径下(文件夹) 只能存在 一个 package, 一个package 可以拆分为多个源文件组成 import 原理此处需要插图 import 导入包的几种方式：点，别名与下划线在写Go代码的时候经常用到import这个命令用来导入包文件，看到的方式参考如下：123import( &quot;fmt&quot;) 然后在代码里面可以通过如下的方式调用fmt.Println(&quot;hello world&quot;) 上面这个fmt是Go语言的标准库，他其实是去GOROOT下去加载该模块，当然Go的import还支持如下两种方式来加载自己写的模块： 相对路径 import &quot;./model&quot; // 当前文件同一目录的model目录，但是不建议这种方式import 绝对路径 import &quot;shorturl/model&quot; // 加载GOPATH/src/shorturl/model模块 三种导入包的使用方法。 点操作import( . &quot;fmt&quot; )可以省略前缀的包名，fmt.Println(&quot;hello world&quot;) 可以省略的写成Println(“hello world”) 别名操作import( f &quot;fmt&quot; ) 调用包函数时前缀变成了重命名的前缀，即f.Println(“hello world”) _ 操作import ( &quot;database/sql&quot; _ &quot;github.com/ziutek/mymysql/godrv&quot; ) _操作其实只是引入该包。即使用_操作引用包是无法通过包名来调用包中的导出函数，而是只是为了简单的调用其init函数()]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go基础语法]]></title>
    <url>%2Fgolang%2F%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一般结构12345678910111213141516171819202122232425// 当前程序的包名package main// 导入其他包import . &quot;fmt&quot;// 常量定义const PI = 3.14// 全局变量的声明和赋值var name = &quot;gopher&quot;// 一般类型声明type newType int// 结构的声明type gopher struct&#123;&#125;// 接口的声明type golang interface&#123;&#125;// 由main函数作为程序入口点启动func main() &#123; Println(&quot;Hello World!&quot;)&#125; 变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport &quot;fmt&quot;var x1, y1 intvar ( // 这种因式分解关键字的写法一般用于声明全局变量 a1 int b1 bool)var c1, d1 int = 1, 2var e1, f1 = 123, &quot;hello&quot;var h1 int // 全局变量 允许声明但不使用// e1 := &quot;weilai&quot; // 只能被用在函数体内，而不可以用于全局变量的声明与赋值func main() &#123; /* 多行注释 */ // 一行注释 var a string = &quot;weilai&quot; // 声明一个变量并初始化 var b, c int = 1, 2 // 一次声明多个变量： var d int // 声明变量，不初始化，一般情况下，值类型默认为 0, 布尔类型默认值为 false ,string 默认值为空字符串 &apos;&apos; var z bool // bool 0值 false fmt.Println(z) fmt.Println(a) // 打印 a 换行 fmt.Print(b, c) // 不会换行 fmt.Println(d) fmt.Println(&quot;hello&quot;) // 会换行 fmt.Println(&quot;world&quot; ) fmt.Print(&quot;hello&quot;) fmt.Print(&quot;world&quot;) // var e int 这行存在 下行就会报错就会报错 no new variables on left side of := e := &quot;weilai&quot; // 等同于 var e string = &quot;weilai&quot; // 使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明 f, g := 20, 30 f, g = g, f // 如果你想要交换两个变量的值，，两个变量的类型必须是相同。 // h := 40 // 声明但未使用 局部变量 会报错 fmt.Println(&quot;e=&quot;, e , &quot;,f=&quot; , f , &quot;,g=&quot; , g) fmt.Printf(&quot;e=%s,f=%d,g=%d&quot; , e , f , g) // Printf 是格式化输出 var vname1, vname2, vname3 = &quot;v1&quot;, &quot;v2&quot;, &quot;v3&quot; fmt.Printf(vname1, vname2, vname3) println(x1, y1, a1, b1, c1, d1, e1, f1) _,numb,strs := numbers() //只获取函数返回值的后两个 fmt.Println(numb,strs)&#125;//一个可以返回多个值的函数func numbers()(int,int,string)&#123; a , b , c := 1 , 2 , &quot;str&quot; return a,b,c&#125;/*falseweilai1 20helloworldhelloworlde= weilai ,f= 30 ,g= 20e=weilai,f=30,g=20v1%!(EXTRA string=v2, string=v3)0 0 0 false 1 2 123 hello2 str*/]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go简介]]></title>
    <url>%2Fgolang%2Freadme%2F</url>
    <content type="text"><![CDATA[简介GO 语言特点 运行效率高，开发高效，部署简单 （可直接编译成机器码，不依赖其他库，glibc的版本有一定要求，部署就是扔一个文件上去就完成了） 语言层面支持并发，易于利用多核实现并发 （最大特点） 内置runtime（作用：性能监控，GC等），支持垃圾回收 丰富标准库，强大网络库 内置强大的工具（gofmt）,跨平台编译，内嵌C支持 GO 语言的应用 服务器编程，以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。 分布式系统，数据库代理器等 网络编程，这一块目前应用最广，包括Web应用、API应用、下载应用、 内存数据库，前一段时间google开发的groupcache，couchbase的部分组建 云平台，目前国外很多云平台在采用Go开发，CloudFoundy的部分组建，前VMare的技术总监自己出来搞的apcera云平台。 GO 语言命令行工具 go build 用于编译源码文件，代码包，依赖包; go run 可以编译并运行Go源码文件 go get 主要用来动态获取远程代码包]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go指针]]></title>
    <url>%2Fgolang%2F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[变量是一种使用方便的占位符，用于引用计算机内存地址。 Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址 123456789package mainimport &quot;fmt&quot;func main() &#123; var a int = 10 fmt.Printf(&quot;变量的地址: %x\n&quot;, &amp;a )&#125; 指针声明 : var var_name *var-type eg: var fp *float32 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; var a int= 20 /* 声明实际变量 */ var ip *int /* 声明指针变量 */ ip = &amp;a /* 指针变量的存储地址 */ fmt.Printf(&quot;a 变量的地址是: %x\n&quot;, &amp;a ) /* 指针变量的存储地址 */ fmt.Printf(&quot;ip 变量的存储地址: %x\n&quot;, ip ) /* 使用指针访问值 */ fmt.Printf(&quot;*ip 变量的值: %d\n&quot;, *ip )&#125; 空指针 :当一个指针被定义后没有分配到任何变量时，它的值为 nil123456789package mainimport &quot;fmt&quot;func main() &#123; var ptr *int var ptr1 * fmt.Printf(&quot;ptr 的值为 : %x\n&quot;, ptr ) /* 0 */&#125;]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go规范]]></title>
    <url>%2Fgolang%2F%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[变量声明，初始化，赋值 同一行声明多个变量并赋值： var a,b,c int =1,2,3 或者 d,e := 4,5 全局变量声明必须使用var关键字,局部变量可以省略（a,b,c int =1,2,3） 变量 _ 表示丢弃变量类型转换 类型转换必须是显示的，不存在隐式转换 只发生在兼容类型之间 &lt;变量名称&gt; [:]= &lt;目标类型&gt;(&lt;需要转换的变量&gt;)123456789101112131415package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)func main()&#123; var a float32 = 3.1 c := int(a) fmt.Println(c) fmt.Println(reflect.TypeOf(c)) &#125; 变量可见性规则 大写字母开头的变量可导出，其他包可以读取，是共有变量 小写字母开头的变量不可导出，是私有变量 常量常量定义形式常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型 显示 const identifier [type] = value 隐式 const identifier = value (通常叫做 无类型常量) 常量可以使用 内置表达式定义 eg: len(),unsafe.Size0f()等 特殊常量 iota iota 在 const 关键字出现时被重置为 0 const 中每新增一行常量声明 iota 就计数一次 iota 只能在常量中使用 iota 常见使用法： 跳值使用法 插队使用法 表达式隐式使用法 单行使用法]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[docker]]></title>
    <url>%2Fdocker%2Freadme%2F</url>
    <content type="text"><![CDATA[dockerLinux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离 Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口 Docker 将应用程序与该程序的依赖，打包在一个文件(image)里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样.容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例 docker 安装123456curl https://get.docker.com &gt; /tmp/install.shchmod +x /tmp/install.sh/tmp/install.shsudo usermod -aG docker rootservice docker restartservice docker status 快速确认docker version 第一个镜像1docker run debian echo &quot;hello world&quot; docker run : 启动容器 debian : 使用的镜像名称 （在docker hub 进行搜素，并下载最新版） echo “hello world” : 执行的命令 1docker run -i -t debian /bin/bash -i -t : 附有一个 tty 的交互会话 -i 支持stdin , -t 终端或伪终端 /bin/bash : 获得一个 bash shell 退出 shell, 容器就会停止 12345678910docker run --name weilai -h docker -i -t debian /bin/bash # -h 指定hostname --name 指定docker namedocker inspect weilai # 获取 weilai 容器的更多信息doker diff weilai # 查看 weilai 文件的更改docker logs weilai # weilai 容器里曾经发生的事情docker ps # 正在运行的 docker 容器docker ps -a # 列出所有容器docker start weilai # 启动已有容器 docker run 是启动一个新的实例 docker attach weilai # 切换到运行交互式容器docker stop weilai # 停止容器docker rm weilai docker run；创建和启动一个新的容器实例，操作对象是镜像，选项较多，如果你要创建和启动一个容器，只能用run；docker exec: 在已运行的容器中，执行命令，操作对象是容器，如果你要进入已运行的容器，并且执行命令，用exec；docker attach: 同样操作的是已运行的容器，可以将本机标准输入（键盘输入）输到容器中，也可以将容器的输出显示在本机的屏幕上，如果你想查看容器运行过程中产生的标准输入输出，用attach；]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python操作安装redis]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fredis%2Fpython%E6%93%8D%E4%BD%9Credis%2F</url>
    <content type="text"><![CDATA[1. 准备工作 安装好 redis 和 RedisPy库 RedisDump 可以用来做数据导入或导出2. RedisPy库RedisPy库 提供两个类 redis 和 StrictRedis 来实现 Redis 的命令操作。 StrictRedis 实现了绝大部分官方命令，参数也一一对应。 redis 是 StrictRedis 的子类，主要功能是用于向后兼容旧版本库里的几个方法。 推荐使用 StrictRedis 连接 Redis12345from redis import StrictRedis# localhost port=6379 默认数据库 password=passwordredis = StrictRedis(host=&apos;localhost&apos;, port=6379, db=0, password=&apos;password&apos;) redis.set(&apos;name&apos;, &apos;weilai&apos;)print(redis.get(&apos;name&apos;)) 使用ConnectionPool 连接 1234567from redis import StrictRedis, ConnectionPoolpool = ConnectionPool(host=&apos;localhost&apos;, port=6379, db=0, password=password)# localhost port=6379 默认数据库 password=passwordredis = StrictRedis(connection_pool=pool) #redis.set(&apos;name&apos;, &apos;weilai&apos;)print(redis.get(&apos;name&apos;)) ConnectionPool 还支持通过 url 来构建 123redis://[:password]@host:port/db # tcprediss://[:password]@host:port/db # tcp +ssl unix://[:password]@/path/to/socket.sock?db=db # UNIX socket 连接 eg:1234url = &apos;redis://:password@localhost:6379/0&apos;pool = ConnectionPool.from_url(url)redis = StrictRedis(connection_pool=pool) print(redis.get(&apos;name&apos;)) 类 改写1234567891011121314151617181920212223242526272829303132333435363738394041import redisclass TestString: def __init__(self): self.r = redis.StrictRedis(host=&apos;localhost&apos;, port=6379, db=0) def test_set(self): result = self.r.set(&apos;name2&apos;,&apos;weilai2&apos;) print(result) return result def test_get(self): result = self.r.get(&apos;name2&apos;) print(result) return result def test_mset(self): d = &#123; &apos;name3&apos; : &apos;user3&apos;, &apos;name4&apos; : &apos;user4&apos; &#125; result = self.r.mset(d) print(result) return result def test_mget(self): l = [&apos;name3&apos;, &apos;name4&apos;] result = self.r.mget(l) print(result) return resultdef main(): str_obj = TestString() str_obj.test_set() str_obj.test_get() str_obj.test_mset() str_obj.test_mget()if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker安装redis]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fredis%2Fdocker%E5%AE%89%E8%A3%85redis%2F</url>
    <content type="text"><![CDATA[docker search redis 查询镜像 docker pull redis 拉取官方镜像 docker images 查看一下是否成功 启动镜像 4.1. 下载并凭需求修改redis.conf，配置文件放在/opt/data/redis/目录下4.2 docker启动redis 12$ mkdir -p /opt/data/redis$ docker run -p 6379:6379 --name myredis -v /opt/data/redis/redis.conf:/etc/redis/redis.conf -v /opt/data/redis:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes --requirepass &quot;passwd&quot; 命令解释说明：-p 6379:6379 ##端口映射，:前表示主机部分，:后表示容器部分。–name myredis ##指定容器名称，查看和进行操作都比较方便。 -v /opt/data/redis:/data ##将主机中/opt/data/redis目录下的redis挂载到容器的/data-v /opt/data/redis/redis.conf:/etc/redis/redis.conf ##将主机中redis.conf配置文件挂载到容器的/etc/redis/redis.conf文件中 -d redis 表示后台启动redisredis-server /etc/redis/redis.conf 以配置文件启动redis，加载容器内的conf文件，最终找到的是挂载的目录/opt/data/redis/redis.conf–appendonly yes 开启redis 持久化 –requirepass “passwd” 需要密码 docker ps 查看容器启动情况 连接redis的几种方式 1234567docker exec -ti myredis redis-cli # 或者用iddocker exec -ti myredis redis-cli -a &quot;passwd&quot;docker exec -ti myredis redis-cli -h localhost -p 6379 docker exec -ti myredis redis-cli -h 127.0.0.1 -p 6379 docker exec -ti myredis redis-cli -h 172.17.0.3 -p 6379 docker-compose.yml文件内容：123456789redis: image: redis container_name: test-redis restart: always ports: - 6379:6379 volumes: - /opt/data/redis:/data command: redis-server --appendonly yes --requirepass &quot;redis&quot; 客户端连接docker run --name myredis-cli -it redis:latest redis-cli -h 服务器 -p 6379ctrl + p + q后台运行再次进入docker exec -ti myredis-cli redis-cli -h 服务器 -p 6379]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis命令]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fredis%2F%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[键123456redis 127.0.0.1:6379&gt; SET weilai redis -- 设置键OKredis 127.0.0.1:6379&gt; DEL weilai -- 删除键(integer) 1redis 127.0.0.1:6379&gt; DEL weilai -- 删除键(integer) 0 # 删除失败]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis数据类型]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fredis%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[redis 数据类型Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。 stringstring类型是Redis最基本的数据类型，二进制安全的。redis的string可以包含任何数据，比如jpg图片或者序列化的对象，一个键最大能存储512MB12345# SET 设置键值 GET 获取键值redis 127.0.0.1:6379&gt; SET name &quot;weilai&quot; OKredis 127.0.0.1:6379&gt; GET name &quot;weilai&quot; mset 和 mget 设置（得到） 多个key的值1234567127.0.0.1:6379&gt; mset date &quot;2019.08.30&quot; time &quot;11:00 a.m.&quot; weather &quot;sunny&quot;OK127.0.0.1:6379&gt; mget date time name weather1) &quot;2019.08.30&quot;2) &quot;11:00 a.m.&quot;3) &quot;weilai&quot;4) &quot;sunny&quot; append 添加字符串1234127.0.0.1:6379&gt; append name &apos;1995&apos;(integer) 10127.0.0.1:6379&gt; GET name&quot;weilai1995&quot; del 删除1234127.0.0.1:6379&gt; del name(integer) 1127.0.0.1:6379&gt; get name(nil) incr/decr 增加/减少 1123456789101112127.0.0.1:6379&gt; set num 0OK127.0.0.1:6379&gt; get num&quot;0&quot;127.0.0.1:6379&gt; decr num(integer) -1127.0.0.1:6379&gt; get num&quot;-1&quot;127.0.0.1:6379&gt; incr num(integer) 0127.0.0.1:6379&gt; get num&quot;0&quot; HashRedis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。HMSET, HGETALL 命令 user:1 为键值12345678910111213141516171819202122232425262728293031323334353637383940414243redis 127.0.0.1:6379&gt; hmset user:1 username weilai password handsome OK127.0.0.1:6379&gt; hmget user:1 username password1) &quot;weilai&quot;2) &quot;handsome&quot;redis 127.0.0.1:6379&gt; HGETALL user:11) &quot;username&quot;2) &quot;weilai&quot;3) &quot;password&quot;4) &quot;handsome&quot;127.0.0.1:6379&gt; hmget user:1 username password port1) &quot;weilai&quot;2) &quot;handsome&quot;3) &quot;22&quot;redis 127.0.0.1:6379&gt; hget user:1 username&quot;weilai&quot;127.0.0.1:6379&gt; HGET user:1 weilai(nil)127.0.0.1:6379&gt; hkeys user:1 # 获取 key1) &quot;username&quot;2) &quot;password&quot;3) &quot;port&quot;127.0.0.1:6379&gt; hvals user:1 #获取 value1) &quot;weilai&quot;2) &quot;handsome&quot;3) &quot;22&quot;127.0.0.1:6379&gt; hlen user:1(integer) 3127.0.0.1:6379&gt; hexists user:1 password # 是否存在 passw(integer) 1127.0.0.1:6379&gt; hexists user:1 passwd(integer) 0 hdel user:1 password port(integer) 2127.0.0.1:6379&gt; hgetall user:11) &quot;username&quot;2) &quot;weilai&quot;127.0.0.1:6379&gt; hsetnx user:1 username fisher # 存在username 不创建(integer) 0127.0.0.1:6379&gt; hgetall user:1 1) &quot;username&quot;2) &quot;weilai&quot;# 每个 hash 可以存储 232 - 1 键值对（40多亿） ListRedis 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素lpush到列表的头部（左边）或者rpush尾部（右边）lrange 获取指定长度 （从0 开始） lpushx/rpushx 只能是 key 存在，且仅能添加一个 lpop/rpop 移除最左/右 边 的一个元素 ltrim 截取一段长度 llen 列表元素个数 lrem weilai 0 python 删除所有的’python’123456789101112131415161718192021222324252627282930313233343536373839404142redis 127.0.0.1:6379&gt; lpush weilai redis(integer) 1redis 127.0.0.1:6379&gt; lpush weilai mongodb(integer) 2redis 127.0.0.1:6379&gt; rpush weilai rabitmq(integer) 3redis 127.0.0.1:6379&gt; lrange weilai 0 101) &quot;mongodb&quot;2) &quot;redis&quot;3) &quot;rabitmq&quot;&quot;127.0.0.1:6379&gt; lrange weilai 0 11) &quot;mongodb&quot;2) &quot;redis&quot;127.0.0.1:6379&gt; llen weilai(integer) 3127.0.0.1:6379&gt; lpush weilai python java c++ shell(integer) 8127.0.0.1:6379&gt; lrange weilai 0 10 1) &quot;shell&quot;2) &quot;c++&quot;3) &quot;java&quot;4) &quot;python&quot;5) &quot;mongodb&quot;6) &quot;redis&quot;7) &quot;rabitmq&quot;127.0.0.1:6379&gt; lrem weilai 0 python # 删除所有的python 元素(integer) 1127.0.0.1:6379&gt; lrange weilai 0 10 1) &quot;shell&quot;2) &quot;c++&quot;3) &quot;java&quot;4) &quot;mongodb&quot;5) &quot;redis&quot;6) &quot;rabitmq&quot;127.0.0.1:6379&gt; ltrim weilai 2 4OK127.0.0.1:6379&gt; lrange weilai 0 101) &quot;java&quot;2) &quot;mongodb&quot;3) &quot;redis&quot;# 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿) SetRedis的Set是string类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1) sadd/srem 添加/删除元素sismember 判断是否为set的一个元素smembers 返回该集合的所有成员sdiff 返回一个集合与其它集合的差异sinter 返回几个集合的交集sunion 返回几个集合的并集 12345678910111213141516171819202122232425262728293031323334353637127.0.0.1:6379&gt; sadd zoo cat dog(integer) 2127.0.0.1:6379&gt; sadd zoo cat dog fisher(integer) 1127.0.0.1:6379&gt; smembers zoo1) &quot;fisher&quot;2) &quot;dog&quot;3) &quot;cat&quot;127.0.0.1:6379&gt; srem zoo cat(integer) 1127.0.0.1:6379&gt; srem zoo cat(integer) 0127.0.0.1:6379&gt; sismember zoo cat(integer) 0127.0.0.1:6379&gt; sismember zoo fisher(integer) 1127.0.0.1:6379&gt; smembers zoo1) &quot;fisher&quot;2) &quot;dog&quot;127.0.0.1:6379&gt; sadd zoo1 dog cow(integer) 2127.0.0.1:6379&gt; smembers zoo11) &quot;cow&quot;2) &quot;dog&quot;127.0.0.1:6379&gt; sdiff zoo zoo11) &quot;fisher&quot;127.0.0.1:6379&gt; sdiff zoo1 zoo1) &quot;cow&quot;127.0.0.1:6379&gt; sinter zoo1 zoo1) &quot;dog&quot;127.0.0.1:6379&gt; sunion zoo1 zoo1) &quot;fisher&quot;2) &quot;dog&quot;3) &quot;cow&quot;# 添加一个string元素到,key对应的set集合中，成功返回1,如果元素以及在集合中返回0,key对应的set不存在返回错误。集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员) zset(sorted set：有序集合)Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 zset的成员是唯一的,但分数(score)却可以重复 12345678910111213redis 127.0.0.1:6379&gt; zadd weilai 0 redis(integer) 1redis 127.0.0.1:6379&gt; zadd weilai 0 mongodb(integer) 1redis 127.0.0.1:6379&gt; zadd weilai 0 rabitmq(integer) 1redis 127.0.0.1:6379&gt; zadd weilai 10 redis -- 添加元素到集合，元素在集合中存在则更新对应score(integer) 0redis 127.0.0.1:6379&gt; ZRANGEBYSCORE weilai 0 10001) &quot;redis&quot;2) &quot;mongodb&quot;3) &quot;rabitmq&quot;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis简介与安装]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fredis%2F%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[简介Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份 Redis运行在内存中但是可以持久化到磁盘(性能极高)，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存. 主要用途 ： 数据库，缓存和消息中间件 安装12345678910111213141516171819202122232425wget http://download.redis.io/releases/redis-5.0.5.tar.gztar xzf redis-5.0.5.tar.gzcd redis-5.0.5make ./redis-server # 启动redis服务./redis-server redis.conf # 依据配置，启动redis服务./redis-cli # 使用测试客户端程序redis-cli和redis服务交互# eg:$ ./redis-cliredis&gt; pingPONG # 以上操作代表 redis已经安装完成。# 在远程服务器上执行命令redis-cli -h host -p port -a passwordeg:$redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;redis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; PINGPONG 配置 redis.conf可以通过修改 redis.conf 文件或使用 CONFIG set 命令(CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE)来修改配置 eg：123456redis 127.0.0.1:6379&gt; CONFIG SET loglevel &quot;notice&quot;OKredis 127.0.0.1:6379&gt; CONFIG GET loglevel1) &quot;loglevel&quot;2) &quot;notice&quot; 具体配置信息参考文档]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis安全性能测试客户端连接管道技术]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fredis%2F%E5%AE%89%E5%85%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[安全查看是否设置密码12345127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;&quot;# 默认没有设置 设置密码12345127.0.0.1:6379&gt; CONFIG set requirepass &quot;mypassword&quot;OK127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;mypassword&quot; 设置密码后，客户端连接 redis 服务就需要密码验证，否则无法执行命令。 123456127.0.0.1:6379&gt; AUTH &quot;mypassword&quot;OK127.0.0.1:6379&gt; SET mykey &quot;Test value&quot;OK127.0.0.1:6379&gt; GET mykey&quot;Test value&quot; 性能测试Redis 性能测试是通过同时执行多个命令实现的redis-benchmark [option] [option value] 1234redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 100000 -qSET: 146198.83 requests per secondLPUSH: 145560.41 requests per second 客户端连接Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作： 首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。 然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法 然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送 1234config get maxclients1) &quot;maxclients&quot;2) &quot;10000&quot; 启动时设置最大连接数1redis-server --maxclients 100000 管道技术Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤： 客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。服务端处理命令，并将结果返回给客户端。 Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。12345678$(echo -en &quot;PING\r\n SET MYkey redis\r\nGET MYkey\r\nINCR visitor\r\nINCR visitor\r\nINCR visitor\r\n&quot;; sleep 10) | nc localhost 6379+PONG+OKredis:1:2:3]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据备份与恢复]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fredis%2F%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[备份Redis SAVE 命令用于创建当前数据库的备份12redis 127.0.0.1:6379&gt; SAVE OK 该命令将在 redis 安装目录中创建dump.rdb文件 BGSAVE后台执行123127.0.0.1:6379&gt; BGSAVEBackground saving started 恢复将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务123redis 127.0.0.1:6379&gt; CONFIG GET dir -- CONFIG 命令获取 redis目录1) &quot;dir&quot;2) &quot;/usr/local/redis/bin&quot;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb常用命令]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmongodb%2Fmongodb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.mongo连入本机数据库 2.mongo 10.66.66.126:27017连入ip地址为10.66.66.126的机器的数据库 3.db / db.getName()查看当前数据库(db就是Database) 4.use demo切换/创建数据库(demo为数据库名) 5.show dbs查看所有数据库show tables查看所有表集合 6.db.dropDatabase()删除当前操作的数据库 7.db.copyDatabase(“mydb”, “temp”, “127.0.0.1”)从指定的机器上复制指定数据库数据到某个数据库，将本机的mydb的数据复制到temp数据库中 8.db.repairDatabase()修复当前数据库 9.db.version()当前db版本 10.db.stats()显示当前db状态 11.db.getMongo()查看当前db的链接机器地址 12.数据库表 (Collection聚集集合 ) 1)创建一个表 db.createCollection(“collName”, {size: 20, capped: 5, max: 100}) 2)得到指定名称的表 db.getCollection(&quot;table&quot;) 3)查询当前db的所有表名的集合 db.getCollectionNames() 4)显示当前db所有表索引的状态 db.printCollectionStats() 13.查数据 1)查询某表中所有记录(如果数据太多分页查看输出 it 回车) db.table.find() 相当于：select * from table; db.table.find().pretty() 查看的数据格式化 db.table.find({}, {id: 0, “name”: 0}) 查询表中所有数据,id和name字段不返回 db.table.find({}, {id: 1, “name”: 1}) 查询表中所有数据,id和name字段返回(默认返回) 2)查询某张表中的某个字段的重复数据(会过滤掉name字段中相同的数据) db.table.distinct(&quot;name&quot;) 相当于: select distinct name from table; 3)查询某张表中&quot;name&quot;=&quot;Bill&quot;的数据 db.table.find({&quot;name&quot;=&quot;Bill&quot;}) 相当于：select * from table where name = Bill; 4)查询某张表中 id &gt; 1 的数据 ($gt &gt;, $lt &lt;，$gte &gt;=, $lte &lt;=, $ne !=) db.table.find({id: {$gt: 1}}) 相当于: select * from table where id &gt; 1; 5)查询某张表中 id &gt; 1 $$ id &lt;= 5的数据 db.table.find({id: {$gt: 1,$lte: 5}}) 相当于： select * from table where (id &gt; 1 and id &lt;= 5); 6)查询某张表中 name 中包含 li 的数据 db.table.find({name: /li/}) 相当于： select * from table where name like &apos;%li%&apos;; 7)查询某张表中 name 以 li 开头的数据 db.table.find({name: /^li/}) 相当于： select * from table where name like &apos;li%&apos;; 8)查询某张表中 name 以 li 结尾的数据 db.table.find({name: /li$/}) 相当于：select * from table where name like &apos;%li&apos;; 9)查询指定列 name 和 work 的数据 db.table.find({}, {name: 1, work: 1}) 相当于：select name, work from table; 10)查询 id &gt; 3 的指定列 name 和 work 的数据 db.table.find({id: {$gt: 3}}, {name: 1, work: 1}) 想当于： select name, work from table where id &gt; 3; 11)按照 number 大小 升序和降序查询 (1表示升序, -1表示降序) 升序: db.table.find().sort({number: 1}) 降序：db.table.find().sort({number: -1}) 12)查询前三条数据 db.table.find().limit(3) 相当于：select top 3 * from table; 13)查询前三条之后的数据 db.table.find().skip(3) 相当于：select * from table where id not in (select top 3 * from table); 14)查询前三条之后的5条数据 db.table.find().limit(5).skip(3) 15)查询 id=2 或者 id=5 的数据($or 或者, $in 包含, $nin 不包含) db.table.find({$or: [{id: 2}, {id: 5}]}) 相当于：select * from table where id = 2 or id = 5; 16)查询第一条数据 db.table.findOne() 相当于：select top 1 * from table; 17)查询 id &gt;= 5 的数据的个数 (count() 查询数量) db.table.find({id: {$gte: 5}}).count() 相当于：select count(*) from table where id &gt;= 5; 18)查询有 name字段 的数据的个数 db.table.find({name: {$exists: true}}).count() 相当于: select count(name) from table; 14.索引索引是为了快速查找数据用的,主要是用来降低CPU成本消耗的。索引相当于排序，但与排序不同的是，排序是将原数据重新排列，改变了原数据的排列顺序。而索引只是建立一个顺序表，由这个顺序表指出数据的顺序，所以索引不改变原数据的排列顺序。MongoDB支持的索引：_id索引(默认建立)、单键索引、多键索引、复合索引、过期索引、全文索引、地理位置索引此外，排序可能升序或降序排列，而索引只有升序一种方式。 1)创建索引 db.table.ensureIndex({name: 1}) db.table.ensureIndex({name: 1, ts: -1}) 2)查询当前聚集集合所有索引 db.table.getIndexes() 3)查看总索引记录大小 db.table.totalIndexSize() 4)读取当前集合的所有index信息 db.table.reIndex() 5)删除指定索引 db.table.dropIndex(&quot;name_1&quot;) 6)删除所有索引索引 db.table.dropIndexes() 15.添加数据 1)插入数据字段 db.table.insert({}) db.table.save({}) 2)导入数据表 mongoimport -d Lanyu -c shangpin --file D:\MongoDB\data\product.json --jsonArray -d: 数据库 -c: 表名 --file: 数据文件地址 --jsonArray: 导入json文件专用,否则导入失败, json文件格式：[{},{},{},{},{}] 16.修改数据 1)修改表中条件为 name : “baiqi” 的数据的 字段 number($set设置) db.table.update({name: “baiqi”}, {$set: {number: “111”}}, false, true) 第一个false表示不新增数据 相当于：update table set number = ‘111’ where name = “baiqi”; 2)修改表中条件为 name : &quot;mayun&quot; 的数据 让 number = number + 111, id = id + 2($inc自增) db.table.update({name: &quot;mayun&quot;}, {$inc: {number: 111, id: 2}}, false, true) 相当于：update table set number = number + 111, id = id + 2 where name = &quot;mayun&quot;; 3)综合上面两个修改 db.table.update({name: &apos;liuqiangdong&apos;}, {$inc: {id: 3}, $set: {number: 113}}, false, true) 相当于： update table set id = id + 3, number = 113 where name = &apos;liuqiangdong&apos;; 17.删除数据 db.table.remove({_id: ObjectId(“59a67e103cbae75d282fe46b”)}) 其他 1)查询之前的错误信息 db.getPrevError() 2)清除错误记录 db.resetError()]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[odm]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmongodb%2Fodm%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728from mongoengine import connect, Document, StringField, IntField, \ FloatField, EmbeddedDocument, ListField, EmbeddedDocumentField, DynamicDocument # 可以在后面插入其他关键字connect(&apos;test&apos;) # 连接的数据库# connect(&apos;test&apos;, host = &apos;192.168.0.2&apos;, port=27017)# connect(&apos;test&apos;, host = &apos;mongodb://localhost/test&apos;) SEX_CHOICE = ( (&apos;male&apos;, &apos;男&apos;), (&apos;female&apos;, &apos;女&apos;))class Grade(EmbeddedDocument): &apos;&apos;&apos; 成绩信息 &apos;&apos;&apos; name = StringField(required=True) score = FloatField(required=True)class Student(DynamicDocument): # 可以在后面插入其他关键字 &apos;&apos;&apos; 学生信息 &apos;&apos;&apos; name = StringField(max_length=32, required=True) age = IntField(required=True) sex = StringField(choices=SEX_CHOICE, required=True) grade = FloatField() address = StringField() grades = ListField(EmbeddedDocumentField(Grade)) # 与 Grade 关联 meta = &#123; &apos;collection&apos;: &apos;students&apos; # 指定连接的集合 &#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb入门]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmongodb%2F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介文档 eg: {“foo”:3,”greeting”:”Hello world!”} 区分大小写 key唯一 文档可嵌套 键值对 有序 集合 集合就是一组文档 文档类似于 关系库里的 行 集合类似于 关系库里的表 集合中的文档无需固定的结构 集合命名规则： 数据库 多个文档组成集合，多个集合组成数据库 一个实例 可以承载多个数据库 （可以理解为一个mongodb可以有多个数据库） 每个数据库都有独立权限 保留的数据库名称（admin,local,config） 使用命令行操作数据库兼容js操作 1+23function add(r1,r2){… return r1 + r2;… }add(8,2)10 新增数据show dbs 查看所有数据库db.collection.insert()db.collection.insertOne()db.collection.insertMany()123&gt; show dbsadmin 0.078GBlocal 0.078GB use test 使用 test 数据库 （没有就会创建）12345678910&gt; use studentsswitched to db students&gt; db # 查看当前数据库students&gt; stu = &#123; name : &apos;weilai&apos;, age : 22 &#125;&#123; &quot;name&quot; : &quot;weilai&quot;, &quot;age&quot; : 22 &#125;&gt; db.students.insert(stu)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.students.insert(&#123; &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot;: &quot;male&quot; &#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;) 查询数据db.collection.find()123&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5de8a491ff626673ec5503c9&quot;), &quot;name&quot; : &quot;weilai&quot;, &quot;age&quot; : 22 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8a554ff626673ec5503ca&quot;), &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125; db.collection.findOne()123456&gt; db.students.findOne() # 查询第一条数据&#123; &quot;_id&quot; : ObjectId(&quot;5de8a491ff626673ec5503c9&quot;), &quot;name&quot; : &quot;weilai&quot;, &quot;age&quot; : 22&#125; 修改数据db.collection.update()1234567891011121314&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5de8a491ff626673ec5503c9&quot;), &quot;name&quot; : &quot;weilai&quot;, &quot;age&quot; : 22 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8a554ff626673ec5503ca&quot;), &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125;&gt; s = db.students.findOne()&#123; &quot;_id&quot; : ObjectId(&quot;5de8a491ff626673ec5503c9&quot;), &quot;name&quot; : &quot;weilai&quot;, &quot;age&quot; : 22&#125;&gt; db.students.update(&#123;name:&apos;weilai&apos;&#125;,&#123;name:&apos;cool&apos;&#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5de8a491ff626673ec5503c9&quot;), &quot;name&quot; : &quot;cool&quot; &#125; # 直接替换，并非仅修改 name 的值&#123; &quot;_id&quot; : ObjectId(&quot;5de8a554ff626673ec5503ca&quot;), &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125; 仅修改值1234567891011121314&gt; s_obj = db.students.findOne(&#123;&apos;name&apos;:&apos;weilai1&apos;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;5de8a554ff626673ec5503ca&quot;), &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot;&#125;&gt; s_obj.name = &apos;amy&apos;amy&gt; db.students.update(&#123;name:&apos;weilai1&apos;&#125;,s_obj)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5de8a491ff626673ec5503c9&quot;), &quot;name&quot; : &quot;cool&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8a554ff626673ec5503ca&quot;), &quot;name&quot; : &quot;amy&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125; 删除数据db.collection.remove({name:&#39;cool&#39;}) 删除 1条数据db.collection.remove({}) 删除所有数据123456789101112131415&gt; db.students.insert(&#123; &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot;: &quot;male&quot; &#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5de8a491ff626673ec5503c9&quot;), &quot;name&quot; : &quot;cool&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8a554ff626673ec5503ca&quot;), &quot;name&quot; : &quot;amy&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8ae63ff626673ec5503cb&quot;), &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125;&gt; db.students.remove(&#123;name:&apos;cool&apos;&#125;)WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5de8a554ff626673ec5503ca&quot;), &quot;name&quot; : &quot;amy&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8ae63ff626673ec5503cb&quot;), &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125;&gt; db.students.remove(&#123;&#125;)WriteResult(&#123; &quot;nRemoved&quot; : 2 &#125;)&gt; db.students.find()&gt;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test_odm]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmongodb%2Ftest_odm%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from odm import Grade, Studentclass TestMongoEngine: def add_one(self): math = Grade(name = &apos;数学&apos;, score = 90) English = Grade(name = &apos;英语&apos;, score = 89.5) stu_obj = Student( name = &apos;weilai&apos;, age = 22, sex = &apos;male&apos;, grades = [math, English] ) stu_obj.remake = &apos;remake&apos; # 动态插入 stu_obj.save() return stu_obj def get_one(self): return Student.objects.first() def get_more(self): return Student.objects.all() def get_from_oid(self, oid): return Student.objects.filter(pk=oid).first() # 根据id 得到一条数据 def update_more(self): return Student.objects.filter(sex=&apos;male&apos;,age__gt=20).update(inc__age=10) def update_one(self): return Student.objects.filter(sex=&apos;male&apos;,age__gt=20).update_one(inc__age=100) def delete_one(self): return Student.objects.filter(sex=&apos;male&apos;).first().delete() def delete_more(self): return Student.objects.filter(sex=&apos;male&apos;).delete()def main(): obj = TestMongoEngine() result = obj.add_one() print(result.pk) get_one = obj.get_one() print(get_one.id) print(get_one.name) print(obj.get_from_oid(get_one.id).id) rows = obj.get_more() for row in rows: print(row.sex) print(obj.update_more()) print(obj.update_one()) print(obj.delete_one()) print(obj.delete_more())if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python操作MongoDB]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmongodb%2Fpython%E6%93%8D%E4%BD%9CMongoDB%2F</url>
    <content type="text"><![CDATA[python操作MongoDB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from pymongo import MongoClientfrom dataclasses import dataclassfrom bson.objectid import ObjectId@dataclassclass Test_Mongo(): client:dict = MongoClient() db:dict = client[&apos;test&apos;] # 连接到 test 数据库 def add_one(self): post = &#123; &apos;name&apos;: &apos;justin&apos;, &apos;age&apos;: 18, &apos;sex&apos;: &apos;male&apos;, &apos;grade&apos;: 80 &#125; return self.db.students.insert_one(post) def add_many(self): return self.db.students.insert_many([&#123;&apos;name&apos;:i&#125; for i in range(0,10)]) def get_one(self): return self.db.students.find_one(&#123;&apos;name&apos;:&apos;justin&apos;&#125;) def get_more(self): return self.db.students.find(&#123;&apos;sex&apos;:&apos;male&apos;&#125;) def get_one_from_oid(self, oid): obj = ObjectId(oid) return self.db.students.find_one(&#123;&apos;_id&apos;: obj&#125;) def get_count(self): return self.db.students.estimated_document_count() def update_one(self): return self.db.students.update_one(&#123;&apos;name&apos;:&apos;justin&apos;&#125;,&#123;&apos;$inc&apos;:&#123;&apos;age&apos;:10&#125;&#125;) def update_many(self): return self.db.students.update_many(&#123;&#125;,&#123;&apos;$inc&apos;:&#123;&apos;age&apos;:5&#125;&#125;) def delete_one(self): return self.db.students.delete_one(&#123;&apos;name&apos;:&apos;justin&apos;&#125;) def delete_many(self): return self.db.students.delete_many(&#123;&apos;name&apos;:&apos;justin&apos;&#125;)def main(): obj = Test_Mongo() print(obj.add_one().inserted_id) print(obj.get_one()) print(obj.add_many().inserted_ids) print(obj.get_count()) for item in obj.get_more(): print(item[&apos;_id&apos;]) print(obj.get_one_from_oid(obj.add_one().inserted_id)) print(obj.update_one().matched_count) print(obj.update_one().matched_count) print(obj.update_many().matched_count) print(obj.update_many().matched_count) print(obj.delete_one().deleted_count) print(obj.delete_many().deleted_count)if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb插入数据]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmongodb%2F%E5%85%A5%E9%97%A8%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[插入数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203&gt; use testswitched to db test&gt; db.students.insertMany(... [&#123;&quot;name&quot;: &quot;测试-0&quot;, &quot;age&quot;: 63, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 1&#125;,&#123;&quot;name&quot;: &quot;测试-1&quot;, &quot;age&quot;: 32, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 7&#125;,&#123;&quot;name&quot;: &quot;测试-2&quot;, &quot;age&quot;: 20, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 8&#125;,&#123;&quot;name&quot;: &quot;测试-3&quot;, &quot;age&quot;: 55, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 58&#125;,&#123;&quot;name&quot;: &quot;测试-4&quot;, &quot;age&quot;: 84, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 65&#125;,&#123;&quot;name&quot;: &quot;测试-5&quot;, &quot;age&quot;: 27, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 57&#125;,&#123;&quot;name&quot;: &quot;测试-6&quot;, &quot;age&quot;: 86, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 61&#125;,&#123;&quot;name&quot;: &quot;测试-7&quot;, &quot;age&quot;: 18, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 93&#125;,&#123;&quot;name&quot;: &quot;测试-8&quot;, &quot;age&quot;: 50, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 71&#125;,&#123;&quot;name&quot;: &quot;测试-9&quot;, &quot;age&quot;: 81, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 42&#125;,&#123;&quot;name&quot;: &quot;测试-10&quot;, &quot;age&quot;: 26, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 25&#125;,&#123;&quot;name&quot;: &quot;测试-11&quot;, &quot;age&quot;: 91, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 14&#125;,&#123;&quot;name&quot;: &quot;测试-12&quot;, &quot;age&quot;: 6, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 54&#125;,&#123;&quot;name&quot;: &quot;测试-13&quot;, &quot;age&quot;: 73, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 24&#125;,&#123;&quot;name&quot;: &quot;测试-14&quot;, &quot;age&quot;: 51, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 14&#125;,&#123;&quot;name&quot;: &quot;测试-15&quot;, &quot;age&quot;: 53, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 19&#125;,&#123;&quot;name&quot;: &quot;测试-16&quot;, &quot;age&quot;: 3, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 48&#125;,&#123;&quot;name&quot;: &quot;测试-17&quot;, &quot;age&quot;: 13, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 11&#125;,&#123;&quot;name&quot;: &quot;测试-18&quot;, &quot;age&quot;: 40, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 97&#125;,&#123;&quot;name&quot;: &quot;测试-19&quot;, &quot;age&quot;: 97, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 96&#125;])&#123; &quot;acknowledged&quot; : true, &quot;insertedIds&quot; : [ ObjectId(&quot;5de8b35c75deb540ecfc5332&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5333&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5334&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5335&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5336&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5337&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5338&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5339&quot;), ObjectId(&quot;5de8b35c75deb540ecfc533a&quot;), ObjectId(&quot;5de8b35c75deb540ecfc533b&quot;), ObjectId(&quot;5de8b35c75deb540ecfc533c&quot;), ObjectId(&quot;5de8b35c75deb540ecfc533d&quot;), ObjectId(&quot;5de8b35c75deb540ecfc533e&quot;), ObjectId(&quot;5de8b35c75deb540ecfc533f&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5340&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5341&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5342&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5343&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5344&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5345&quot;) ]&#125;&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5332&quot;), &quot;name&quot; : &quot;测试-0&quot;, &quot;age&quot; : 63, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 1 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5333&quot;), &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 32, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 7 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5334&quot;), &quot;name&quot; : &quot;测试-2&quot;, &quot;age&quot; : 20, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 8 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5335&quot;), &quot;name&quot; : &quot;测试-3&quot;, &quot;age&quot; : 55, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 58 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5336&quot;), &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 84, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 65 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5337&quot;), &quot;name&quot; : &quot;测试-5&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 57 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5338&quot;), &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 86, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5339&quot;), &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533a&quot;), &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 50, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533b&quot;), &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 81, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 42 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533c&quot;), &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 26, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 25 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533d&quot;), &quot;name&quot; : &quot;测试-11&quot;, &quot;age&quot; : 91, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533e&quot;), &quot;name&quot; : &quot;测试-12&quot;, &quot;age&quot; : 6, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 54 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533f&quot;), &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 73, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 24 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5340&quot;), &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 51, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5341&quot;), &quot;name&quot; : &quot;测试-15&quot;, &quot;age&quot; : 53, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 19 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5342&quot;), &quot;name&quot; : &quot;测试-16&quot;, &quot;age&quot; : 3, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 48 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5343&quot;), &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 13, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 11 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5344&quot;), &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 40, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5345&quot;), &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 97, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 96 &#125;&gt; db.students.find(&#123;sex:&apos;male&apos;&#125;,&#123;age:1,name:1,_id:0&#125;) # sex 为 male false 不显示， true 显示&#123; &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 32 &#125;&#123; &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 84 &#125;&#123; &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 81 &#125;&#123; &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 26 &#125;&#123; &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 73 &#125;&#123; &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 51 &#125;&#123; &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 13 &#125;&#123; &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 97 &#125;&gt; db.students.find(&#123;grade:&#123;&apos;$gte&apos;:60&#125;&#125;,&#123;_id:0&#125;) # grade 大于等于 60 &#123; &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 84, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 65 &#125;&#123; &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 86, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61 &#125;&#123; &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93 &#125;&#123; &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 50, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71 &#125;&#123; &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 40, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97 &#125;&#123; &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 97, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 96 &#125;&gt; db.students.find(&#123;&apos;$or&apos;:[&#123;sex:&apos;female&apos;,age:18&#125;,&#123;sex:&apos;male&apos;,age:81&#125;]&#125;,&#123;_id:0&#125;) # age =18,sex = famale 或 age = 81,sex = male&#123; &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93 &#125;&#123; &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 81, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 42 &#125;&gt; db.students.find().sort(&#123;age:-1&#125;) # 按 age 倒序 &#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5345&quot;), &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 97, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 96 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533d&quot;), &quot;name&quot; : &quot;测试-11&quot;, &quot;age&quot; : 91, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5338&quot;), &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 86, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5336&quot;), &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 84, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 65 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533b&quot;), &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 81, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 42 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533f&quot;), &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 73, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 24 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5332&quot;), &quot;name&quot; : &quot;测试-0&quot;, &quot;age&quot; : 63, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 1 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5335&quot;), &quot;name&quot; : &quot;测试-3&quot;, &quot;age&quot; : 55, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 58 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5341&quot;), &quot;name&quot; : &quot;测试-15&quot;, &quot;age&quot; : 53, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 19 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5340&quot;), &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 51, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533a&quot;), &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 50, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5344&quot;), &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 40, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5333&quot;), &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 32, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 7 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5337&quot;), &quot;name&quot; : &quot;测试-5&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 57 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533c&quot;), &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 26, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 25 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5334&quot;), &quot;name&quot; : &quot;测试-2&quot;, &quot;age&quot; : 20, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 8 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5339&quot;), &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5343&quot;), &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 13, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 11 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533e&quot;), &quot;name&quot; : &quot;测试-12&quot;, &quot;age&quot; : 6, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 54 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5342&quot;), &quot;name&quot; : &quot;测试-16&quot;, &quot;age&quot; : 3, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 48 &#125;&gt; db.students.find(&#123;&#125;,&#123;_id:0&#125;).sort(&#123;age:1&#125;) # 查询所有，不显示_id,按age 升序&#123; &quot;name&quot; : &quot;测试-16&quot;, &quot;age&quot; : 3, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 48 &#125;&#123; &quot;name&quot; : &quot;测试-12&quot;, &quot;age&quot; : 6, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 54 &#125;&#123; &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 13, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 11 &#125;&#123; &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93 &#125;&#123; &quot;name&quot; : &quot;测试-2&quot;, &quot;age&quot; : 20, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 8 &#125;&#123; &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 26, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 25 &#125;&#123; &quot;name&quot; : &quot;测试-5&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 57 &#125;&#123; &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 32, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 7 &#125;&#123; &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 40, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97 &#125;&#123; &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 50, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71 &#125;&#123; &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 51, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;name&quot; : &quot;测试-15&quot;, &quot;age&quot; : 53, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 19 &#125;&#123; &quot;name&quot; : &quot;测试-3&quot;, &quot;age&quot; : 55, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 58 &#125;&#123; &quot;name&quot; : &quot;测试-0&quot;, &quot;age&quot; : 63, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 1 &#125;&#123; &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 73, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 24 &#125;&#123; &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 81, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 42 &#125;&#123; &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 84, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 65 &#125;&#123; &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 86, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61 &#125;&#123; &quot;name&quot; : &quot;测试-11&quot;, &quot;age&quot; : 91, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 97, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 96 &#125;&gt; db.students.update(&#123;&#125;,&#123;&apos;$set&apos;:&#123;class:&apos;class 1&apos;&#125;&#125;) # 仅修改第一条数据WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)&gt; db.students.find(&#123;&#125;,&#123;_id:0&#125;)&#123; &quot;name&quot; : &quot;测试-0&quot;, &quot;age&quot; : 63, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 1, &quot;class&quot; : &quot;class 1&quot; &#125;&#123; &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 32, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 7 &#125;&#123; &quot;name&quot; : &quot;测试-2&quot;, &quot;age&quot; : 20, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 8 &#125;&#123; &quot;name&quot; : &quot;测试-3&quot;, &quot;age&quot; : 55, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 58 &#125;&#123; &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 84, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 65 &#125;&#123; &quot;name&quot; : &quot;测试-5&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 57 &#125;&#123; &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 86, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61 &#125;&#123; &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93 &#125;&#123; &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 50, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71 &#125;&#123; &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 81, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 42 &#125;&#123; &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 26, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 25 &#125;&#123; &quot;name&quot; : &quot;测试-11&quot;, &quot;age&quot; : 91, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;name&quot; : &quot;测试-12&quot;, &quot;age&quot; : 6, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 54 &#125;&#123; &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 73, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 24 &#125;&#123; &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 51, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;name&quot; : &quot;测试-15&quot;, &quot;age&quot; : 53, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 19 &#125;&#123; &quot;name&quot; : &quot;测试-16&quot;, &quot;age&quot; : 3, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 48 &#125;&#123; &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 13, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 11 &#125;&#123; &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 40, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97 &#125;&#123; &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 97, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 96 &#125;&gt; db.students.update(&#123;&#125;,&#123;&apos;$set&apos;:&#123;class:&apos;class 2&apos;&#125;&#125;,&#123;multi:true&#125;) # &#123;multi:true&#125; 多条属性WriteResult(&#123; &quot;nMatched&quot; : 20, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 19 &#125;)&gt; db.students.find(&#123;&#125;,&#123;_id:0&#125;)&#123; &quot;name&quot; : &quot;测试-0&quot;, &quot;age&quot; : 63, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 1, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 32, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 7, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-2&quot;, &quot;age&quot; : 20, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 8, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-3&quot;, &quot;age&quot; : 55, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 58, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 84, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 65, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-5&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 57, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 86, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 50, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 81, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 42, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 26, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 25, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-11&quot;, &quot;age&quot; : 91, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 14, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-12&quot;, &quot;age&quot; : 6, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 54, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 73, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 24, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 51, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 14, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-15&quot;, &quot;age&quot; : 53, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 19, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-16&quot;, &quot;age&quot; : 3, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 48, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 13, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 11, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 40, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 97, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 96, &quot;class&quot; : &quot;class 2&quot; &#125;&gt; db.students.update(&#123;&#125;,&#123;&apos;$inc&apos;:&#123;age:1&#125;&#125;,&#123;multi:true&#125;) # 所有人的age加1 WriteResult(&#123; &quot;nMatched&quot; : 20, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 20 &#125;)&gt; db.students.find(&#123;&#125;,&#123;_id:0&#125;) &#123; &quot;name&quot; : &quot;测试-0&quot;, &quot;age&quot; : 64, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 1, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 33, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 7, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-2&quot;, &quot;age&quot; : 21, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 8, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-3&quot;, &quot;age&quot; : 56, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 58, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 85, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 65, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-5&quot;, &quot;age&quot; : 28, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 57, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 87, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 19, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 51, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 82, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 42, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 25, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-11&quot;, &quot;age&quot; : 92, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 14, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-12&quot;, &quot;age&quot; : 7, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 54, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 74, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 24, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 52, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 14, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-15&quot;, &quot;age&quot; : 54, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 19, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-16&quot;, &quot;age&quot; : 4, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 48, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 14, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 11, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 41, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 98, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 96, &quot;class&quot; : &quot;class 2&quot; &#125;&gt; db.students.update(&#123;sex:&apos;male&apos;&#125;,&#123;&apos;$inc&apos;:&#123;grade:-1&#125;&#125;,&#123;multi:true&#125;) # sex:male 的grade 减1 WriteResult(&#123; &quot;nMatched&quot; : 8, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 8 &#125;)&gt; db.students.find(&#123;&#125;,&#123;_id:0&#125;)&#123; &quot;name&quot; : &quot;测试-0&quot;, &quot;age&quot; : 64, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 1, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 33, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 6, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-2&quot;, &quot;age&quot; : 21, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 8, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-3&quot;, &quot;age&quot; : 56, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 58, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 85, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 64, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-5&quot;, &quot;age&quot; : 28, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 57, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 87, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 19, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 51, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 82, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 41, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 24, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-11&quot;, &quot;age&quot; : 92, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 14, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-12&quot;, &quot;age&quot; : 7, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 54, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 74, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 23, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 52, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 13, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-15&quot;, &quot;age&quot; : 54, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 19, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-16&quot;, &quot;age&quot; : 4, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 48, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 14, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 10, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 41, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 98, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 95, &quot;class&quot; : &quot;class 2&quot; &#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb补充数据]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmongodb%2F%E5%85%A5%E9%97%A8%E8%A1%A5%E5%85%85%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021import randomimport jsona = &#123; &apos;name&apos; : &apos;weilai&apos;, &apos;age&apos; : 18, &apos;sex&apos;: &apos;male&apos;, &apos;grade&apos; : 45 &#125;list_json = []for i in range(0,20): a[&apos;name&apos;] = f&quot;测试-&#123;i&#125;&quot; a[&apos;age&apos;] = random.randint(0, 100) a[&apos;sex&apos;] = random.choice([&apos;male&apos;, &apos;female&apos;]) a[&apos;grade&apos;] = random.randint(0, 100) j = json.dumps(a, ensure_ascii=False) list_json.append(j)list_json = &apos;,&apos;.join(list_json)list_json = &apos;[&apos; + list_json +&apos;]&apos;print(list_json)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人计算机]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[计算机组成原理总结计算机系统简介计算机系统由“软件“及”硬件“组成，软件通常分为系统软件和应用软件。系统软件:用来管理整个计算机系统，监视服务，使系统资源得到合理调度，高效运行。应用软件:根据用户任务需求所编制的各种程序。 计算机系统的层次结构通常用户用高级语言编写程序，然后将它和数据一起送入计算机内，再由计算机将其翻译成机器能识别的机器语言程序，然后交由机器运行。 高级语言机器 → → 汇编语言机器 → →机器语言机器 或 高级语言机器 → → 机器语言机器 通常，将高级语言程序翻译成机器语言程序的软件成为翻译程序。翻译程序分为：编译程序，解释程序。编译程序：一次全部翻译成机器语言程序，然后交由机器执行。解释程序：边翻译，边执行。 高级语言机器 → → 汇编语言机器 → →机器语言机器 → →微指令系统 高级语言机器 → → 汇编语言机器 → →操作系统机器→ →机器语言机器 → →微指令系统 第1章：计算机系统概论1、计算机系统由哪两部分组成？计算机系统性能取决于什么？ 计算机系统是由“硬件”和“软件”组成。衡量一台计算机性能的优劣是根据多项技术指标综合确定的，既包括硬件的各种性能指标，又包括软件的各种功能。1）计算机系统由硬件和软件两部分组成。2）计算机系统性能由硬件和软件共同决定。 2、计算机系统5层层次结构从下到上由哪五层组成？哪些是物理机，哪些是虚拟机？ 1）微程序机器、传统机器、操作系统机器、汇编语言机器、高级语言机器2）微程序机器和传统机器是物理机，其他是虚拟机。 3、在计算机系统结构中，什么是翻译？什么是解释？ 1）翻译：将一种语言编写的程序全部翻译成另一种语言，然后再执行；2）解释：将一种语言编写的程序的一条语句翻译成另一种语言的一条或多条语句，然后执行，执行完这条语言后，再解释下一条。 4、什么是计算机体系结构？什么是计算机组成？以乘法指令为例说明二者区别。 1）计算机体系结构是指那些能够被程序员看到的计算机的属性。如指令集、数据类型等；2）计算机组成是指如何实现计算机体系结构所体现出来的属性；3）以乘法指令为例，计算机是否有乘法指令，属于体系结构的问题。乘法指令是采用专用的乘法器，还是使用加法器和移位器构成，属于计算机组成的问题。 5、冯诺依曼机器的主要特点？ 1）计算机由运算器、存储器、控制器、输入设备和输出设备五大部分组成；2）指令和数据存储在存储器中，并可以按地址访问；3）指令和数据均以二进制表示；4）指令由操作码和地址码构成，操作码指明操作的性质，地址码表示操作数在存储器中的位置；5）指令在存储器内按顺序存放，通常按自动的顺序取出执行；6）机器以运算器为中心，I/O设备与存储器交换数据也要通过运算器。（因此，后来有了以存储器为中心的计算机结构） 7、什么是存储单元、存储字、存储字长、存储体？ 存储单元：存储一个存储字并具有特定存储地址的存储单位；存储字：一个存储单元中存放的所有的二进制数据，按照某个地址访问某个存储单元获取的二进制数据。存储字长：存储字中二进制数据的位数，即按照某个地址访问某个存储单元获取的二进制数据的位数；存储体：由多个存储单元构成的存储器件。 8、主存储器中，什么是MAR，什么是MDR，存储器的最大容量由什么决定？ 1）MAR：存储地址寄存器，保存需要访问的存储单元地址。反映存储单元的个数。2）MDR：存储数据寄存器，缓存读出/写入存储单元的数据。反映存储字长。3）存储器的最大容量由MAR寄存器的位数和MDR寄存器的位数决定。 9、什么是机器字长，什么是存储字长长？ 机器字长：CPU一次能够处理的二进制数据的位数。存储字长：按照某个地址访问某个存储单元获取的二进制数据的位数。 10、假设MAR寄存器的位数为16位，MDR寄存器的位数为16位，存储器的最大容量是多少？ 1）MAR寄存器的位数为16位，能表示的地址个数为2的16次方，为64K；2）MDR寄存器的位数为16位，说明存储字长为16位，也即2个字节；3）存储器的最大容量为64K * 2B = 128K Byte 第三章 系统总线1、为什么要使用总线？ 在冯诺依曼结构中，各个部件之间均有单独连线，不仅线多，而且导致扩展I/O设备很不容易。即扩展一个I/O设备，需要连接很多线。因此，引入了总线连接方式，将多个设备连接在同一组总线上，构成设备之间的公共传输通道。 2、总线的两大基本特征是什么？ 1）共享：多个部件连接在同一组总线上，各个部件之间都通过该总线进行数据交换。2）分时：同一时刻，总线上只能传输一个部件发送的信息； 3、系统总线按照传输信息的不同，分成哪几类？是单向的，还是双向的？ 1）分成数据总线、地址总线以及控制总线。2）数据总线：各个功能部件之间传送数据信息，双向传输；3）地址总线：用来指明数据总线上，源数据或目的数据所在的主存单元的地址。单向：由CPU发出4）控制总线：用来发送各种控制信号。对于控制总线中的单根线，是单向的，即只能由一个部件发向另一个部件。而一组控制总线中，有输入也有输出，因此，控制总线也可以看成是双向的。 3、什么是总线宽度、总线带宽、总线复用、信号线数？ 1）总线宽度：数据总线的根数，一般是8的倍数。是衡量计算机系统性能的重要指标；2）总线带宽：即总线数据传输速率，总线上每秒能够传输的最大字节量。3）总线复用：一条信号线上分时传送两种信号。例如数据总线和地址总线的分时复用；4）信号线数：地址总线、数据总线和控制总线三种总线的线数之和。 4、假设总线的工作频率为33MHz，总线宽度为32位，则它最大的传输速率是多少？ 33 * （32/8） = 132 MB/s 5、简要说明单总线结构的概念及缺点？（现代计算机为什么要采用多总线结构？） 在单总线结构中，所有的部件（CPU、主存、I/O设备）都连接在一组总线上。但所有的信息传送都要通过这组总线，同时只能有一个部件向总线上发送信息，导致总线成为系统的瓶颈。因此，发展出来了多总线结构，其基本思想均是将速度相近的设备挂接在同一组总线上，总线之间通过总线控制器相连。例如CPU和Cache之间、I/O设备之间等。 6、集中式总线判优控制有哪三种方式，哪种方式的优先级不能改变？ 1）链式查询、计数器定时查询、以及独立请求。2）链式查询的优先级不能改变，离控制器最近的优先级最高。 8、什么是总线周期，分为哪几个阶段？ 1）总线周期：总线上两个部件完成一次完整且可靠的数据传输时间；2）分为四个阶段：申请分配阶段：申请总线寻址阶段：发出地址及有关命令传数阶段：进行数据交换结束：从总线上撤除信号，让出总线 9、什么是总线通信控制，总线通信控制有哪几种？ 1）总线通信控制：解决通信双方如何获知传输开始和传输结束，以及如何协调配合；2）同步通信、异步通信、半同步通信、分离式通信 10、什么是同步通信？其优点和缺点？ １）同步通信：总线上各个部件由统一的时钟信号控制；在总线周期中，每个时钟周期各个部件如何动作都有明确的规定。２）优点：速度快，各个模块间配合简单３）缺点：以总线上最慢的部件来设计公共时钟，影响总线效率。 11、什么是异步通信？异步通信分为哪几种类型？ 1）异步通信：总线上各部件没有统一的时钟标准，采用应答式通信；（主模块发出请求后，一直等到从模块反馈回来应答信号之后才开始通信）2）不互锁、半互锁、全互锁。（需要了解各种方式的含义） 12、什么是波特率？什么是比特率？（需要掌握如何计算波特率、比特率） 波特率：单位时间内传送的二进制数据数据的位数，单位bps比特率：单位时间内传送的有效的二进制位数。 13、异步通信时，常规需要设置的参数有哪些？ 波特率、停止位（1/2/1.5）、校验位（奇校验、偶校验、无校验） 14、简述半同步通信的基本原理。 半同步通信结合同步通信和异步通信。同步通信：采用统一的时钟，规定了在一定的时钟周期干什么事情；异步通信：如果从模块没有准备好，增加一个“等待响应”信号。 15、简述分离式通信的基本原理。 主模块发出地址和命令之后，放弃总线，在从模块准备数据期间，使得总线可以被其他设备所用。提高总线利用率。但是，这种方式控制比较复杂。 16、奇偶校验可以纠错吗？汉明码可以纠错码？ 1）奇偶校验只能检错，不能纠错。2）汉明码可以纠错。 第四章 存储器1、存储器按存取方式，可以分成哪四类？哪些属于随机访问存储器，哪些属于串行访问存储器？ 1）可以分为随机存储器、只读存储器、顺序存储器和直接存储器；2）随机存储器和只读存储器属于随机存储器，即存取时间与物理地址无关；3）顺序存储器（典型的如磁带）和直接存储器（典型的如磁盘）属于串行存储器，即存取时间与物理地址有关。 2、衡量存储器使用哪三个指标？寄存器、缓存、主存中，哪个速度最快？哪个最便宜？ 1）速度、容量、位价格。2）寄存器速度最快，主存最便宜。 3、常见的存储系统层次结构有哪两种？透明性如何？各自用来解决什么问题的？ 1）缓存-主存层次：用来缓解CPU和主存速度不匹配的问题，由硬件来完成，对所有的程序员完全透明。2）主存-辅存层次：用来解决主存容量不够的问题，由操作系统和硬件共同完成，对应用程序设计者透明，对系统程序设计者不透明。（现在一般存储器都即能按字访问，也能按照字节访问，因此，存储器编址时，每个字节都有一个独立的地址。） 4、字在存储单元中有两种存储方式，大端方式和小端方式。各是什么含义？x86采用的是哪种存储方式？ 1）大端方式：字的低位存在内存的高地址中，而字的高位存在内存的低地址中；2）小端方式：字的低位存在内存的低地址中，而字的高位存在内存的高地址中。3）x86CPU采用的是小端方式。 5、主存的三个主要技术指标 存储容量、存取速度和存储带宽 6、什么是存取时间？什么是存取周期？哪个大？ 1）存取时间：启动一次存储器完成本次操作（读或写）所需的时间；2）存取周期：连续两次启动存储器所需要的最小间隔时间；3）存取周期包含存取时间； 7、什么是存储器带宽？（要了解如何计算存储器带宽） 单位时间内存储器存取的信息量； 8、半导体存储芯片译码驱动包含哪两种方式，请简要说明。 1）线选法：所有的地址芯片通过一个译码器译码，选择一个存储单元的各位，适合于存储容量不大的芯片；2）重合法：将地址分为两组，每组通过一个译码器译码，选择行或列，行、列交叉处就是要访问的存储位。 9、随机存储器包含哪两大类？哪个需要刷新？请从速度、容量、价格等方面进行简要比较。 1）静态RAM：采用锁存器原理实现；2）动态RAM：采用电容原理实现，需要刷新。3）相比于动态RAM，静态RAM的速度快、容量小、价格高，一般用于缓存，而动态RAM一般用于内存。 10、只读存储器有哪几种？ 1）掩模ROM（MROM）：出厂后内容不能被更改。2）PROM：可编程只读存储器，可以进行一次性编程；3）EPROM：可擦除只读ROM，用紫外线照射；4）EEPROM：电可擦除只读ROM。6）FLash Memory：采用EEPROM的非易失性存储器。 11、单片存储器芯片的容量有限，很难满足实际需要，因此必须将若干存储芯片连接在一起才能组成足够容量的存储器。存储器的扩展通常有位扩展和字扩展，什么是字扩展，什么是位扩展？请举例简要说明 1）位扩展：增加存储器的字长，例如两个1K 4位的存储芯片构成1个1K8位的存储器；2）字扩展：增加存储器的字数，例如两个1K 8位的存储芯片构成1个2K 8位的存储器；通常字扩展和位扩展两种方式混合使用。 12、熟虑掌握存储器的扩展，包括地址空间分配、地址线的连接、数据线的连接、片选信号的产生及连接等；参看P94页，例4.1 13、假设欲检测的二进制代码为n位，为了使其具有1位的纠错能力，需添加K位检测位，组成n+k位的代码。问，应添加多少位检测位？ 应添加的检测位位数：2的k次方大于等于n+k+1。因为要使其有1位的检测能力，必须使用k位来说明n+k位到底哪一位出现了错误，k位能表达的数量为2的k次方，而n+k位到底哪一位出现了错误或者是全部正确，共有n+k+1种状况，因此，k的取值需要满足：2的k次方大于等于n+k+1 14、对于汉明码，应熟练掌握汉明码的编码方式（按照配偶或配奇的原则），以及给出汉明码，得到要传送的原始信息（包括纠错过程）。 15、提高访存速度的三种方式。 1）采用高速元器件；2）采用存储层次结构：cache-主存结构；3）调整主存结构：包括单体多字，多体并行两种方式。 16、简述单体多字的存储系统的工作原理，及其优点。 1）单体多字存储系统一次访存取出多个CPU字，即存储字为CPU字的n倍（假设一次访存取出n个cpu字）。2）优点是：显著提高了存储器带宽。 17、多体并行系统有哪两种编址方式？请简要说明其编址方式及其优点。 1）高位交叉编址方式：存储体的编址方式为顺序存储，即一个存储体存满后，再存入下一个；存储单元地址的高位为存储体的编号。高位交叉编址并不能提高单次访存速度，但能使多应用并行访存，提高系统的并发性。2）低位交叉编址方式：存储体的编址方式为交叉存储。即程序连续存放在相邻的存储体之中。存储单元地址的低位为存储体的编号。低位交叉编址能显著提高单次访存速度。 19、在四位低位交叉编址中，假设存取周期为T，总线传输周期为τ，为了实现流水线方式存储，应满足什么条件？如果连续读取四个字，所需要的时间是多少？ 1）T= 4τ2）连续读取四个字，所需要的时间为T + （4-1）τ注意：假设不是低位交叉编址，而是高位交叉编址，连续读取四个字所需要的时间仍然为4T。 20、需要大家掌握多体并行存储器在高位交叉编址（顺序存储）和低位交叉编址（交叉存储）的情况下，存储器带宽的计算方式。 21、在CPU和内存之间引入cache的原因。 1）避免cpu空等I/O访存；2）缓解CPU和主存速度不匹配的问题。 22、什么是程序的局部性原理。 CPU从主存取指令或数据，在一定时间内，只是对主存局部地址区域访问。 23、Cache命中率、平均访问时间以及访问效率的计算。 24、Cache写操作有哪两种方式？ 1）写直达法：写操作既写入Cache又写入主存；2）写回法：只把数据写入Cache而不写入主存，当Cache中数据被替换出去之后才写入主存。 25、将主存地址映射到Cache地址称为地址映射，常见的Cache映射方式有哪几种？ 直接映射、全相联映射、组相联映射。 26、直接映射的优缺点？ 优点：地址变换速度快。缺点：cache利用率不高，块冲突率高； 27、全相联映射的优缺点？ 优点：cache利用率高，块冲突率低。缺点：地址变换复杂，需要较多的硬件。 28、需要大家掌握各种映射方式之下，写出主存地址格式、cache地址格式，以及主存地址向cache地址的转换。 29、Cache常用的替换算法有哪些？哪个命中率最高？ 1）先进先出、近期最少使用算法和随机替换算法；2）命中率最高的是近期最少使用算法； 30、磁盘的三地址结构包括哪些？ 柱面、磁头号和扇区号 第五章 输入输出系统1、I/O系统的发展大致可以分为哪4个阶段？ 1）早期（分散连接、串行工作、程序查询）2）接口模块和DMA阶段（总线连接、并行工作、中断及DMA）3）通道阶段（通道是具有特殊功能的处理器）4）I/O处理机阶段I/O系统的发展实际上是逐步将CPU从繁重的I/O工作中解放出来的过程； 2、I/O设备编址有哪两种方式？各有什么优缺点？ 1）统一编址方式：和存储器统一编址，I/O地址作为存储器地址的一部分；无须用专用的I/O指令，但占用存储器空间。2）独立编址方式：和存储地址分开编址，需用专用的I/O指令。 3、I/O设备与主机的联络方式有哪几种？ I/O设备与主机间交互信息时必须了解彼此的状态。根据I/O设备工作速度的不同，可以分为3类：1）立即响应：不管其状态（认为其时刻准备好），适用于慢速设备。2）应答信号：通过应答信号来进行交互；3）同步时标：采用统一的时钟信号。 4、I/O总线包括哪四类？ 数据线、设备选择线、状态线、命令线 5、I/O设备通常使用D触发器（完成触发器）和B触发器（工作触发器）来标识设备所处的状态。D=0，B=0：暂停状态；D=0，B=1：准备状态D=1，B=0：就绪状态 6、程序查询的基本工作原理。 cpu不断去查询I/O设备状态，导致CPU和I/O设备串行工作。 7、什么是中断？ 计算机在执行程序过程中，当出现异常清空或特殊请求时，计算机停止现行程序的运行，转去处理这些异常清空或特殊请求，处理结束后，再返回现行程序的间断处，继续执行原程序，即为中断。 8、中断服务程序的基本流程包括哪四部分？ 1）保护现场2）中断服务3）恢复现场4）中断返回 9、什么是单重中断和多重中断？ 1）单重中断：不允许中断现行的中断服务程序；2）多重中断：允许级别更高的中断源中断现行的中断服务程序，也称为中断嵌套； 10、CPU响应中断的时机？ 当前指令执行完毕后，cpu发出中断查询信号，也就是说，中断响应一定是在每条指令执行结束之后进行的，不可能在指令执行过程中响应中断。 11、什么是DMA？ DMA：直接内存访问。在主存和I/O设备之间建立独立的总线连接。 12、在DMA方式中，由于DMA接口与CPU共享主存，可能会出现两者争用主存的冲突，为解决冲突，DMA和主存交换数据时，通常采用哪三种工作方式？ 1）停止CPU访问主存：DMA访存优先级高；2）周期挪用（窃取）：DMA挪用存储或窃取总线使用权一个或几个主存存取周期；3）DMA和CPU交替访问：将CPU工作周期分成两部分，一部分供DMA访存，一部分供CPU访存。 13、DMA工作过程包括哪三部分？ 1）预处理2）数据传输2）后处理 第六章 计算机的运算方法1、掌握有符号数的原码计算方法，以及通过原码求真值； 2、掌握补码计算的方法，以及通过补码求原码，然后求真值的方法。 1）通过原码求补码：符号位不变，各位取反，末位加1；2）通过补码求原码：符号位不变，各位取反，末位加1； 3、原码中0有2种表示方法（正零和负零），补码中0只有一种表示方法（正零和负零的表示方法一致） 4、假设有符号数的位数为8（包括符号位），补码能表示的真值的范围？ 补码能表示的真值范围为-128~+127（参见补码定义）5、掌握求反码以及移码的方法。 6、什么是定点表示？什么是浮点表示？ １）定点表示：小数点固定在某一位置的数为定点数；２）浮点表示：小数点位置可以浮动的数。 7、浮点数在机器中的表示形式，由哪几部分组成？ 由尾数、数符、阶码、阶符四部分组成。 8、掌握规格化浮点数的表示范围（最大正数、最小正数、最大负数、最小负数）的计算方法。 9、IEEE754标准规定的浮点数由哪几部分组成？ 由数符、阶码（含阶符）以及尾数组成。 10、IEEE754标准规定的浮点数中，阶码和尾数用什么形式表示？ 阶码用移码表示，其偏移量是2^(n-1)，尾数用原码表示。 11、float占多少位？double占多少位？ float为短实数，占32位，其中阶码8位，尾数23位。double为长实数，占64位，其中阶码占11位，尾数为52位。 12、对正数进行算术移位，当正数采用源码、补码、反码时，左移或右移时，低位或高位添补什么代码？ 对于正数，其源码、补码、反码均等于真值，左移时，低位添补0，右移时，高位添补0。 13、对负数进行算术移位，当负数采用源码、补码、反码时，左移或右移时，低位或高位添补什么代码？ 对于源码，左移或右移时，低位或高位均添补0；对于补码：左移时，低位添补0，右移时高位添补1对于反码：左移或右移时，低位或高位均添补1； 14、什么是逻辑移位？ 逻辑移位是对无符号数的移位，由于无符号数不存在符号位，左移时，高位移丢，低位补零。右移时，低位移丢，高位补零。 15、加法和减法时，什么情况下可能发生溢出？如何简单判断发生溢出？ 1）正数加正数，正数减负数，负数加负数，负数减正数时，可能会发生溢出。2）如果参加操作的两个数符号相同（转换成补码的加法），其结果与源操作数符号不同，即为溢出。3）如果补码采用1位符号位，如果最高有效位的进位和符号位的进位不同，则发生溢出。 16、定点乘法运算可以使用加法和移位来实现吗？ 可以。 17、浮点加减运算基本按照哪几步来进行？ 1）对阶：使小数点对齐；2）尾数求和：将对阶后的两个尾数按照定点加减运算规则求和；3）规格化：尾数规格化；4）舍入：尾数右规时，丢失数值位；5）溢出判断：判断结果是否溢出。 18、如何判断浮点运算结果是否溢出？ 阶码是否超出了其表示范围。（使用2个符号位判溢出） 第七章 指令系统1、什么是机器指令？什么是指令系统？1）机器指令：每一条机器语言的语句；2）指令系统：全部机器指令的集合。 2、一条指令包含哪两个主要部分？请简要说明各部分作用。1）操作码：指明指令要完成的操作；2）地址码：指明指令要操作的数据或数据来源； 3、操作码长度有固定长度和可变长度两种，各自有什么优点？1）固定长度：便于硬件设计，指令译码时间短；2）可变长度：压缩了操作码平均长度； 4、指令中地址码中的地址可以是哪些设备的地址？可以是主存地址、寄存器地址或I/O设备的地址； 5、指令中地址的个数可以有几个？四地址、三地址、二地址、一地址以及零地址。 6、假设指令中有四个地址、三个地址、两个地址以及一个地址，各自需要访存几次？1）四地址：访存4次；2）三地址：访存4次；3）两地址：访存3次；4）一地址：访存2次； 7、当使用寄存器代替指令字中的地址码字段后，有哪些优点？1）扩大指令字的寻址范围；2）缩短指令字长；3）减少访存次数 8、数据在存储器中存储时，为什么要按照边界对齐？减少访存次数。 9、寻址方式包括哪两类？1）指令寻址：下一条将要执行的指令的指令地址；2）数据寻址：确定本指令的操作数地址。 10、什么是形式地址？什么是有效地址？1）形式地址：指令的地址码字段通常都不代表操作数的真实地址，成为形式地址，记为A；2）有效地址：操作数的真实地址，记为EA，由寻址特征和形式地址共同决定； 11、了解各种寻址方式的概念及根据形式地址形成有效地址的方式。立即寻址、直接寻址、隐含寻址、间接寻址、寄存器寻址、寄存器间接寻址、基址寻址（隐式或显式）、变址寻址、相对寻址、堆栈寻址 12、什么是RISC？什么是CISC？RISC：精简指令集；CISC：复杂指令集；]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[待解决dataclass + __solts__的问题 github上相关问题 多加一个装饰器 基础1234567891011121314151617181920212223class Color(): r = 200 def __init__(self,r=250): self.r = r self.g = self.get_g() self.b = self.get_b def get_g(self): g = 223 return g @property def get_b(self): b = 222 return b def __str__(self): return f&apos;&#123;self.__class__.__name__&#125;(class_r = &#123;self.__class__.r&#125;, r = &#123;self.r&#125;, g = &#123;self.g&#125;, b = &#123;self.b&#125;)&apos;color = Color(255)color1 = Color()print(color) # Color(class_r = 200, r = 255, g = 223, b = 222)print(color1) # Color(class_r = 200, r = 250, g = 223, b = 222) 1234567891011121314151617181920class Color(): r = 200 def __init__(self): self.g = self.get_g() self.b = self.get_b def get_g(self): g = 223 return g @property def get_b(self): b = 222 return b def __str__(self): return f&apos;&#123;self.__class__.__name__&#125;(class_r = &#123;self.__class__.r&#125;, r = &#123;self.r&#125;, g = &#123;self.g&#125;, b = &#123;self.b&#125;)&apos;color = Color()print(color) # Color(class_r = 200, r = 255, g = 223, b = 222) 使用第三方插件修改一下1234567891011121314151617from attr import attrs, attrib # dataclass 内置库可替代&apos;&apos;&apos;attrs 修饰符，可以自动实现__init__,__repr__,__eq__,__ne__,__it__,__le__,__gt__,__ge__,__hash__,这几个方法&apos;&apos;&apos;@attrsclass Color(): r = attrib(type=int, default=100) g = attrib(type=int, default=200) b = attrib(type=int, default=222)color = Color(255,254,253)color1 = Color()print(color) # Color(class_r = 200, r = 255, g = 223, b = 222)print(color1) # Color(class_r = 200, r = 250, g = 223, b = 222) 声明和比较123456789101112131415from attr import attrs, attrib # dataclass内置库可替代&apos;&apos;&apos;attrs 修饰符，可以自动实现__init__,__repr__,__eq__,__ne__,__it__,__le__,__gt__,__ge__,__hash__,这几个方法&apos;&apos;&apos;@attrsclass Point(): x = attrib() y = attrib()p1 = Point(1,2)p2 = Point(y=3,x=4)print(p1,p2) # Point(x=1, y=2) Point(x=4, y=3) 使用python3.7 的内置库12345678910from dataclasses import dataclass@dataclassclass Point(): x:int = 0 y:int = 0p1 = Point(1,2)p2 = Point(y=3,x=4)print(p1,p2) # Point(x=1, y=2) Point(x=4, y=3) 1234567891011# 默认init,repr,eq 为True， 其余为False@dataclass(init=1,repr=1,eq=1,order=1,unsafe_hash=0,frozen=0)class Point(): x:int = 0 y:int = 0p1 = Point(1,2)p2 = Point(y=3,x=4)p3 = Point(x=1,y=2)print(p1&gt;p2) # fasleprint(p1==p3) # True 1234567891011from dataclasses import dataclass@dataclass(frozen=1)class Point(): x:int = 0 y:int = 0p1 = Point(1,2)print(p1) # 当实例化一个frozen 对象时，任何企图修改对象属性的行为都会引发 FrozenInstanceError#p1.x = 10 # dataclasses.FrozenInstanceError: cannot assign to field &apos;x&apos; 1234567891011121314from dataclasses import dataclass@dataclass()class Point(): x:int = 0 y:int = 0 def x_add_1(self): self.x += 1p1 = Point(1,2)print(p1) # Point(x=1, y=2)p1.x_add_1()print(p1) # Point(x=2, y=2) __init__方法在返回前会调用__post_init__123456789101112from dataclasses import dataclass@dataclass()class Point(): x:int = 0 y:int = 0 def __post_init__(self): self.x += 1 p1 = Point(1,2)print(p1) # Point(x=2, y=2) 有关继承12345678910111213141516from dataclasses import dataclass@dataclassclass Point: x:int = 0 y:int = 0 def __post_init__(self): self.x += 1@dataclassclass ThirdPonit(Point): z:int =0ppp = ThirdPonit(1,3,4)print(ppp) # ThirdPonit(x=2, y=3, z=4) super1234567891011121314151617181920from dataclasses import dataclass@dataclassclass Point: x:int = 0 y:int = 0 def __post_init__(self): self.x += 1@dataclassclass ThirdPonit(Point): z:int =0 def __post_init__(self): super().__post_init__() # 调用 父类的__post_init__() self.x += 10ppp = ThirdPonit(1,3,4)print(ppp) # ThirdPonit(x=12, y=3, z=4) 复合初始化12345678910111213141516import randomfrom dataclasses import dataclassdef get_random_marks(): return [random.randint(1,10) for _ in range(5)]@dataclassclass Student: marks:list = list def __post_init__(self): # 额外的工作 self.marks = get_random_marks()a = Student()print(a) # Student(marks=[2, 9, 8, 8, 2])print(a.marks) # [2, 9, 8, 8, 2] 修改123456789101112131415161718192021import randomfrom dataclasses import dataclass, fielddef get_random_marks(): return [random.randint(1,10) for _ in range(5)]@dataclassclass Student: marks:int = field(default_factory= get_random_marks) # int 不建议，建议使用数据类型 # default_factory ：如果在创建对象时没赋值，则使用该方法初始化该字段 （必须是可以调用的无参数方法） # 使用 get_random_marks 方法 初始化 marks a = Student()print(a) # Student(marks=[7, 2, 4, 7, 4])print(a.marks) # [7, 2, 4, 7, 4]print(type(a.marks)) # &lt;class &apos;list&apos;&gt;b = Student(&apos;b&apos;) # 传参则不影响print(b) # Student(marks=&apos;b&apos;)print(b.marks) # bprint(type(b.marks)) # &lt;class &apos;str&apos;&gt; filed 更多操作123456789101112131415from dataclasses import dataclass, field@dataclass(order=1)class Number: number:int = field(compare= False,repr= False) # number 不进行比较,不打印 val:int verified:1 = field(default=0,init=0) # 默认为 1，不进行初始化a = Number(3,4)b = Number(4,3)print(a &lt; b) # Falseprint(a) # Number(val=4, verified=0)print(b) # Number(val=3, verified=0)b.verified = 1print(b) # Number(val=3, verified=1)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[迭代对象，迭代器，生成器]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%8C%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[容器容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用 in , not in 关键字判断元素是否包含在容器中 assert 如果为Fasle, 那么raise一个AssertionError123assert False, &apos;error&apos;assert True, &apos;error&apos;assert 1 in [1, 2, 3, 4],&apos;error&apos; 大多数容器提供了某种方式来获取其中每一个元素,（是可迭代对象赋予了容器这种能力） 可迭代对象 （iterable）凡是可以返回一个迭代器的对象都可以称之为可迭代对象 可迭代对象实现了 iter (返回可迭代对象本身) 和 next 方法，123456789101112x = [1, 2, 3]y = iter(x)z = iter(x) #两个不同的迭代器next(y) next(y)next(z)type(x) # list 可迭代对象type(y) # list_iterator 具体的迭代类型a = &apos;hahaha&apos;b = iter(a)type(b) # str_iterator 迭代器 (iterator)迭代器是一个带状态的对象，能在调用 next() 方法时返回容器的下一个值. 迭代器等有人需要的时候才生成值返回， 没调用的时候， 就处于休眠状态等待下一次调用。 生成器（generator）相比其他容器对象，它更能节省内存和cpu。 12sum(i for i in range(100_000_000)) # 生成器sum[i for i in range(100_000_000)] # 列表推导式 生成器是一种特殊的迭代器，只需要yield关键字。生成器一定是迭代器（反之不成立）。 12345def someting(): result = [] for x in ..: result.append(x) return result 都可以改写123def iter_something(): for x in ..: yield x 生成器表达式（generator expression）列表推导式的生成器版本，但他返回的是一个生成器对象，而不是列表对象1a = (x * x for x in range(10)) 生成器只能遍历一次]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络请求]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[url 与 ipip : Internet Protocol 如果 ‘域名-ip’ 已被记录，则直接访问目标ip浏览器缓存，系统缓存，路由缓存 没有被记录，则 依靠 DNSDNS : Domain Name System 是一个将域名和 IP 相互映射的分布式数据库。 网卡上，有 ‘DNS 服务器’ 配置项 DNS 劫持访问 A 结果 访问了 B DNS 投毒(污染)从客户端 向 DNS 服务器发出 查询IP 的请求，到响应 返回到客户端 的这段时间，被伪造返回来一个 错误的DNS应答，那么访问不到真正的资源 DNS 正常解析返回正常的 ip 地址]]></content>
      <categories>
        <category>flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多线程的鸡肋]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%B8%A1%E8%82%8B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536from contextlib import contextmanagerimport time## 因为GIL锁的原因，多线程并没有多少用## 不适合计算密集型@contextmanagerdef _cost_time(): start_time = time.time() print(&apos;start time : &apos; + time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())) yield end_time = time.time() seconds = end_time - start_time m, s = divmod(seconds, 60) h, m = divmod(m, 60) print(&apos;end time : &apos; + time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())) print(&apos;time cost %d:%02d:%02d &apos; % (h, m, s))def decrement(n): while n &gt; 0: n -= 1# Single threadwith _cost_time(): decrement(100000000)#import threadingwith _cost_time(): t1 = threading.Thread(target=decrement,args=[50000000]) t2 = threading.Thread(target=decrement,args=[50000000]) t1.start() t2.start() t1.join() t2.join() 修改一下123456789101112131415161718192021222324252627282930313233343536import time## 因为GIL锁的原因，多线程并没有多少用## 不适合计算密集型def _cost_time(func): def warpper(*args,**kw): start_time = time.time() print(&apos;start time : &apos; + time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())) func(*args,**kw) end_time = time.time() seconds = end_time - start_time m, s = divmod(seconds, 60) h, m = divmod(m, 60) print(&apos;end time : &apos; + time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())) print(&apos;time cost %d:%02d:%02d &apos; % (h, m, s)) return warpper@_cost_timedef decrement(n): while n &gt; 0: n -= 1# Single threaddecrement(100000000)# Multithreadingimport threadingt1 = threading.Thread(target=decrement,args=[50000000])t2 = threading.Thread(target=decrement,args=[50000000])t1.start()t2.start()t1.join()t2.join()]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[优雅的python写法]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E4%BC%98%E9%9B%85%E7%9A%84python%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[学习python cook book 有感1. 交换变量1a, b = b, a 2. 循环遍历区间1234for i in range(6): print (i)``` ## 3. 带有索引位置的集合遍历 for i, color in enumerate(colors): print (i ,colors[i])1## 4. 字符串拼接 print ‘. ‘ .join(names)‘’’join 方法全程只会产生一个字符串对象，而每执行一次 + 操作，就会在内存中生成一个新的字符串对象‘’’12现在已经可以直接使用加号，不会影响效率。（不要被落后的经验给拖累了）## 5. 打开/关闭文件 with open (‘xxx.xxx’,’r’) as f: data = f.read()1## 6. 列表推导式 [i for i in range(10)]1## 7. 善用装饰器 ‘’’装饰器可以吧与业务逻辑无关的代码抽离出来，让代码保持干净清爽，且能多次利用url 曾使用过直接从cache读出，没有的话存到saved中‘’’import urllib.request as urllib def cache(func): saved = {} def wrapper(url): if url in saved: return saved[url] else: page = func(url) saved[url] = page return page return wrapper @cachedef web_lookup(url): return urllib.urlopen(url).read()1## 8. 合理使用列表 ‘’’list是一个查询效率高于更新操作的数据结构,删除/插入 一个元素 执行的效率较低，因为还要对剩下的元素进行移动‘’’from collections import dequenames = deque([1, 2, 3, 4, ‘haha’])names.popleft()names.appendleft(‘mark’) ‘’’deque 是一个双向队列的数据结构，删除元素和插入元素会很快‘’’1## 9. 序列解包 p = ‘1’ , ‘2’ , ‘3’ , 4a, b, c, d, = p12## 10. 遍历字典的 key 和 value dict ={1:’haha’,2:’xixi’}for key, value in dict.items(): print(key ,’ + ‘, value)‘’’dict.items 返回迭代器对象，可节省更多的内存‘’’1## 11. 链式比较操作 age = 18if 18 &lt; age &lt; 60: print(‘young man’) False == True == True == True False1## 12. if/else text = ‘男’ if gender == ‘male’ else ‘女’1## 13. True/Fales 值判断 if a: do_someting()if b: do_someting()‘’’a,b 的值有就是True, 没有就是False‘’’1## 14. 字符串格式化 a,b = ‘haha’, [1,2,3]s = f’str is {a}, list is {b}’‘’’不支持python2‘’’1## 15. 列表切片 items = range(10)sub_items = items[1:4] # 取第1号到第4号元素odd_items = items[1::2] # 第1号到最后面，步长为2 （奇数）copy_items = items[::] # 或者 items[:]1## 16. 善用生成器 def fib(n): a, b = 0, 1 while a &lt; n: yeild a a ,b = b, a + b‘’’生成器的好处是无需一次性把所有元素加载到内存，只有迭代获取元素时才返回该元素，而列表是预先一次性把全部元素加载到内存中遇到 yield 会暂停执行另一个函数‘’’1# 17. 获取字典元素 d = {‘name’:’foo’}d.get(‘name’,’unknow’)d.get(‘age’,’unknow’)1# 18. 预设字典默认值 groups = {}for (key, value) in data: groups.setdefault(key, []).append(value) from collections import defaultdictgroups = defaultdict(list)for (key, value) in data: groups[key].append(value)12## 19 字典/列表/集合 推导式 numbers = [1, 2, 3, 4]my_dict = {number: number*2 for number in numbers}print(my_dict)12345## 20. for/else&apos;&apos;&apos;python 特有的语法格式，else中的代码在for 循环完所有元素成后执行&apos;&apos;&apos; flagfound = Falsemylist = [1, 2, 3, ‘theflag’, 4, 5, 6]for i in mylist: if i == ‘theflag’: flagfound = True break print(i)else: raisd ValueError(‘list argument missing terminal flag’)12## 21 一些特性### 给数字加\_分组并不影响实际 a = 11_22_33_44error = 0xbad_c0ffee1### 将类型注释添加到函数和方法中 def my_add(a:str,b:int) -&gt; str: return a + bmy_add(1,2)1### 直接操作数字 PI =3.141592653f’PI is {PI:.4f}’`]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python的日志模块]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2Fpython%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[日志概述 日志会记录下操作，运行的一些相关内容 查看日志是获取信息，排查异常，发现问题的最好途径 日志可在控制台显示，也可以记录到文件中，或者同时输出 日志级别 一般指的是： DEBUG, INFO, WARNING, ERROR, CRITICAL 等严重等级进行划分 python 的 logging 提供了一组便利的日志函数，分别是： debug(), info(), warning(), error(), critical()。 12345DEBUG : 详细信息一般只在调试问题时使用INFO : 事情按预期进行WARNNING : 某些没有预料到的事件提示，或者将来可能出现问题的提示。ERROR : 更严重的问题，软件的一部分功能已不能被执行CRITICAL ： 严重错误，表明软件不能继续运行 logging 的四大组件123456日志器 Logger 提供了应用程序一直使用的接口处理器 Handler 将 logger 创建的日志记录发送到合适的目的输出过滤器 Filter 提供更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录格式器 Formatter 决定日志记录的最终输出格式logger 是入口，真正工作的是 handler, handler 还可以通过 filter 和 formatter 对要输出的日志内容做过滤和格式化处理 日志输出输出到控制台python 中日志的默认等级是 WARNING, DEBUG 和 INFO 级别的日志不会得到显示。12345import logginglogging.info(&apos;info message&apos;)logging.warning(&apos;warning message&apos;)logging.error(&apos;error message&apos;) logging 提供 basciConfig 让使用者可以适时调整默认日志级别1234567import logginglogging.basicConfig(level=logging.DEBUG)logging.info(&apos;info message&apos;)logging.warning(&apos;warning message&apos;)logging.error(&apos;error message&apos;) 输出到文件在 basciConfig 中填写 filename(日志名) ,filemode(写入方式)123456789import logginglogging.basicConfig(level=logging.DEBUG, filename=&apos;test.log&apos;, filemode=&apos;a&apos;)logging.info(&apos;info message&apos;)logging.warning(&apos;warning message&apos;)logging.error(&apos;error message&apos;) 同时输出到文件及控制器对比1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import osimport loggingimport uuidfrom logging import Handler, FileHandler, StreamHandlerclass PathFileHandler(FileHandler): def __init__(self, path, filename, mode = &apos;a&apos;, encoding = None, delay = False): filename = os.fspath(filename) if not os.path.exists(path): os.mkdir(path) self.baseFilename = os.path.join(path, filename) self.mode = mode self.encoding = encoding self.delay =delay if delay: Handler.__init__(self) self.stream = None else: StreamHandler.__init__(self, self._open())class Loggers(): level_relations = &#123; &apos;debug&apos; : logging.DEBUG, &apos;info&apos; : logging.INFO, &apos;warning&apos; : logging.WARNING, &apos;error&apos; : logging.ERROR, &apos;critical&apos; : logging.CRITICAL &#125; uid = uuid.uuid4() def __init__(self, filename = f&apos;&#123;uid&#125;.log&apos;, level = &apos;info&apos;, log_dir = &apos;log&apos;, fmt = &quot;[%(asctime)s] [%(levelname)8s] %(message)s&quot; ): self.logger =logging.getLogger(filename) abspath = os.path.dirname(os.path.abspath(__file__)) self.directory = os.path.join(abspath, log_dir) format_str = logging.Formatter(fmt) self.logger.setLevel(self.level_relations.get(level)) stream_handler = logging.StreamHandler() stream_handler.setFormatter(format_str) file_handler = PathFileHandler(path=self.directory, filename=filename, mode=&apos;a&apos;) file_handler.setFormatter(format_str) self.logger.addHandler(stream_handler) self.logger.addHandler(file_handler)if __name__ == &apos;__main__&apos;: text = &apos;hahaha&apos; log = Loggers(level=&apos;debug&apos;) log.logger.info(4) log.logger.info(5) log.logger.info(text)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[psutil模块]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2Fpsutil%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%88%A9%E7%94%A8%E7%8E%87%2F</url>
    <content type="text"><![CDATA[三大模块 System related function Processes Windows Service 安装方法pip install psutil pip install -user psutil 使用方法123456789101112131415161718192021222324252627import psutil&apos;&apos;&apos;待探索&apos;&apos;&apos;# cpu 节选psutil.cpu_times() # 将系统cpu时间作为命名元组返回psutil.cpu_percent(interval=None, percpu=None) # cpu 使用百分比psutil.cpu_percent(interval=3, percpu=True) # 3秒间隔中，cpu 的占用率psutil.cpu_count() # cpu 逻辑核心数psutil.cpu_count(logical=True) # cpu 物理核心数for i in range(10): psutil.cpu_percent(interval=3, percpu=True) # 3秒间隔中，cpu 的占用率# 内存节选psutil.virtual_memory() # 将系统内存使用情况作为命名元组返回# 当内存不足，发出提示dan = 300 * 1024 * 1024 # 单位为bif psutil.virtual_memory().available &lt;= dan: print(&apos;memory warning&apos;)# 进程信息psutil.pids()[p.info for p in psutil.process_iter(attrs=[&apos;pid&apos;, &apos;name&apos;]) if &apos;python&apos; in p.info[&apos;name&apos;]] 更多单个进程信息1234567891011121314151617181920p = psutil.Process(2423) p.name() #进程名p.exe() #进程的bin路径p.cwd() #进程的工作目录绝对路径p.status() #进程状态p.create_time() #进程创建时间p.uids() #进程uid信息p.gids() #进程的gid信息p.cpu_times() #进程的cpu时间信息,包括user,system两个cpu信息p.cpu_affinity() #get进程cpu亲和度,如果要设置cpu亲和度,将cpu号作为参考就好p.memory_percent() #进程内存利用率p.memory_info() #进程内存rss,vms信息p.io_counters() #进程的IO信息,包括读写IO数字及参数p.connectios() #返回进程列表p.num_threads() #进程开启的线程数听过psutil的Popen方法启动应用程序，可以跟踪程序的相关信息from subprocess import PIPEp = psutil.Popen([&quot;/usr/bin/python&quot;, &quot;-c&quot;, &quot;print(&apos;hello&apos;)&quot;],stdout=PIPE)p.name()p.username() 获取开机时间`psutil.boot_time() # 时间戳 datetime.datetime.fromtimestamp(psutil.boot_time ()).strftime(“%Y-%m-%d %H: %M: %S”) #转换成自然时间格式]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python的一些技巧]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2Fpython%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[变量有关于变量` 定义 __str__ 方法的对象，可以使用 str() 函数 返回可读名称 定义 __next__ 和 __iter__ 方法的对象，就可以被循环迭代 定义 __bool 方法的对象，进行布尔值的判断时就会使用自定义的逻辑]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pathlib模块]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2Fpathlib%E6%9C%89%E5%85%B3%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[面向对象的文件系统路径 pathlib 提供表示文件系统路径的类，适用于不同的操作系统 纯路径提供纯粹的计算操作，具体路径继承纯路径且可以进行 I/O 操作12345678910import pathlibprint(pathlib.PurePath(__file__)) # 文件路径print(pathlib.PurePath(__file__).match(&apos;*.py&apos;))print(pathlib.Path.cwd()) # 当前路径 （运行路径）print(pathlib.Path.cwd().parent) # 上一级print(pathlib.Path.cwd().parent.parent) # 上上级parts = [&apos;first&apos;, &apos;second&apos;, &apos;third&apos;]print(pathlib.Path.cwd().parent.joinpath(*parts)) # 在上一级开始拼接路径 更多123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pathlib import PathPath.iterdir() # 遍历目录的子目录或者文件Path.is_dir() # 判断是否是目录Path.glob() # 过滤目录(返回生成器)Path.resolve() # 返回绝对路径Path.exists() # 判断路径是否存在Path.open() # 打开文件(支持with)Path.unlink() # 删除文件或目录(目录非空触发异常)# 基本属性Path.parts # 分割路径 类似os.path.split(), 不过返回元组Path.drive # 返回驱动器名称Path.root # 返回路径的根目录Path.anchor # 自动判断返回drive或rootPath.parents # 返回所有上级目录的列表# 改变路径Path.with_name() # 更改路径名称, 更改最后一级路径名Path.with_suffix() # 更改路径后缀#拼接路径Path.joinpath() # 拼接路径Path.relative_to() # 计算相对路径# 测试路径Path.match() # 测试路径是否符合patternPath.is_dir() # 是否是文件Path.is_absolute() # 是否是绝对路径Path.is_reserved() # 是否是预留路径Path.exists() # 判断路径是否真实存在# 其他方法Path.cwd() # 返回当前目录的路径对象Path.home() # 返回当前用户的home路径对象Path.stat() # 返回路径信息, 同os.stat()Path.chmod() # 更改路径权限, 类似os.chmod()Path.expanduser() # 展开~返回完整路径对象Path.mkdir() # 创建目录Path.rename() # 重命名路径Path.rglob() # 递归遍历所有子目录的文件]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于import]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E5%85%B3%E4%BA%8Eimport%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[12345678import syssys.path.append(&quot;..&quot;) # 将上层目录加入路径.sys.path.append(&quot;/home&quot;) # 将/home 加入路径.## 一个模块只能被导入一次from imp import *reload(sys) # 重新导入某模块]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux使用者管理]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2Flinux%E4%BD%BF%E7%94%A8%E8%80%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[新建用户12345root 权限下：useradd testpasswd testuserdel -r test # 连同文件夹一起删掉 例行工作12atcron 程序管理与selinux初探 程序一般放在磁盘中，通过用户的执行来触发，触发后会加载到内存中成为一个个体，就是进程。 &amp; 后台运行 (关掉终端会停止) nohup + cmd + &amp; 或者setsid + cmd + &amp; fg %1 将job 1拿到前台来 vi 下 ctrl + z 可将vi 放到后台。 kill # kill -9 %1 bg 后台暂停的 让 后台运行 top -d 5 -p 12345 free -g uname -a uptime netstat -a SELinuxSecurity Enhanced Linux screen1234screen -dmS test # 创建 test 窗口screen -r test # 连接 test 窗口screen -d test 后 screen -r test # 如果连接不上，这样连接screen -S test -X quit # 删除 test 窗口]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[部分命令]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[基础 .bash_history 历史记录 Tab 补全 alias 命令别名， alias lm = ‘ls -al’ , unalias lm (临时) vi /root/.bashrc （永久） type cd 命令类型 \ 转义 变量 变量未设置时，默认为空 PATH=$PATH:/home/bin 变量累加 export PATH 使变量成为环境变量 一般默认 大写为系统变量 小写为自行设置变量 变量中 单引号’’（纯文本） 与 双引号 “” (保持原本特性) current_path=$(pwd) 接命令赋值给变量。 等同于 123456789101112current_path=`pwd`# 建议都用 $(pwd)``` 7. `unset current_path` 取消变量8. 子进程取消的变量 对 父进程无影响，子进程只继承父进程的环境变量与export。9. `work=/opt/software` 可以`cd $work` 。写入.bash_profile 全局生效。10. `env` 查看环境变量11. `set` 查看所有变量12. `echo $?` 只与上一个命令有关，上一个命令成功返回0## 变量读取，数组与声明 read -s -p “please input root password:” serverPwd # -p 提示 -s 不显示echo $serverPwdecho -e “\n” # -e 启用反斜杠转义 （换行）1**数组** var[1]=’small’var[2]=’big’echo “$var[1],$var[2]”1declare 和 typeset 一样声明变量类型 sum=100+1echo $sun # 100+1declare -i sum=100+1echo $sun # 101 1## $ $0 当前脚本的文件名$n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。$# 传递给脚本或函数的参数个数。$* 传递给脚本或函数的所有参数。 # 双引号内，会识别成一个整体$@ 传递给脚本或函数的所有参数。 # 双引号内，还是会识别成一个一个参数$? 上个命令的退出状态，或函数的返回值。一般情况下，大部分命令执行成功会返回 0，失败返回 1。$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID1234567891011121314151617## 与文件系统及程序的限制关系：ulimit## 数据流重定向st:standard1. stdin &lt; &lt;&lt; (代码0)2. stout &gt; &gt;&gt; (代码0)3. stderr 2&gt; 2&gt;&gt; (代码2)4. &gt;/dev/null ,2&gt;/dev/null 丢弃输出5. &gt; list 2&gt;&amp;1 (都输出 list)或 &amp;&gt; list## 命令执行判断依据1. cmd1,cmd2,cmd3 依次执行2. cmd1 &amp;&amp; cmd2 &amp;&amp; cmd3 前面成功，后面才执行（$# = 0）3. cmd1 || cmd2 || cmd3 前面成功，后面就不执行（$# = 0）## 管道命令（pipe）**将前一个命令的stout(不会处理stderr) 传到下一个命令的stdin中** yes|bash …sh(执行命令输入yes)echo $PATH |cut -d ‘:’ -f 4 # 以 : 分割$PATH ,取出第4个echo $PATH |cut -d ‘:’ -f 3,5 # 以 : 分割$PATH ,取出第3,5个export | cut -c 12- # 取出12到最后的字符last | grep -i root # 找出last中的含root行，忽略大小写last | grep -v root # 不含root行last | grep root|cut -d ‘ ‘ -f 1| sort | uniq -ic # i 忽略大小写 c 计数cat /etc/os-release | wc # 输出 行 字数 字符数wc -l(行) -w(英文单字) -m (多少字符)12## 双向重定向（tee）**将数据流同时输出到屏幕和文件中** last |tee -a last.list # -a 累加` shell脚本shell script 是利用shell的功能所写的一个纯文本文件，将一些shell的语法命令写在里面，搭配正则表达式，管道命令与数据流重定向等功能达到我们想要的目的。]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机概论]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[计算机概论计算机五大部分 输入单元 中央处理器 （控制器，运算器） 内存 输出单元 cpu 种类 精简指令集 （RISC） 复杂指令集 （CISC） CPU内部已经含有一小的指令集，我们所使用的软件都要经过 CPU 内部的微指令集来完成 精简指令集RISC比较精简，每个指令执行时间短，完成的操作也很单纯，指令的执行性能比较好，但要做复杂的事情，就要多个指令来完成（ ARM ） 复杂指令集CISC的微指令集中，每个小指令可以执行一些较低阶的硬件操作，指令数目多且复杂，每条指令的长度并不相同。每个指令花费时间长，但每条个别指令可以处理的工作比较丰富。（AMD INTEL 等 x86 架构 CPU ）(64 位的个人计算机CPU 统称为 x86_64 架构) 接口设备最重要的接口设备是主板，主板将所有的设备连接在一起，让它们能够协调通信 主板上最重要的组件 ： 主板芯片组 ，将所有设备汇聚在一起 计算机发展简史 电子管计算机 晶体管计算机 集成电路计算机 （计算机具备进入千家万户条件）IBM 推出兼容的产品 System/360 操作系统的雏形 超大规模集成电路计算机 （当前计算机） 计算机分类 超级计算机 # 天河二号等 大型计算机 # 去’IOE’ 微型计算机 # 小型机，普通服务器, 已经代替了传统大型机，成为大规模企业计算的中枢 工作站 # 比个人计算机更强大的性能 微电脑 （个人 pc ） 计算机上常用的计算单位大小单位理论上只认识0与1，0/1 的单位称为 bit，存储数据时，每份简单的数据都会使用 8 个 bit 来记录，称之为 Byte1Byte = 8 bitk M G T P 用来简化1024写法 速度单位CPU 常用 MHz 和 GHz ，(Hz 秒分之一) 网络上使用的 bit 为单位， 8Mbit/s ,转化为 Byte 为 1024 kB/s 或 1 MB/s 或 8Mbps ##]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[进程与线程]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[CPU，它承担了所有的计算任务，进程是指程序的一次执行，线程是CPU的基本调度单位。 进程的内存空间是共享的，每个线程都可以使用这些共享内存, 一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存,”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域 “互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域 某些内存区域，只能供给固定数目的线程使用,”信号量”（Semaphore），用来保证多个线程不会互相冲突 概念进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。 一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[权限目录]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F%E6%9D%83%E9%99%90%EF%BC%8C%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[用户与用户组 u g o a (user group other all) r:4 w:2 x:1 chgrp chown chmod 目录1234567891011121314151617181920# 一般情况下lrwxrwxrwx. 1 root root 7 Feb 2 14:33 bin -&gt; usr/bin #bin 放用户可用，启动时会用到的命令 l 连接文件 指向 /usr/bin dr-xr-xr-x. 6 root root 4096 Feb 20 10:37 boot # 开机用到的文件，内核，相关设置drwxr-xr-x. 19 root root 3560 Apr 22 16:07 dev # 任何设备与接口设备drwxr-xr-x. 93 root root 12288 May 24 16:05 etc # 配置文件drwxr-xr-x. 6 root root 4096 May 24 14:42 home # 默认用户主文件夹lrwxrwxrwx. 1 root root 7 Feb 2 14:33 lib -&gt; usr/lib #系统函数库lrwxrwxrwx. 1 root root 9 Feb 2 14:33 lib64 -&gt; usr/lib64 drwx------. 2 root root 16384 Feb 2 14:32 lost+found # 文件系统发生错误时，保存的一些丢失片段dr-xr-xr-x. 9 root root 2048 Jan 15 21:24 media # 可删除设备drwxr-xr-x. 2 root root 4096 Jun 25 2018 mnt # 额外挂载设备drwxr-xr-x. 7 root root 4096 May 24 16:16 opt # 第三方软件放置库dr-xr-xr-x. 505 root root 0 Feb 19 17:39 proc #虚拟文件系统，内核进程网络状态等存在于内存中，不占磁盘空间dr-xr-x---. 4 root root 4096 May 24 14:54 root # 系统管理员主文件夹lrwxrwxrwx. 1 root root 8 Feb 2 14:33 sbin -&gt; usr/sbin # 开机过程需要的命令drwxr-xr-x. 3 root root 4096 May 24 14:39 srv # 服务数据目录dr-xr-xr-x. 13 root root 0 Feb 19 17:40 sys # 同proc ，目前已加载的内核模块，与内存监测到的硬件设备信息等。drwxrwxrwt. 25 root root 4096 May 24 16:44 tmp # 临时放置文件drwxr-xr-x. 14 root root 4096 Feb 2 14:33 usr # 可分享不可变动的，所有系统默认软件等drwxr-xr-x. 21 root root 4096 Feb 20 10:37 var # 缓存，登录文件以及某些软件运行所产生的文件等。 可变动的，不可变动的 可分享的，不可分享的]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日志文件]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[日志文件日志文件记录系统在什么时候由哪个进程做了什么样的行为，发生了何种事件等。 syslogd: 主要登录系统与网络等服务的信息。 klogd: 主要登录内核产生的各项信息。 logrotate: 主要进行日志文件的轮替功能。]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件，目录]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F%E6%96%87%E4%BB%B6%EF%BC%8C%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[目录与路径 cd pwd mkdir rmdir mkdir -m 711 test , mkdir -p -m mkdir -m 711 test/test/test/test1 (仅test1 为711) rmdir -p test/test/test/test1 （递归删除空目录） 查询 file /user/bin/passwd # 查询某文本数据类型 which python # 查询某命令位置 whereis passwd # 查询某目录，文件位置 locate passwd # -i 忽略大小写 -r 接正则表达式 find # 能执行额外的动作 内存交换空间（swap）CPU读取的数据都来自于内存，内存不足时，内存中暂不使用的程序和数据会被移动到swap中 #]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于vi]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F%E5%85%B3%E4%BA%8Evi%2F</url>
    <content type="text"><![CDATA[vivi的使用 一般模式 编辑模式 （i,I，o,O,a,A,r,R）(Ii aA 插入)（oO 插入一行）(Rr 替换) 命令行模式 (: / ?)123dos2unix filenamedos2unix和unix2dos，dos2unix把&quot;\r\n&quot;转化成&quot;\n&quot;，unixtodos把&quot;\n&quot;转化成&quot;\r\n]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IP地址]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2Fip%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[ip 地址就是 网络中的 地址信息 IPv4 与 IPIPVIPv4 格式 A.B.C.D 取值范围 0 ~ 255 2*32 个IPv6 格式 A:B:C:D:E:F:G:H 十六进制 2*128 个 16*32 公网 ip 和 内网 ip公网内 ip 地址由 inter NIC 负责。公有地址全球唯一私有地址 是非注册地址，用于组织机构内部使用 私有地址范围 A 类 IP 地址 ： 10.0.0.0 ~ 10.255.255.255 B 类 IP 地址 ： 172.16.0.0 ~ 172.31.255.255 C 类 IP 地址 ： 192.168.0.0 ~ 192.168.255.255 私有地址 不是由 internet分配的，不会出现在internet中。需要将私有 ip地址 转为 公网 IP 地址，与外部连接 （NAT）（私网地址访问互联网地址很方便，但互联网地址访问私有地址很困难） 内网的地址都是使用的路由器中的公共的公网ip来连接internet。 局域网内， IP 地址 是唯一的。但不同局域网， IP地址可以重复 localhost， 127.0.0.1 和 0.0.0.0 区别 localhost : 域名， windows默认将 localhost 指向127.0.0.1. 127.0.0.1 : 回环地址，凡是127 开头的 IP地址，都是回环地址（主机上发送给回环地址的数据 会自己接收，根本不传出去） 0.0.0.0 : 并不是一个真实的IP地址，他表示本机中所有的IPV4地址。监听本机所有的ip端口]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP基本原理]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2FHTTP%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. URL 与 URIURI : 统一资源标识符 URL : 统一资源定位符 (URN : 统一资源名称 只命名资源 而不指定如何定位资源) URL 是 URI 的子集 2. 超文本Hypertext ,用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。 网页源代码 HTML 可以称之为超文本。 3. HTTP HTTPSHTTP : 超文本传输协议，用于从网络传输超文本数据到本地浏览器的传送协议 HTTPS ： 以安全为目标的 HTTP通道。即 HTTP 下加入 SSL 层。通过其传输的内容都经过 SSL 加密。 建立一个安全信息通道，来保证数据传输的安全。 确认网站的真实性。 4. HTTP 请求过程浏览器（客户端） 输入 URL ,向服务器发送一个 Request (请求), 服务器收到 Request 后，返回对应的一个 Response (响应), Response 中包含页面的源代码等内容，浏览器再进行解析，便将网页呈现出来。 5. RequestRequest 可分为四部分 Request Method (请求方式) Request URL （请求连接） Request Headers （请求头） Request Body （请求体） 5.1 Request Method请求方式，常见有 GET , POST GET 请求参数会直接包含在URL里， （eg:https://www.baidu.com/s?wd=Python wd 就是要搜寻的关键字） POST 一般用于表单提交发起，数据常以 Form Data 即表单形式传输，不会体现在 URL 中。（包含在 Request Body 中） GET 请求提交的数据最多只有1024字节。 其他请求方式 HEAD PUT DELETE CONNECT OPTIONS TRACE 5.2 Request URL请求的网址，即统一资源定位符，可以唯一确定我们想请求的资源 5.3 Request Headers请求头， 用来说明服务器要使用的附加信息，比较重要的有Cookie,Refer,User-Agent等 Accept : 请求报头域，用于指定客户端可接受的语言类型 Accept-Language : 指定客户端可接受的语言类型 Accept-Encoding : 指定客户端可接受的内容编码 HOST : 用于指定请求资源的主机和端口号 Cookie : 是网站为了辨别用户进行 Session 跟踪而储存在用户本地的数据。 Referer : 用来标识这个请求是从哪个页面发出来的 User-Agent : UA,特殊的字符串头，使得服务器能够识别客户使用的操作系统及版本、浏览器及版本等信息。（爬虫时可加次信息伪装成浏览器） Content-type : 互联网媒体类型，在 HTTP 协议消息中，使用它来表示具体请求中的媒体类型信息。（Application/josn ,image/gif, text/html等） 5.4 Request Body一般承载的内容为 POST 请求中的Form Data , 而对于 GET 请求 Request Body 则为空。 6. Response由服务端返回给客服端。Response可以分为三部分 Request Status Code (响应状态码) Response Headers （响应头） Response Body （响应体） 6.1 Request Status Code200 表示正常。 404 表示页面未找到。 500 表示服务器内部异常。 一般情况下 2开头 （请求成功）表示成功处理了请求的状态代码。 3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 6.2 Response Headers包含了服务器对请求的应答信息 部分信息 date : 标识 Response 产生的时间 Last-Modified : 指定资源的最后修改时间 Content-Encoding ：指定 Response 内容的编码 Server : 包含了服务器的信息 Content-type ： 同Request Set-Cookie : 设置Cookie, 即告诉浏览器需要将此内容放到Cookies中，下次请求携带Cookies请求。 Expires : 指定 Response 的过期时间，使用它可以控制代理服务器或浏览器将内容更新到缓存中，如再次访问，直接从缓存中加载，降低服务器荷载，缩短加载时间。 6.3 Response Body响应的正文数据都是在响应体中（爬虫请求网页后要解析的数据就是解析响应体） 在浏览器开发工具中点击Preview,就可以看到网页源代码、json数据等，然后从中做相应内容的提取]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux基础]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2Freadme%2F</url>
    <content type="text"><![CDATA[基础 .bash_history 历史记录 Tab 补全 alias 命令别名， alias lm = ‘ls -al’ , unalias lm (临时) vi /root/.bashrc （永久） type cd 命令类型 \ 转义 变量 变量未设置时，默认为空 PATH=$PATH:/home/bin 变量累加 export PATH 使变量成为环境变量 一般默认 大写为系统变量 小写为自行设置变量 变量中 单引号’’（纯文本） 与 双引号 “” (保持原本特性) current_path=$(pwd) 接命令赋值给变量。 等同于 123456789101112current_path=`pwd`# 建议都用 $(pwd)``` 7. `unset current_path` 取消变量8. 子进程取消的变量 对 父进程无影响，子进程只继承父进程的环境变量与export。9. `work=/opt/software` 可以`cd $work` 。写入.bash_profile 全局生效。10. `env` 查看环境变量11. `set` 查看所有变量12. `echo $?` 只与上一个命令有关，上一个命令成功返回0## 变量读取，数组与声明 read -s -p “please input root password:” serverPwd # -p 提示 -s 不显示echo $serverPwdecho -e “\n” # -e 启用反斜杠转义 （换行）1**数组** var[1]=’small’var[2]=’big’echo “$var[1],$var[2]”1declare 和 typeset 一样声明变量类型 sum=100+1echo $sun # 100+1declare -i sum=100+1echo $sun # 101 1## $ $0 当前脚本的文件名$n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。$# 传递给脚本或函数的参数个数。$* 传递给脚本或函数的所有参数。 # 双引号内，会识别成一个整体$@ 传递给脚本或函数的所有参数。 # 双引号内，还是会识别成一个一个参数$? 上个命令的退出状态，或函数的返回值。一般情况下，大部分命令执行成功会返回 0，失败返回 1。$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID1234567891011121314151617## 与文件系统及程序的限制关系：ulimit## 数据流重定向st:standard1. stdin &lt; &lt;&lt; (代码0)2. stout &gt; &gt;&gt; (代码0)3. stderr 2&gt; 2&gt;&gt; (代码2)4. `&gt;/dev/null ,2&gt;/dev/null` 丢弃输出5. `&gt; list 2&gt;&amp;1 (都输出 list)或 &amp;&gt; list`## 命令执行判断依据1. cmd1,cmd2,cmd3 依次执行2. cmd1 &amp;&amp; cmd2 &amp;&amp; cmd3 前面成功，后面才执行（$# = 0）3. cmd1 || cmd2 || cmd3 前面成功，后面就不执行（$# = 0）## 管道命令（pipe）**将前一个命令的stout(不会处理stderr) 传到下一个命令的stdin中** yes|bash …sh(执行命令输入yes)echo $PATH |cut -d ‘:’ -f 4 # 以 : 分割$PATH ,取出第4个echo $PATH |cut -d ‘:’ -f 3,5 # 以 : 分割$PATH ,取出第3,5个export | cut -c 12- # 取出12到最后的字符last | grep -i root # 找出last中的含root行，忽略大小写last | grep -v root # 不含root行last | grep root|cut -d ‘ ‘ -f 1| sort | uniq -ic # i 忽略大小写 c 计数cat /etc/os-release | wc # 输出 行 字数 字符数wc -l(行) -w(英文单字) -m (多少字符)12## 双向重定向（tee）**将数据流同时输出到屏幕和文件中** last |tee -a last.list # -a 累加` shell脚本shell script 是利用shell的功能所写的一个纯文本文件，将一些shell的语法命令写在里面，搭配正则表达式，管道命令与数据流重定向等功能达到我们想要的目的。]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[个人计算机]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2F%E4%B8%AA%E4%BA%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[个人计算机架构与接口设备主板主流 x86 开发商（Intel，AMD）的 cpu 架构并不兼容， 两大主流的 CPU 所需要的主板芯片组设计也不相同。 芯片组 分为两个 桥接器 来控制各组件通信 北桥负责连接速度较快的 CPU 、内存、显卡等组件 南桥负责连接速度较慢的周边接口，包括usb,硬盘，网卡等 tips : AMD 将内存控制组件集成到 CPU 当中，急速 CPU 与内存的传输速度。（AMD 和 INTEL 的架构上的主要区别） CPU 多核 ： 一个 CPU 多个运算内核 频率 ： CPU 每秒可进行的工作次数，等于外频和倍数的乘积（外频：CPU与外部组件进行数据传输/运算时的速度，倍频：CPU内部用来加速工作性能的一个倍速） 32位 与 64位： 主要依据 CPU 解析的字组大小来判定。 32位 CPU 最大只能够支持到 4GB 内存 内存个人计算机的内存主要组件为 动态随机访问内存 （通电使用与记录，断电数据消失） 双通道设计理念 ： 一条内存仅达 64位，两条内存可达128位 BIOS ： Basic input output System , 写死到只读存储器中 （Read Only Memory,rom）,BIOS 系统在开机的时候首先读取的一个程序。（因为升级BIOS，现在BIOS通常写在闪存或EEPROM） 显卡显卡上面有一个 内存的容量，将会影响到最终的屏幕分辨率与色彩深度。运算速度，显卡上面嵌入一个 3D 加速的芯片 ， GPU 的由来。 硬盘PCI适配卡电源]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP的基本原理]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2FHTTP%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. URL 与 URIURI : 统一资源标识符 URL : 统一资源定位符 (URN : 统一资源名称 只命名资源 而不指定如何定位资源) URL 是 URI 的子集 2. 超文本Hypertext ,用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。 网页源代码 HTML 可以称之为超文本。 3. HTTP HTTPSHTTP : 超文本传输协议，用于从网络传输超文本数据到本地浏览器的传送协议 HTTPS ： 以安全为目标的 HTTP通道。即 HTTP 下加入 SSL 层。通过其传输的内容都经过 SSL 加密。 建立一个安全信息通道，来保证数据传输的安全。 确认网站的真实性。 4. HTTP 请求过程浏览器（客户端） 输入 URL ,向服务器发送一个 Request (请求), 服务器收到 Request 后，返回对应的一个 Response (响应), Response 中包含页面的源代码等内容，浏览器再进行解析，便将网页呈现出来。 5. RequestRequest 可分为四部分 Request Method (请求方式) Request URL （请求连接） Request Headers （请求头） Request Body （请求体） 5.1 Request Method请求方式，常见有 GET , POST GET 请求参数会直接包含在URL里， （eg:https://www.baidu.com/s?wd=Python wd 就是要搜寻的关键字） POST 一般用于表单提交发起，数据常以 Form Data 即表单形式传输，不会体现在 URL 中。（包含在 Request Body 中） GET 请求提交的数据最多只有1024字节。 其他请求方式 HEAD PUT DELETE CONNECT OPTIONS TRACE 5.2 Request URL请求的网址，即统一资源定位符，可以唯一确定我们想请求的资源 5.3 Request Headers请求头， 用来说明服务器要使用的附加信息，比较重要的有Cookie,Refer,User-Agent等 Accept : 请求报头域，用于指定客户端可接受的语言类型 Accept-Language : 指定客户端可接受的语言类型 Accept-Encoding : 指定客户端可接受的内容编码 HOST : 用于指定请求资源的主机和端口号 Cookie : 是网站为了辨别用户进行 Session 跟踪而储存在用户本地的数据。 Referer : 用来标识这个请求是从哪个页面发出来的 User-Agent : UA,特殊的字符串头，使得服务器能够识别客户使用的操作系统及版本、浏览器及版本等信息。（爬虫时可加次信息伪装成浏览器） Content-type : 互联网媒体类型，在 HTTP 协议消息中，使用它来表示具体请求中的媒体类型信息。（Application/josn ,image/gif, text/html等） 5.4 Request Body一般承载的内容为 POST 请求中的Form Data , 而对于 GET 请求 Request Body 则为空。 6. Response由服务端返回给客服端。Response可以分为三部分 Request Status Code (响应状态码) Response Headers （响应头） Response Body （响应体） 6.1 Request Status Code200 表示正常。 404 表示页面未找到。 500 表示服务器内部异常。 一般情况下 2开头 （请求成功）表示成功处理了请求的状态代码。 3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 6.2 Response Headers包含了服务器对请求的应答信息 部分信息 date : 标识 Response 产生的时间 Last-Modified : 指定资源的最后修改时间 Content-Encoding ：指定 Response 内容的编码 Server : 包含了服务器的信息 Content-type ： 同Request Set-Cookie : 设置Cookie, 即告诉浏览器需要将此内容放到Cookies中，下次请求携带Cookies请求。 Expires : 指定 Response 的过期时间，使用它可以控制代理服务器或浏览器将内容更新到缓存中，如再次访问，直接从缓存中加载，降低服务器荷载，缩短加载时间。 6.3 Response Body响应的正文数据都是在响应体中（爬虫请求网页后要解析的数据就是解析响应体） 在浏览器开发工具中点击Preview,就可以看到网页源代码、json数据等，然后从中做相应内容的提取]]></content>
      <categories>
        <category>flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[环境准备与自动卸载部署]]></title>
    <url>%2Fwork%2F%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[记录原因上个月为了减轻自己的工作量，将日常部署工作进行了流程化处理后来根据上级的要求，做了一个全自动化的安装卸载脚本，做完之后，给我提了如下修改意见。因为本人又喜欢分享。但因保密要求，提供的并非完整代码，只是一种示意。github地址 主要功能 环境的一键搭建 xx的一键部署 xx的自动部署卸载xx部署，部署成功一个小时后，自动卸载后重新部署。如果部署失败，则停止部署。(还可以扩展，部署失败自动发邮件等) 遇到的主要问题 密码问题(写入到配置文件当中，后续可以进行加密后写入配置文件) 后台命令，不能read终端输出的问题（用python传入密码，读出解决） 集群卸载问题（从配置文件中利用正则筛选出集群ip，scp传送文件，ssh执行命令，然后用pexcept解决password以及yes/no的输入。）（利用paramiko更加容易，但尽量使用python原生方式） 自动脚本的停止（对linux 的kill -9 进行了一下封装，统一调用） 简化使用问题（使用try,except对调用进行提示，尽量减少别人查看使用方法） 检视意见 重复卸载，需要提供提示 工具运行脚本需简化，提供统一调用接口，接口用法需要提示用户 工具使用文档内容离散难懂，需要整理说明 工具代码中增加异常保护和处理 判断安装是否成功不应该读取日志，而是通过调用脚本返回值判断 xx安装完成后，需要增加判断xx是否能使用 提供安装策略文件，支持以不同方式安装xx，比如：双平面, 单机, 集群, 多操作系统等 系统命令统一使用shell脚本，便于修改 工具需要屏蔽xx版本差异 root节点的密码需要加密保存 安装过程信息需要记录到日志中 python代码中增加异常保护 整个工具按照通用的方式去排查，硬编码的内容建议抽取放置到配置文件中 检视的代码，是因为最初只是想完成功能，就面向过程写的，最后要兼容不同的部署方式，以及未来的扩展需求，于是改用面向对象虽然以面向对象的方式写脚本有点刻意，但以面向过程的方式，不易扩展，改写困难，加上训练一下自己，所以改写。 环境准备详情见：setting.pyupload.py 安装部署详情见：部署卸载自动部署卸载]]></content>
      <categories>
        <category>work</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[给博客加日期]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E7%BB%99%E5%8D%9A%E5%AE%A2%E5%8A%A0%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[之前写文章，一直没有写时间，也没多大问题。后来换了一台电脑后，上传新文章全部乱了顺序。原来之前是按文件的创建时间排序，而我这复制过来的文件，创建时间几乎一样。所以博客乱了套。后来发现文件的修改时间还是以前的，于是给每篇文章，按修改时间添加了date。 代码如下12345678910111213141516171819import osimport sysimport timepath = r&apos;E:\WeiLai\OneDrive\blog\source\_posts&apos;for root, dir, files in os.walk(path): for file in files: full_path = os.path.join(root, file) if &apos;.md&apos; in full_path: mtime = os.stat(full_path).st_mtime file_modify_time = time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;, time.localtime(mtime)) date = &apos;date: &apos;+file_modify_time with open (full_path,&apos;r&apos;, encoding=&apos;UTF-8&apos;) as f: s = f.read() q = s.partition(&apos;tags:&apos;) t = q[0] + date +&apos;\n&apos; + q [1] + q[2] with open (full_path,&apos;w&apos;, encoding=&apos;UTF-8&apos;) as f: f.write(t)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python操作mysql(ORM)]]></title>
    <url>%2Fpython%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2Fpython%E6%93%8D%E4%BD%9Cmysql(ORM)%2F</url>
    <content type="text"><![CDATA[使用SQLAlchemy 安装方法pip install SQLAlchemy 更多内容参考flask鱼书项目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127from sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_base from sqlalchemy import Column, Integer, String ,DateTime, Boolean# 连接数据库engine = create_engine(&apos;mysql://root:password@localhost:3306/school?charset=utf8&apos;)## 编码问题# # 获取基类Base = declarative_base()class News(Base): # 继承基类 __tablename__ = &apos;students1&apos; id = Column(Integer, primary_key = True) nickname = Column(String(20)) name = Column(String(20), nullable = False) sex = Column(String(1)) in_time = Column(DateTime) is_vaild = Column(Boolean) idcard = Column(Integer, unique = True) News.metadata.create_all(engine) # 创建表格## 新增数据from sqlalchemy.orm import sessionmakerSession = sessionmaker(bind=engine)class OrmTest(object): def __init__(self): self.session = Session() def add_one(self): new_obj = News( nickname = &apos;123&apos;, name = &apos;321&apos;, sex = &apos;男&apos;, ) self.session.add(new_obj) self.session.commit() return new_obj def add_more(self): new_obj = News( nickname = &apos;123&apos;, name = &apos;321&apos;, sex = &apos;男&apos;, ) new_obj2 = News( nickname = &apos;wei&apos;, name = &apos;lai&apos;, sex = &apos;女&apos;, ) self.session.add_all([new_obj, new_obj2]) self.session.commit() return new_obj## 查询数据 def get_one(self): return self.session.query(News).get(10) # get 是选id为2的 def get_more(self): return self.session.query(News).filter_by(is_vaild=True)## 修改数据## 将一条当作多条的一种情况 def update_data(self): data_list = self.session.query(News).filter(News.id &gt;= 5) for item in data_list: if item: item.is_vaild = 0 self.session.add(item) # 加入 self.session.commit() # 提交## filter 与 filter_by 的区别## 删除数据 def delete_data(self): data = self.session.query(News).get(8) if data: self.session.delete(data) self.session.commit() else: return False def delete_data_more(self): delete_list = self.session.query(News).filter(News.id &lt;= 5) for item in delete_list: if item: self.session.delete(item) else: return False self.session.commit() def main(): obj = OrmTest() obj.add_one() obj.add_more() data = obj.get_one() ## 防止查询失误 if data: print(&apos;ID:&#123;0&#125; &#123;1&#125;&apos;.format(data.id,data.sex)) else: print(&apos;Not exist&apos;) data_more = obj.get_more() print(data_more.count()) # 计数 for new_obj in data_more: print(&apos;ID:&#123;0&#125; &#123;1&#125; &#123;2&#125; &#123;3&#125;&apos;.format(new_obj.id,new_obj.sex,new_obj.name,new_obj.nickname)) obj.update_data() print(&apos;数据修改成功&apos;) obj.delete_data() print(&apos;数据删除成功&apos;) obj.delete_data_more()if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>mysql学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql基础(1)]]></title>
    <url>%2Fpython%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%E5%9F%BA%E7%A1%80(1)%2F</url>
    <content type="text"><![CDATA[windows安装过程参考之前的文章https://www.jianshu.com/p/e35185ec3294 MySQL语法基础创建表– 为注释，不会被执行 使用查询语句建表12345678910111213141516171819202122232425-- 新建数据库CREATE DATABASE`school`;-- 使用数据库USE `school`;-- 创建表格-- id-- name-- nickname-- sex-- in_timeCREATE TABLE `students`( `id` INT NOT NULL AUTO_INCREMENT PRIMARY KEY, `name` VARCHAR(20) NOT NULL, `nickname` VARCHAR(20) NULL, `sex` CHAR(1) NULL, `in_time` DATETIME NULL) DEFAULT CHARSET &apos;UTF8&apos;;-- PRIMARY KEY 主键是用来唯一定位记录的-- 建议不使用任何业务相关的字段作为主键-- 在students表中添加一个class idALTER TABLE `school`.`students`ADD COLUMN `class id` int NULL AFTER `id`; 插入数据12345678910111213-- 插入students表 -- now():mysql中当前时间INSERT INTO `students` VALUE(1,&apos;weilai&apos;,&apos;imwl&apos;,&apos;男&apos;,now());-- 可以选择性插入INSERT INTO `students`(`name`,`nickname`,`sex`,`in_time`) VALUES(&apos;weilai&apos;,&apos;imwl&apos;,&apos;男&apos;,now());-- 插入多行数据INSERT INTO `students`(`name`,`nickname`,`sex`,`in_time`) VALUES(&apos;weilai2&apos;,&apos;imwl&apos;,&apos;男&apos;,now()),(&apos;weilai&apos;,&apos;imwl&apos;,&apos;男&apos;,now()),(&apos;weilai&apos;,&apos;imwl&apos;,&apos;男&apos;,now()),(&apos;weilai&apos;,&apos;imwl&apos;,&apos;男&apos;,now()); 查询数据1234567891011121314151617-- 查询数据库-- * 表示所有的SELECT * FROM `students`;-- 只查询name 和 nicknameSELECT `name`,`nickname` FROM `students`;-- 只查询name 和 nickname,同时性别为男的(查询表中不显示男)SELECT `name`,`nickname` FROM `students` WHERE `sex`=&apos;男&apos;;-- 在上面基础上id倒序SELECT `id`,`name`,`nickname` FROM `students` WHERE `sex`=&apos;男&apos;ORDER BY `id` DESC;-- 在上面基础上分页-- 0，2 : 从第1条数据开始，显示2条SELECT `id`,`name`,`nickname` FROM `students` WHERE `sex`=&apos;男&apos;ORDER BY `id` DESC LIMIT 0,2;-- 1,2 : 从第2条数据开始，显示2条SELECT `id`,`name`,`nickname` FROM `students` WHERE `sex`=&apos;男&apos;ORDER BY `id` DESC LIMIT 1,2; 修改数据where 很重要，不然就是改动整张表的数据123456789-- 修改-- 将所有的性别改女UPDATE `students` SET `sex`=&apos;女&apos;;-- 将name为weilai 的性别回男UPDATE `students` SET `sex`=&apos;男&apos; WHERE `name` = &apos;weilai&apos;;-- 将name为weilai 的性别为男,nickname改为没有昵称UPDATE `students` SET `sex`=&apos;男&apos;,`nickname`=&apos;没有昵称&apos; WHERE `name` = &apos;weilai&apos;;-- 将id &lt;3 的性别改为女UPDATE `students` SET `sex`=&apos;女&apos; WHERE `id` &lt; 3 删除数据 12345-- 删除数据 -- 删除students表中，性别为女的数据DELETE FROM `students` WHERE `sex` = &apos;女&apos;-- 删除students表中全部数据DELETE FROM `students` 444]]></content>
      <categories>
        <category>mysql学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql基础(2)]]></title>
    <url>%2Fpython%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%E5%9F%BA%E7%A1%80(2)%2F</url>
    <content type="text"><![CDATA[外键在students表中，通过class id的字段，可以把数据与另一张表（class）关联起来，这种列称为外键。 在students表中添加一个class id(id的后一列)12ALTER TABLE `school`.`students`ADD COLUMN `class id` int NULL AFTER `id`; 在数据库school中建立一个班级表1234CREATE TABLE `students`( `class id` INT NOT NULL AUTO_INCREMENT PRIMARY KEY, `name` VARCHAR(20) NOT NULL,) DEFAULT CHARSET &apos;UTF8&apos;; 添加/删除 外键12345678910111213ALTER TABLE `students`ADD CONSTRAINT `qe`-- 外键约束名称，随意取值 FOREIGN KEY (`class id`)REFERENCES `class` (`id`);-- ALTER TABLE `school`.`students` -- ADD FOREIGN KEY (`class id`) REFERENCES `school`.`class` (`id`);-- 删除外键ALTER TABLE `students`DROP FOREIGN KEY `qe`;删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现的 通过中间表，可以定义了一个“多对多”关系。 一对一：一个表的记录对应到另一个表的唯一一个记录 有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度 索引在查找记录的时候，想要获得非常快的速度，就需要使用索引123456ALTER TABLE `school`.`students` ADD INDEX `sex search`(`sex`); -- 名称为sex search，使用列 sex 的索引-- 也可以多列ALTER TABLE `school`.`students` ADD INDEX `search`(`sex`，`name`); 索引的效率取决于索引列的值是否散列，例如sex列，大约一半的记录值是男，另一半是女，因此，对该列创建索引就没有意义。123ALTER TABLE `school`.`students` DROP INDEX `sex search`;-- 删除索引 **假设name不重复，那么可以创建唯一索引1ADD UNIQUE INDEX `search`(`name`) **没索引，但对is_vaild进行唯一约束12ALTER TABLE studentsADD CONSTRAINT uni_name UNIQUE (is_vaild); 通过对数据库表创建索引，可以提高查询速度。 通过创建唯一索引，可以保证某一列的值具有唯一性。 数据库索引对于用户和应用程序来说都是透明的。 查询补充12345SELECT * FROM `students` WHERE `id` &gt;= 10 AND `sex` != &apos;女&apos; GROUP BY `id` HAVING `in_time` ORDER BY `id` DESC LIMIT 0,3;SELECT COUNT(*) num FROM `students` WHERE NOT `id` &gt;= 10 AND `sex` != &apos;女&apos; ORDER BY `id` DESC LIMIT 0,8 ;SELECT AVG(id) num FROM `students` WHERE NOT `id` &gt;= 10 AND `sex` != &apos;女&apos; ORDER BY `id` DESC LIMIT 0,8 ; 4]]></content>
      <categories>
        <category>mysql学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql基础(3)]]></title>
    <url>%2Fpython%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%E5%9F%BA%E7%A1%80(3)%2F</url>
    <content type="text"><![CDATA[多表联查 使用多表查询可以获取M x N行记录（M,N为两个表各自的行数）多表查询的结果集可能非常巨大，要小心使用。 内连接123456789101112131415mysql&gt; SELECT s.id, s.name,`s`.`class id`, s.nickname,s.sex,c.name,s.in_time,s.is_vaild FROM students s INNER JOIN class c ON `s`.`class id` = c.id;+----+---------+----------+-----------+------+--------------+---------------------+----------+| id | name | class id | nickname | sex | name | in_time | is_vaild |+----+---------+----------+-----------+------+--------------+---------------------+----------+| 7 | weilai | 202 | imwl | 男 | 二年二班 | 2018-12-27 22:05:41 | 1 || 8 | weilai | 202 | imwl | 男 | 二年二班 | 2018-12-27 22:05:41 | 2 || 9 | weilai | 202 | imwl | 男 | 二年二班 | 2018-12-27 22:05:41 | NULL || 10 | weilai2 | 201 | imwl | 男 | 二年一班 | 2018-12-27 22:05:41 | NULL || 12 | name1 | 201 | nickname1 | 女 | 二年一班 | NULL | NULL || 13 | name2 | 201 | nickname2 | 男 | 二年一班 | NULL | NULL || 19 | 2 | 301 | i | 男 | 三年一班 | 2019-02-27 12:02:04 | NULL || 20 | 3 | 301 | m | 女 | 三年一班 | 2019-02-27 12:02:04 | NULL || 21 | 4 | 302 | w | 男 | 三年二班 | 2019-02-27 12:02:04 | NULL || 22 | 5 | 302 | l | 男 | 三年二班 | 2019-02-27 12:02:04 | NULL |+----+---------+----------+-----------+------+--------------+---------------------+----------+ INNER JOIN查询的写法是： 先确定主表，仍然使用FROM &lt;表1&gt;的语法；再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法；然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是s.class id = c.id，表示students表的class id列与class表的id列相同的行需要连接；可选：加上WHERE子句、ORDER BY等子句。 小结JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上； INNER JOIN是最常用的一种JOIN查询，它的语法是SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;； JOIN查询仍然可以使用WHERE条件和ORDER BY排序。 补充知识假设查询语句是： 1SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2; 我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录： LEFT OUTER JOIN是选出左表存在的记录： RIGHT OUTER JOIN是选出右表存在的记录： FULL OUTER JOIN则是选出左右表都存在的记录：]]></content>
      <categories>
        <category>mysql学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库]]></title>
    <url>%2Fpython%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[数据库分类 关系型数据库 （MySQL,SQLServer,MariaDB,ORACLE等） 非关系型数据库 (mongoDB,redis等） 非关系型数据库分类1 . 文档型2 . key-value型3 . 列式数据库4 . 图形数据库]]></content>
      <categories>
        <category>mysql学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用MySQL]]></title>
    <url>%2Fpython%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E4%BD%BF%E7%94%A8MySQL%2F</url>
    <content type="text"><![CDATA[示例数据 https://codeload.github.com/datacharmer/test_db/zip/master导入 eg: mysql -u root -p &lt; employees.sql 连接到 MySQL \g 输出水平显示 \G 输出垂直显示 12mysql -h localhost -P 3306 -u root -p - 连接到mysqlALTER USER `root`@`localhost` IDENTIFIED BY &apos;password&apos;; - 修改密码 创建数据库数据库是许多表的集合，数据库服务器可以容纳许多这样的数据库 数据库服务器 → 数据库 → 表（由列定义） → 行 CREATE/ALTER/DROP 数据库对象（数据库和表） 称为 数据定义语言（DDL）操作 INSERT/UPDATE/DELETE /SELECT 称为 数据操作语言（DML） 前三项也称 写，SELECT 也称 读 1234567CREATE DATABASE company; - 创建数据库 建议都用 ``CREATE DATABASE `my.contacts`; - 用反标记字符 ``（当数据库和表含特殊字符时） USE `company`; - 使用 company 数据库mysql -u root -p company - 直接连接到 company 数据库SELECT DATABASE(); - 查找连接到的数据库SHOW DATABASES; - 查找有权访问的所有数据库SHOW VARIABLES LIKE &apos;company&apos;; - 获取当前的数据目录 sudo ls -lhtr /usr/lcoal/mysql/data/ 创建表1234567891011CREATE TABLE IF NOT EXISITS `company`.`customers`(`id` int unsigned AUTO_INCREMENT PRIMARY KEY,`first_name` varchar(20),`last_name` varchar(20),`country` varchar(20)) ENGINE=InnoDB DEFAULT CHARSET=utf8;SHOW TABLES - 查看所有表SHOW CREATE TABLE customers\G - 查看表结构DESC customers;CREATE TABLE new_costomers Like customers - 克隆表结构 增删改查参考 删除表的所有行最快的方式 TRUNCATE TABLE customers DDL操作。 创建用户除非是localhost的管理任务等，一般不推荐使用root 用户连接到 mysql执行语句]]></content>
      <categories>
        <category>mysql学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python操作mysql（增删改查）]]></title>
    <url>%2Fpython%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2Fpython%E6%93%8D%E4%BD%9Cmysql(%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5)%2F</url>
    <content type="text"><![CDATA[使用mysqlclient先安装mysqlclient网址：https://pypi.org/project/mysqlclient/python中可使用pip安装，pip install mysqlclient 也可以使用别的方法，详细可查看之前的文章：爬取百度百科词条写入数据库 python操作mysql查询数据1234567891011121314151617181920import MySQLdb# 获取连接connection = MySQLdb.connect( host = &apos;localhost&apos;, user = &apos;root&apos;, password = &apos;password&apos;, db = &apos;school&apos;, charset = &apos;utf8mb4&apos;, port = 3306 # 默认3306，可不填port)# 获取数据cursor = connection.cursor()cursor.execute(&apos;SELECT * FROM `students`ORDER BY `in_time`DESC;&apos;) result = cursor.fetchone() # 获取第一条数据print (result)# 关闭连接connection.close() 可能会出现异常，所以改写12345678910111213141516171819202122232425import MySQLdbtry:# 获取连接 connection = MySQLdb.connect( host = &apos;localhost&apos;, user = &apos;root&apos;, password = &apos;password&apos;, db = &apos;school&apos;, charset = &apos;utf8mb4&apos;, port = 3306 # 默认3306，可不填port ) # 获取数据 cursor = connection.cursor() cursor.execute(&apos;SELECT * FROM `students`ORDER BY `in_time`DESC;&apos;) result = cursor.fetchone() # 获取第一条数据 print (result)except MySQLdb.Error as e: print(&apos;Error : %s &apos; % e)finally: # 关闭连接 connection.close() 因为这个操作是所有都有的，所以封装成一个对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import MySQLdbclass MysqlSearch: def __init__(self): self.get_connection() def get_connection(self): try: self.connection = MySQLdb.connect( host = &apos;localhost&apos;, user = &apos;root&apos;, password = &apos;password&apos;, db = &apos;school&apos;, charset = &apos;utf8mb4&apos;, port = 3306 # 默认3306，可不填port ) except MySQLdb.Error as e: print(&apos;Error : %s &apos; % e) def close_connection(self): try: if self.connection: self.connection.close() except MySQLdb.Error as e: print(&apos;Error : %s &apos; % e) def get_one(self): # 获取会话指针 cursor = self.connection.cursor() # 准备sql sql = &apos;SELECT * FROM `students`WHERE`name`=%s ORDER BY `in_time`DESC;&apos; # 执行sql cursor.execute(sql,(&apos;weilai&apos;,)) # print(cursor.description) ## ((&apos;id&apos;, 3, 1, 11, 11, 0, 0), (&apos;name&apos;, 253, 6, 80, 80, 0, 0), ## (&apos;nickname&apos;, 253, 4, 80, 80, 0, 1), (&apos;sex&apos;, 254, 3, 4, 4, 0, 1), ## (&apos;in_time&apos;, 12, 19, 19, 19, 0, 1)) ## 获得一条结果 # a = [k[0] for k in cursor.description], ## a = [&apos;id&apos;, &apos;name&apos;, &apos;nickname&apos;, &apos;sex&apos;, &apos;in_time&apos;] # b = [k[0] for k in cursor.description],cursor.fetchone() ## ([&apos;id&apos;, &apos;name&apos;, &apos;nickname&apos;, &apos;sex&apos;, &apos;in_time&apos;], ## (7, &apos;weilai&apos;, &apos;imwl&apos;, &apos;男&apos;, datetime.datetime(2018, 12, 27, 22, 5, 41))) result = dict(zip([k[0] for k in cursor.description],cursor.fetchone())) # 关闭 cursor 和连接 cursor.close() self.close_connection() return result def get_more(self): cursor = self.connection.cursor() sql = &apos;SELECT * FROM `students`WHERE`name`=%s ORDER BY `in_time`DESC;&apos; cursor.execute(sql,(&apos;weilai&apos;,)) result = [dict(zip([k[0] for k in cursor.description],row)) for row in cursor.fetchall()] # print(result) # [&#123;&apos;id&apos;: 7, &apos;name&apos;: &apos;weilai&apos;, &apos;nickname&apos;: &apos;imwl&apos;, &apos;sex&apos;: &apos;男&apos;, &apos;in_time&apos;: datetime.datetime(2018, 12, 27, 22, 5, 41)&#125;, # &#123;&apos;id&apos;: 8, &apos;name&apos;:&apos;weilai&apos;, &apos;nickname&apos;: &apos;imwl&apos;, &apos;sex&apos;: &apos;男&apos;, &apos;in_time&apos;: datetime.datetime(2018, 12, 27, 22, 5, 41)&#125;, # &#123;&apos;id&apos;: 9, &apos;name&apos;: &apos;weilai&apos;, &apos;nickname&apos;: &apos;imwl&apos;, &apos;sex&apos;: &apos;男&apos;, &apos;in_time&apos;: datetime.datetime(2018, 12, 27, 22, 5, 41)&#125;] cursor.close() self.close_connection() return resultdef main(): obj = MysqlSearch() # a = obj.get_one() # print(a) # print(a[&apos;id&apos;]) b = obj.get_more() for item in b: print(item)if __name__ == &apos;__main__&apos;: main()# zip函数&apos;&apos;&apos;zip() 将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，元素个数与最短的一致&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b) # 返回一个对象&gt;&gt;&gt; zipped&lt;zip object at 0x103abc288&gt;&gt;&gt;&gt; list(zipped) # list() 转换为列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; list(zip(a,c)) # 元素个数与最短的列表一致[(1, 4), (2, 5), (3, 6)] &gt;&gt;&gt; a1, a2 = zip(*zip(a,b)) # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式&gt;&gt;&gt; list(a1)[1, 2, 3]&gt;&gt;&gt; list(a2)[4, 5, 6]&apos;&apos;&apos; ** 补充(分页查询)：12345678910111213141516def get_more_by_pages(self, page, page_size): # 分页查询数据 offset = (page -1) * page_size cursor = self.connection.cursor() sql = &apos;SELECT * FROM `students`WHERE`name`=%s ORDER BY `in_time`DESC LIMIT %s , %s;&apos; cursor.execute(sql,(&apos;weilai&apos;, offset, page_size)) result = [dict(zip([k[0] for k in cursor.description],row)) for row in cursor.fetchall()] # print(result) # [&#123;&apos;id&apos;: 7, &apos;name&apos;: &apos;weilai&apos;, &apos;nickname&apos;: &apos;imwl&apos;, &apos;sex&apos;: &apos;男&apos;, &apos;in_time&apos;: datetime.datetime(2018, 12, 27, 22, 5, 41)&#125;, # &#123;&apos;id&apos;: 8, &apos;name&apos;:&apos;weilai&apos;, &apos;nickname&apos;: &apos;imwl&apos;, &apos;sex&apos;: &apos;男&apos;, &apos;in_time&apos;: datetime.datetime(2018, 12, 27, 22, 5, 41)&#125;, # &#123;&apos;id&apos;: 9, &apos;name&apos;: &apos;weilai&apos;, &apos;nickname&apos;: &apos;imwl&apos;, &apos;sex&apos;: &apos;男&apos;, &apos;in_time&apos;: datetime.datetime(2018, 12, 27, 22, 5, 41)&#125;] cursor.close() self.close_connection() return result 新增/修改数据到数据库出现问题不应该提交 12345678910111213141516171819202122def add_one(self): # 准备SQL try: sql = ( &quot;INSERT INTO `students` (`name`,`nickname`,`sex`,`in_time`) VALUE&quot; &quot;(%s,%s,%s,%s);&quot; ) cursor = self.connection.cursor() # 可以提交多条 cursor.execute(sql,(&apos;name1&apos;, &apos;nickname1&apos;, &apos;男&apos;, None)) cursor.execute(sql,(&apos;name2&apos;, &apos;nickname2&apos;, &apos;男&apos;, &apos;haha&apos;)) # 提交事务 self.connection.commit() # 关闭cursor和连接 cursor.close() except MySQLdb.Error as e: print(&apos;Error : %s &apos; % e) self.connection.rollback() self.close_connection()]]></content>
      <categories>
        <category>mysql学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017-2018年总结(初版)]]></title>
    <url>%2F%E9%9A%8F%E7%AC%94%2F2017-2018%20%E6%80%BB%E7%BB%93(%E5%88%9D%E7%89%88)%2F</url>
    <content type="text"><![CDATA[本打算写一个2018年总结，想了一下，觉得还是从学生时代结束后开始写比较好。 从2017-07到现在2019-01，没想到竟然已经18个月了。这18个月，真的算是，对自己一个磨练。所以之前元旦所说的空空如也，并不完全正确，至少在某些方面，确实还有点进步。(2018-10应该算是一个比较重要的分水岭吧) 粗略分为4个方面工作方面准确来说，目前从事过两份工作。 2017-08 至 2017-12。毕业后在某研究所工作。刚开始得到这个工作机会的时候还是挺开心的，毕竟做毕设拿院优，他们的软件占很大成分；同事之间相处也很和睦。主要工作就是给客户解决软件以及设计上的问题，时常需要出差。这工作太闲了，所以当时一直在胡思乱想。后来，我认真思考了一下以后的出路，如果继续这一行，好像只有去做设计了，而我对设计确实没什么兴趣。(一到冬天我就不想呆在济南的原因,可能就是因为雾霾吧。那个地方雾霾比济南还严重，所以就提出了辞职。） 2018-04至2019-01。亲戚介绍了一份工作。当时我其实不想去的，但当时已经在家闲置了快3个月。加上确实很迷茫，不知道以后该干嘛。还有当时说先去看看，然后就过去了。刚开始抱着学习技术的态度去的，后来发现自己多虑了。我从没有想过会从事这么久，期间真的无数次想辞职。刚开始碍于情面，所以不曾开口。后来又因为惰性，习惯了。目前看来，从事这么久的主要原因:一是确实很闲，平常帮师傅们打打下手啥的；二是旅游耗费了太多钱财，弄得经济困难；三是，国庆后，开始认真学习python，有时间学习。 学习方面第一个工作阶段，确实很充实，每天都在自学（职业相关的），即使现在对我而言一点意义都没有了。 第二个工作阶段，到国庆前，即使很闲，但也基本没有主动学习过；国庆后开始感觉自己的学习效率在逐渐提高，也有学习的意识了。在此期间，搭建了自己的个人博客来记录，网址为：https://itswl.github.io 生活方面没有以前那么慵懒了，变得更加的独立。 17年的时候，想着爬华山，看兵马俑，逛陕博，但又因为一个人，懒得行动。心想着不急，终究会去的，结果离开了也未曾去过。 今年得知，张家界离这里不远。（以前外公曾说，等我们初中的时候，就带我们去张家界玩，结果到现在还没带我们去。我都不知道是不是他不记得了，我中秋的时候回去也忘记提这件事了。）然后五一期间，就一个人去了。去了发现凤凰也不远，于是也去了凤凰。算是一个开端吧。 当然还有一个特别重大的事：我从2018-8到现在一滴可乐都没喝过。我并不觉得可乐会带来什么危害，不喝可乐，只是单纯的为了克制一下自己那种欲望。 思想上面我觉得一个人最大的进步就是思想上面的，当然只是我个人现在的想法。挺怀恋刚毕业的时候，自信，洒脱。也享受孤独的感觉，能在元旦的晚上冻成狗，也能在群处怡然自得。更加包容多元，更加心平气和。 总结既然是总结，那么总结一下。不好的地方:浪费了太多时间，当断不断。 好的地方：戒掉了可乐，开始养生，有了学习的意识。变得更加的独立，也不会感到孤独。 期待:2019，能够真的成长吧 补(一)读万卷书，行万里路，真的是很有用的话。行，使我开阔；读书使我静下心。 补(二)今年春运，本着学习爬虫看一下12306，结果还是使用了他人的软件，帮别人买了10多张张春运票，也能算是比较有成就感吧。 补(三)]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬虫整理（四）多进程分布式与异步]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E7%88%AC%E8%99%AB%E6%95%B4%E7%90%86-(%E5%9B%9B)-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[有的时候，爬取速度不快，就要想一些其他的办法。比如多进程多线程以及异步。不过一般的网站都会对其有限制，所以还得看实际情况具体来选取爬虫方式。爬虫并不复杂。爬虫更关键的是在，爬虫，反爬虫和反反爬虫这一块。 多进程分布式与异步的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from urllib.request import urlopen, urljoinfrom bs4 import BeautifulSoupimport multiprocessing as mpimport reimport timedef crawl(url): response = urlopen(url) time.sleep(0.1) # slightly delay for downloading return response.read().decode()def parse(html): soup = BeautifulSoup(html, &apos;lxml&apos;) urls = soup.find_all(&apos;a&apos;, &#123;&quot;href&quot;: re.compile(&apos;^/.+?/$&apos;)&#125;) title = soup.find(&apos;h1&apos;).get_text().strip() page_urls = set([urljoin(base_url, url[&apos;href&apos;]) for url in urls]) # remove duplication url = soup.find(&apos;meta&apos;, &#123;&apos;property&apos;: &quot;og:url&quot;&#125;)[&apos;content&apos;] return title, page_urls, urlif __name__ == &apos;__main__&apos;: base_url = &apos;https://morvanzhou.github.io/&apos; # base_url = &quot;http://127.0.0.1:4000/&quot; # DON&apos;T OVER CRAWL THE WEBSITE OR YOU MAY NEVER VISIT AGAIN if base_url != &quot;http://127.0.0.1:4000/&quot;: restricted_crawl = True else: restricted_crawl = False unseen = set([base_url,]) seen = set() pool = mp.Pool(4) # number strongly affected count, t1 = 1, time.time() while len(unseen) != 0: # still get some url to visit if restricted_crawl and len(seen) &gt; 20: break print(&apos;\nDistributed Crawling...&apos;) crawl_jobs = [pool.apply_async(crawl, args=(url,)) for url in unseen] htmls = [j.get() for j in crawl_jobs] # request connection htmls = [h for h in htmls if h is not None] # remove None print(&apos;\nDistributed Parsing...&apos;) parse_jobs = [pool.apply_async(parse, args=(html,)) for html in htmls] results = [j.get() for j in parse_jobs] # parse html print(&apos;\nAnalysing...&apos;) seen.update(unseen) unseen.clear() for title, page_urls, url in results: print(count, title, url) count += 1 unseen.update(page_urls - seen) print(&apos;Total time: %.1f s&apos; % (time.time()-t1, )) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import aiohttpimport asyncioimport timefrom bs4 import BeautifulSoupfrom urllib.request import urljoinimport reimport multiprocessing as mpbase_url = &quot;https://morvanzhou.github.io/&quot;# base_url = &quot;http://127.0.0.1:4000/&quot;# DON&apos;T OVER CRAWL THE WEBSITE OR YOU MAY NEVER VISIT AGAINif base_url != &quot;http://127.0.0.1:4000/&quot;: restricted_crawl = Trueelse: restricted_crawl = Falseseen = set()unseen = set([base_url])def parse(html): soup = BeautifulSoup(html, &apos;lxml&apos;) urls = soup.find_all(&apos;a&apos;, &#123;&quot;href&quot;: re.compile(&apos;^/.+?/$&apos;)&#125;) title = soup.find(&apos;h1&apos;).get_text().strip() page_urls = set([urljoin(base_url, url[&apos;href&apos;]) for url in urls]) url = soup.find(&apos;meta&apos;, &#123;&apos;property&apos;: &quot;og:url&quot;&#125;)[&apos;content&apos;] return title, page_urls, urlasync def crawl(url, session): r = await session.get(url) html = await r.text() await asyncio.sleep(0.1) # slightly delay for downloading return htmlasync def main(loop): pool = mp.Pool(2) # slightly affected async with aiohttp.ClientSession() as session: count = 1 while len(unseen) != 0: if restricted_crawl and len(seen) &gt; 20: break tasks = [loop.create_task(crawl(url, session)) for url in unseen] finished, unfinished = await asyncio.wait(tasks) htmls = [f.result() for f in finished] parse_jobs = [pool.apply_async(parse, args=(html,)) for html in htmls] results = [j.get() for j in parse_jobs] seen.update(unseen) unseen.clear() for title, page_urls, url in results: print(count, title, url) unseen.update(page_urls - seen) count += 1if __name__ == &quot;__main__&quot;: t1 = time.time() loop = asyncio.get_event_loop() loop.run_until_complete(main(loop)) loop.close() print(&quot;Async total time: &quot;, time.time() - t1)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux基础思维导图]]></title>
    <url>%2Flinux%E5%AD%A6%E4%B9%A0%2Flinux%E5%9F%BA%E7%A1%80%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬取百度百科词条写入数据库]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91%E8%AF%8D%E6%9D%A1%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[这是在把百度百科上从一个词条中，随机选择一个关键字，然后从这个关键词的词条中，继续这样一个步骤，同时保存到数据库。如果遇到某词条下没有其他关键字，就会返回到上一个关键字处，目前有一个问题，就是两条关键词都只有一个的话，会进入循环。数据库中可以设置url唯一数据库这一块的操作，得先安装pymysql。直接使用pip安装即可。随机数random是python自带的。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from bs4 import BeautifulSoupfrom urllib.request import urlopenimport reimport randomimport pymysql.cursors # 数据库base_url = &quot;https://baike.baidu.com&quot;his = [&quot;/item/%E5%8F%B2%E8%AE%B0&quot;]for i in range(1000): # dealing with Chinese symbols url = base_url + his[-1] html = urlopen(url).read().decode(&apos;utf-8&apos;) soup = BeautifulSoup(html, features=&apos;lxml&apos;) print(i, soup.find(&apos;h1&apos;).get_text(), &apos; url: &apos;, url) # find valid urls sub_urls = soup.find_all(&quot;a&quot;, &#123;&quot;target&quot;: &quot;_blank&quot;, &quot;href&quot;: re.compile(&quot;/item/(%.&#123;2&#125;)+$&quot;)&#125;) if len(sub_urls) != 0: his.append(random.sample(sub_urls, 1)[0][&apos;href&apos;]) else: # no valid sub link found his.pop()# 链接数据库 connection = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, password = &apos;password&apos;, db = &apos;baikeurl&apos;, charset = &apos;utf8mb4&apos;, ) try: # 获取会话指针 with connection.cursor() as cursor: # 创建sql 语句 sql = &apos;insert into `urls`(`urlname`,`urlhref`)values(%s,%s)&apos; # 执行sql 语句 cursor.execute(sql,(soup.find(&apos;h1&apos;).get_text(),url)) # 提交 connection.commit() except: pass finally: connection.close() 读取数据库12345678910111213141516171819202122import pymysql.cursorsconnection = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, password = &apos;password&apos;, db = &apos;baikeurl&apos;, charset = &apos;utf8mb4&apos;, )try: # 获取会话指针 with connection.cursor() as cursor: # 查询sql 语句 sql = &apos;select `urlname` , `urlhref` from `urls` where `id` is not null&apos; # 执行sql 语句 conut = cursor.execute(sql) print(conut) # result = cursor.fetchall() # print(result)finally: connection.close()]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读取TXT_PDF]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E8%AF%BB%E5%8F%96TXT_PDF%2F</url>
    <content type="text"><![CDATA[这个是我学习爬取TXT和PDF的代码，前半段是读取TXT，后半段是读取PDF，PDF中使用了第三方库，pdfminer3k,使用pip安装即可。pip install pdfminer3k。PDF其中注释掉的为读取网络上的PDF文档。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from urllib import requestfrom pdfminer.pdfdevice import PDFDevicefrom pdfminer.pdfinterp import PDFPageInterpreter, PDFResourceManagerfrom pdfminer.pdfparser import PDFDocument, PDFParserfrom pdfminer.converter import PDFPageAggregatorfrom pdfminer.layout import LAParams# html = request.urlopen(# &apos;https://en.wikipedia.org/robots.txt&apos;# ).read().decode(&apos;utf-8&apos;)# print(html) # 读取txt# fp = open(&apos;./practice/byte-of-python-chinese-edition.pdf&apos;,&apos;rb&apos;) # 获取文档对象fp = request.urlopen(&apos;https://q.stock.sohu.com/newpdf/201831703172.pdf&apos;) # 读取网络pdfparser = PDFParser(fp) # 创建一个与文档关联的解释器doc = PDFDocument() # 文档对象# 链接解释器和文档对象parser.set_document(doc)doc.set_parser(parser)# 初始化文档doc.initialize() # 可接收文档密码resource = PDFResourceManager() # 创建PDF资源管理器laparam = LAParams() # 参数分析器device = PDFPageAggregator(resource,laparams=laparam)# 创建一个聚合器interpreter = PDFPageInterpreter(resource,device)# 创建 PDF页面解释器# 使用文档对象得到页面的集合for page in doc.get_pages(): # 使用页面解释器来读取 interpreter.process_page(page) # 使用聚合器来获取内容 layout = device.get_result() for out in layout: if hasattr(out,&apos;get_text&apos;): # 有没有这个属性 print(out.get_text())]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬虫整理（五）slenium]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E7%88%AC%E8%99%AB%E6%95%B4%E7%90%86-(%E4%BA%94)--slenium%2F</url>
    <content type="text"><![CDATA[首先使用pip安装并加入环境变量123456789101112131415161718192021222324from selenium import webdriverfrom selenium.webdriver.chrome.options import Options# firefox plugin# https://askubuntu.com/questions/870530/how-to-install-geckodriver-in-ubuntu# hide browser windowchrome_options = Options()chrome_options.add_argument(&quot;--headless&quot;) # define headless# add the option when creating driverdriver = webdriver.Chrome(chrome_options=chrome_options)driver.get(&quot;https://morvanzhou.github.io/&quot;)driver.find_element_by_xpath(u&quot;//img[@alt=&apos;强化学习 (Reinforcement Learning)&apos;]&quot;).click()driver.find_element_by_link_text(&quot;About&quot;).click()driver.find_element_by_link_text(u&quot;赞助&quot;).click()driver.find_element_by_link_text(u&quot;教程 ▾&quot;).click()driver.find_element_by_link_text(u&quot;数据处理 ▾&quot;).click()driver.find_element_by_link_text(u&quot;网页爬虫&quot;).click()print(driver.page_source[:200])driver.get_screenshot_as_file(&quot;./img/sreenshot2.png&quot;)driver.close()print(&apos;finish&apos;)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PandaTV爬取主播人气并排序]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2FPandaTV%E7%88%AC%E5%8F%96%E4%B8%BB%E6%92%AD%E4%BA%BA%E6%B0%94%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[很早前，第一次爬虫，就用的re加urllib原生爬虫。这次重新来爬取一次PandaTV主播人气排名，来练一下手。毕竟看直播嘛，颜值区更喜欢一点。就以颜值区为例，颜值区url = ‘https://www.panda.tv/cate/yzdr&#39;。结果保存在运行目录下的`PandaTV主播人气排名.md`中。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import refrom urllib import requestimport osimport datetime class Spider(): url = &apos;https://www.panda.tv/all&apos; root_pattern =&apos;&lt;div class=&quot;video-info&quot;&gt;[\s\S]*?&lt;/div&gt;&apos; # 因为number和name均在其下 name_pattern = &apos;&lt;span class=&quot;video-nickname&quot; title=&quot;([\s\S]*?)&quot;&gt;\n&apos; number_pattern = &apos;&lt;span class=&quot;video-number&quot;&gt;&lt;i class=&quot;ricon ricon-eye&quot;&gt;&lt;/i&gt;([\s\S]*?)&lt;/span&gt;\n&apos; # 获取htmls数据 def __fetch_content(self): r = request.Request(Spider.url) r.add_header(&apos;User-Agent&apos;,&apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/18.17758&apos;) r = request.urlopen(r) # 打开网页 request 下面的urlopen方法 htmls = r.read() # 读取 htmls = str(htmls, encoding=&apos;utf-8&apos;) # 转为str return htmls # 建立一个list为: [&#123;&apos;name&apos;:name,&apos;number&apos;: number&#125;,&#123;&apos;name&apos;:name,&apos;number&apos;: number&#125;,...] def __analysis(self, htmls): root_html = re.findall(Spider.root_pattern, htmls) # 抓取所有的&lt;div class=&quot;video-info&quot;&gt;[\s\S]*?&lt;/div&gt; anchors = [] for html in root_html: # 将&lt;div class=&quot;video-info&quot;&gt;[\s\S]*?&lt;/div&gt;一个一个提取出来 name = re.findall(Spider.name_pattern, html) # 将一个的name提取出来 ，格式为[str] number = re.findall(Spider.number_pattern, html) # 将一个的number提取出来,格式为[str] anchor = &#123;&apos;name&apos;: name, &apos;number&apos;: number&#125; # 将name 和 number 对应起来，组成一个字典 anchors.append(anchor) # 将这个字典添加到 anchors列表中 return anchors # def __refine(self, anchors): l = lambda anchors: &#123; &apos;name&apos;: anchors[&apos;name&apos;][0], #strip() 内置函数，去掉空格 &apos;number&apos;: anchors[&apos;number&apos;][0] # 取出字符串 &#125; return map(l, anchors) #&#123;[&apos;name&apos;:&apos;xxx&apos;,&apos;number&apos;:&apos;yyy&apos;]&#125;,&#123;[&apos;name&apos;:&apos;xxx1&apos;,&apos;number&apos;:&apos;yyy1&apos;]&#125;... def __sort(self, anchors): #排序 anchors = sorted(anchors, key=self.__sort_seed, reverse=True) #reverse=True表示降序 return anchors #anchor[&apos;number&apos;]中的转为float格式，按转化后的数字大小进行排序 def __sort_seed(self, anchor): # 排序调用的方法 r = anchor[&apos;number&apos;] if &apos;万&apos; in r: r = r.strip(&apos;万&apos;) r = float(r) r *= 10000 number = float(r) return number def __show(self, anchors): # 显示格式 time_stamp = datetime.datetime.now() b = str(time_stamp.strftime(&apos;%Y.%m.%d - %H:%M:%S&apos;) ) with open(&apos;./PandaTV主播人气排名.md&apos;, &apos;a&apos;) as f: f.write(&apos;\n\n&apos;) f.write(b) f.write(&apos;\n\n&apos;) for rank in range(0, len(anchors)): a = str((&apos;rank &apos; + str(rank + 1) + &apos; &apos; #加排名，因为是从0开始 &apos;主播姓名&apos; + &apos;:&apos; + anchors[rank][&apos;name&apos;] + &apos; &apos; + &apos;观看人数:&apos;+anchors[rank][&apos;number&apos;])) with open(&apos;./PandaTV主播人气排名.md&apos;, &apos;a&apos;) as f: f.write(a) f.write(&apos;\n&apos;) def go(self): #主方法 htmls = self.__fetch_content() anchors = self.__analysis(htmls) anchors = list(self.__refine(anchors)) anchors = self.__sort(anchors) self.__show(anchors) spider = Spider()spider.go() 附带本次成果]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[慕课网数据采集总结]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E6%85%95%E8%AF%BE%E7%BD%91%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/video/12637 课程地址]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬虫整理（一）使用re和urllib]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E7%88%AC%E8%99%AB%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E4%BD%BF%E7%94%A8re%E5%92%8Curllib%2F</url>
    <content type="text"><![CDATA[完整代码123456789101112131415161718192021from urllib.request import urlopenhtml = urlopen( &quot;https://morvanzhou.github.io/static/scraping/basic-structure.html&quot;).read( ).decode(&apos;utf-8&apos;)print(html)import reres = re.findall(r&quot;&lt;title&gt;(.+?)&lt;/title&gt;&quot;, html)print(&quot;\nPage title is: &quot;, res[0])res = re.findall(r&quot;&lt;p&gt;(.*?)&lt;/p&gt;&quot;, html, flags=re.DOTALL) print(&quot;\nPage paragraph is: &quot;, res[0])res = re.findall(r&apos;href=&quot;(.*?)&quot;&apos;, html)print(&quot;\nAll links: &quot;, res) 正文使用re和urllib123456from urllib.request import urlopen# if has Chinese, apply decode()html = urlopen( &quot;https://morvanzhou.github.io/static/scraping/basic-structure.html&quot;).read().decode(&apos;utf-8&apos;) print(html) # 打开，读取，转换可显示中文，最后打印出来 结果显示 接下来，使用re筛选数据1234567891011import reres = re.findall(r&quot;&lt;title&gt;(.+?)&lt;/title&gt;&quot;, html) print(res) # [&apos;Scraping tutorial 1 | 莫烦Python&apos;] # 列表print(res[0]) # Scraping tutorial 1 | 莫烦Pythonres = re.findall(r&quot;&lt;p&gt;(.*?)&lt;/p&gt;&quot;, html)print(res) # []res = re.findall(r&quot;&lt;p&gt;(.*?)&lt;/p&gt;&quot;, html, flags=re.DOTALL) # re.DOTALL if multi lineprnt(res)print(res[0]) 12res = re.findall(r&apos;href=&quot;(.*?)&quot;&apos;, html)print(&quot;\nAll links: &quot;, res)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬虫整理（二）BeautifulSoup]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E7%88%AC%E8%99%AB%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89BeautifulSoup%2F</url>
    <content type="text"><![CDATA[BeautifulSoup 解析：基础本段完整代码 具体安装过程可自行搜索。beautifulSoup使用过程 选择要爬的网址 (url) 使用 python 打开这个网址 (urlopen等) 读取网页信息 (read() 出来) 将读取的信息放入 BeautifulSoup 使用 BeautifulSoup 选取 tag 信息等 (代替正则表达式)123456from urllib.request import urlopen# if has Chinese, apply decode()html = urlopen(&quot;https://morvanzhou.github.io/static/scraping/basic-structure.html&quot;).read().decode(&apos;utf-8&apos;) 使用BeautifulSoup筛选数据1234from bs4 import BeautifulSoupsoup = BeautifulSoup(html, features=&apos;lxml&apos;) #以 lxml 的这种形式加载print(soup) 12345678print(soup.h1) # 输出&lt;h1&gt; 标题print(soup.p) # 输出&lt;p&gt; 标题all_href = soup.find_all(&apos;a&apos;)print(&apos;\n&apos;,all_href)all_href = [l[&apos;href&apos;] for l in all_href] #像 Python 字典的形式, 用 key 来读取 l[&quot;href&quot;]print(&apos;\n&apos;, all_href) BeautifulSoup 解析网页:CSS本节代码 12345678910111213141516171819202122232425from bs4 import BeautifulSoupfrom urllib.request import urlopen# if has Chinese, apply decode()html = urlopen(&quot;https://morvanzhou.github.io/static/scraping/list.html&quot;).read().decode(&apos;utf-8&apos;)soup = BeautifulSoup(html, features=&apos;lxml&apos;)# use class to narrow searchmonth = soup.find_all(&apos;li&apos;, &#123;&quot;class&quot;: &quot;month&quot;&#125;)print(month)#要找所有 class=month 的信息. 并打印出它们的 tag 内文字for m in month: print(m.get_text()) # 打印tag中的文字jan = soup.find(&apos;ul&apos;, &#123;&quot;class&quot;: &apos;jan&apos;&#125;)print(&apos;\n&apos;,jan)d_jan = jan.find_all(&apos;li&apos;) # use jan as a parentprint(&apos;\n&apos;,d_jan)for d in d_jan: print(&apos;\n&apos;,d.get_text()) BeautifulSoup 解析网页正则表达式本节代码12345678910111213141516html = urlopen(&quot;https://morvanzhou.github.io/static/scraping/table.html&quot;).read().decode(&apos;utf-8&apos;)print(html)soup = BeautifulSoup(html, features=&apos;lxml&apos;)img_links = soup.find_all(&quot;img&quot;, &#123;&quot;src&quot;: re.compile(&apos;.*?\.jpg&apos;)&#125;)for link in img_links: print(link[&apos;src&apos;])print(&apos;\n&apos;)course_links = soup.find_all(&apos;a&apos;, &#123;&apos;href&apos;: re.compile(&apos;https://morvan.*&apos;)&#125;)for link in course_links: print(link[&apos;href&apos;]) 我们发现, 如果是图片, 它们都藏在这样一个 tag 中:123&lt;td&gt; &lt;img src=&quot;https://morvanzhou.github.io/static/img/course_cover/tf.jpg&quot;&gt;&lt;/td&gt; 用 soup 将这些 tag 全部找出来, 但是每一个 img 的链接(src)都可能不同，可能是 jpg 有的是 png, 只挑选 jpg 形式的图片, 用这样一个正则 r’.*?.jpg’ 来选取. 把正则的 compile 形式放到 BeautifulSoup 的功能中, 就能选到符合要求的图片链接了.想要的链接都有统一的形式, 就是开头都会有 https://morvan., 定一个正则, 让 BeautifulSoup 找到符合规则的链接. 一个小练习来熟悉1234567891011121314151617181920212223242526from bs4 import BeautifulSoupfrom urllib.request import urlopenimport reimport randombase_url = &quot;https://baike.baidu.com&quot;his = [&quot;/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/5162711&quot;]for i in range(20): # dealing with Chinese symbols url = base_url + his[-1] html = urlopen(url).read().decode(&apos;utf-8&apos;) soup = BeautifulSoup(html, features=&apos;lxml&apos;) print(i, soup.find(&apos;h1&apos;).get_text(), &apos; url: &apos;, url) # find valid urls sub_urls = soup.find_all( &quot;a&quot;, &#123;&quot;target&quot;: &quot;_blank&quot;, &quot;href&quot;: re.compile(&quot;/item/(%.&#123;2&#125;)+$&quot;)&#125;) if len(sub_urls) != 0: his.append(random.sample(sub_urls, 1)[0][&apos;href&apos;]) else: # no valid sub link found his.pop()]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬虫整理（三）Requests]]></title>
    <url>%2Fpython%E7%BB%83%E4%B9%A0%2F%E7%88%AC%E8%99%AB%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89Requests%2F</url>
    <content type="text"><![CDATA[Requests 是一个 Python 的外部模块, 需要手动安装. 使用 pip 安装就好了. 1234567import requestsimport webbrowser # 使用浏览器打开param = &#123;&quot;wd&quot;: &quot;itswl.github&quot;&#125; # 搜索的信息r = requests.get(&apos;https://www.baidu.com/s&apos;, params=param)print(r.url) # 用get 方式webbrowser.open(r.url)# https://www.baidu.com/s?wd=itswl.github 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import requestsimport webbrowser # 使用浏览器打开param = &#123;&quot;wd&quot;: &quot;itswl.github&quot;&#125; # 搜索的信息r = requests.get(&apos;http://www.baidu.com/s&apos;, params=param)print(r.url) # 用get 方式webbrowser.open(r.url)def get(): print(&apos;\nget&apos;) param = &#123;&quot;wd&quot;: &quot;itswl.github&quot;&#125; r = requests.get(&apos;https://www.baidu.com/s&apos;, params=param) print(r.url) print(r.text)# get()def post_name(): print(&apos;\npost name&apos;) # http://pythonscraping.com/pages/files/form.html data = &#123;&apos;firstname&apos;: &apos;laii&apos;, &apos;lastname&apos;: &apos;weii&apos;&#125; r = requests.post(&apos;http://pythonscraping.com/files/processing.php&apos;, data=data) print(r.text)post_name()def post_image(): print(&apos;\npost image&apos;) # http://pythonscraping.com/files/form2.html file = &#123;&apos;uploadFile&apos;: open(&apos;./image.png&apos;, &apos;rb&apos;)&#125; r = requests.post(&apos;http://pythonscraping.com/files/processing2.php&apos;, files=file) print(r.text)def post_login(): print(&apos;\npost login&apos;) # http://pythonscraping.com/pages/cookies/login.html payload = &#123;&apos;username&apos;: &apos;Morvan&apos;, &apos;password&apos;: &apos;password&apos;&#125; r = requests.post(&apos;http://pythonscraping.com/pages/cookies/welcome.php&apos;, data=payload) print(r.cookies.get_dict()) # http://pythonscraping.com/pages/cookies/profile.php r = requests.get(&apos;http://pythonscraping.com/pages/cookies/profile.php&apos;, cookies=r.cookies) print(r.text)def session_login(): # 使用cookie print(&apos;\nsession login&apos;) # http://pythonscraping.com/pages/cookies/login.html session = requests.Session() payload = &#123;&apos;username&apos;: &apos;Morvan&apos;, &apos;password&apos;: &apos;password&apos;&#125; r = session.post(&apos;http://pythonscraping.com/pages/cookies/welcome.php&apos;, data=payload) print(r.cookies.get_dict()) r = session.get(&quot;http://pythonscraping.com/pages/cookies/profile.php&quot;) print(r.text)post_name()post_image()post_login()session_login() 下载文件123456789101112131415161718192021222324252627282930313233import osos.makedirs(&apos;./img/&apos;, exist_ok=True)IMAGE_URL = &quot;https://morvanzhou.github.io/static/img/description/learning_step_flowchart.png&quot;def urllib_download(): from urllib.request import urlretrieve urlretrieve(IMAGE_URL, &apos;./img/image1.png&apos;) # whole documentdef request_download(): import requests r = requests.get(IMAGE_URL) with open(&apos;./img/image2.png&apos;, &apos;wb&apos;) as f: f.write(r.content) # whole documentdef chunk_download(): import requests r = requests.get(IMAGE_URL, stream=True) # stream loading with open(&apos;./img/image3.png&apos;, &apos;wb&apos;) as f: for chunk in r.iter_content(chunk_size=32): f.write(chunk)urllib_download()print(&apos;download image1&apos;)request_download()print(&apos;download image2&apos;)chunk_download()print(&apos;download image3&apos;) 一个小练习，抓取美女吧图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# coding=utf-8import requestsfrom lxml import etreeimport osimport reclass TieBa(object): &quot;&quot;&quot;抓取百度贴吧美女图片&quot;&quot;&quot; def __init__(self, word): self.url = &apos;https://tieba.baidu.com/f?kw=&#123;&#125;&apos;.format(word) # word 美女 self.headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0; TUCOWS) &apos; &#125; def get_data(self, url): # 构造请求 response = requests.get(url, headers=self.headers) data = response.content # print(data) return data def parse_page(self, data): &quot;&quot;&quot;解析数据&quot;&quot;&quot; # 创建xpath对象 html = etree.HTML(data) # 提取当前页标题，url数据 node_list = html.xpath(&apos;//*[@id=&quot;thread_list&quot;]/li/div/div[2]/div[1]/div[1]/a&apos;) detail_list = [] for node in node_list: temp = dict() temp[&apos;title&apos;] = node.xpath(&apos;./text()&apos;)[0] temp[&apos;url&apos;] = &apos;https://tieba.baidu.com&apos; + node.xpath(&apos;./@href&apos;)[0] detail_list.append(temp) # print(temp) # 提取下一页连接 next_url = html.xpath(&apos;//*[@id=&quot;frs_list_pager&quot;]/a[contains(text(), &quot;下一页&quot;)]/@href&apos;)[0] next_url = &apos;http:&apos; + next_url if len(next_url) &gt; 0 else None # print(next_url) return detail_list, next_url def parse_detail(self, detail_list): &quot;&quot;&quot;提取详情页url&quot;&quot;&quot; data_url = [] for detail in detail_list: data_url.append(detail[&apos;url&apos;]) return data_url def save_data(self, url): &quot;&quot;&quot;保存数据&quot;&quot;&quot; # 请求标题连接地址 data = self.get_data(url) # 创建xpath对象 html = etree.HTML(data) # print(html) # print(url) # 获取图片url try: image_url = html.xpath(&apos;//*[contains(@id,&quot;post_content&quot;)]/img[1]/@src&apos;)[0] except Exception as e: return print(image_url) # 判断图片地址是否已jpg结尾 if re.match(r&apos;.*\.jpg$&apos;, image_url): # 请求图片地址，获取图片 image_data = self.get_data(image_url) filename = &apos;image/&apos; + image_url.split(&apos;/&apos;)[-1] # print(filename) # 保存图片 with open(filename, &apos;wb&apos;) as f: f.write(image_data) def run(self): # 判断是否有image文件夹 if not os.path.exists(&apos;image&apos;): # 创建文件夹 os.mkdir(&apos;image&apos;) next_url = self.url # 请求美女吧首页 data = self.get_data(next_url) # 保存首页文件，观察数据，是否有需要的数据 with open(&apos;tieba.json&apos;, &apos;wb&apos;) as f: f.write(data) # 如果有下一页就执行 while next_url: # 获取每页标题和对应的连接地址 detail_list, next_url = self.parse_page(data) # 提取每页的详情页的url data_url = self.parse_detail(detail_list) # 遍历每个url for url in data_url: # 保存图片 self.save_data(url) # 构造下一页请求 data = self.get_data(next_url)if __name__ == &apos;__main__&apos;: tb = TieBa(&apos;美女&apos;) tb.run()]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask构建可扩展的RESTful-API-1--起步与红图]]></title>
    <url>%2Fflask-api%2FFlask%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84RESTful-API-1--%E8%B5%B7%E6%AD%A5%E4%B8%8E%E7%BA%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言flask VS Django可以理解为安装各种插件的 flask = Django 1.1 初始化项目1.一个项目的初始化流程如下： 2.新建入口文件app/init.py12345678910from flask import Flaskdef create_app(): app = Flask(__name__) # 实例化flask核心对象 app.config.from_object(&apos;app.config.secure&apos;) # 读取配置文件下的secure app.config.from_object(&apos;app.config.setting&apos;) # 读取配置文件下的setting register_blueprints(app) # 注册蓝图到核心对象上 return app ginger.py12345678from app import create_appapp = create_app()if __name__ == &apos;__main__&apos;: app.run(debug=True) 1.2 红图1.蓝图拆分视图函数的缺陷的缺陷1.蓝图的作用并不是用来拆分视图函数的，而是用来拆分模块的 2.使用蓝图，统一个业务模型的试图函数的前缀都一样，代码重复啰嗦 2.打开思维，创建自己的redprint-红图为了解决上面的两个问题，我们可以模仿蓝图，构建一个自定义的对象-红图，红图的定位是用来拆分视图，也就是视图函数层 我们采用自顶向下的编程思想，先编写redprint在试图函数中的使用代码，再编写redprint具体的实现 2.1 视图函数向红图的注册app/api/v1/book.py123456789101112from app.libs.redprint import Redprintapi = Redprint(&apos;book&apos;) # 实例化一个Redprint@api.route(&apos;/get&apos;) # 使用Redprint 来注册视图函数def get_book(): return &apos;get_book&apos;@api.route(&apos;/create&apos;)def create_book(): return &apos;create_book&apos; app/api/v1/user.py1234567891011121314151617181920# 使用Blueprint注册视图函数# from flask import Blueprint# user = Blueprint(&apos;user&apos;,__name__)# @user.route(&apos;/v1/user/get&apos;)# def get_user():# return &apos;imwl&apos;from app.libs.redprint import Redprintapi = Redprint(&apos;user&apos;)@api.route(&apos;/get&apos;)def get_user(): return &apos;get_user&apos;@api.route(&apos;/create&apos;)def create_user(): return &apos;create_user&apos; 2.2 红图向蓝图的注册app/api/init.py123456789101112131415161718192021222324from flask import Blueprintfrom app.api.v1 import user, book # 创建一个Bluerint,把Redprint注册到Blueprint上，并传入Redprint一个前缀&apos;/bookdef create_blueprint_v1(): bp_v1 = Blueprint(&apos;v1&apos;, __name__) # 假设api有register的方法，后面再实现, url_prefix解决前缀问题 # book.api.register(bp_v1, url_prefix=&apos;/book&apos;) # user.api.register(bp_v1, url_prefix=&apos;/user&apos;) # 后文 有解释为什么不传 url_prefix user.api.register(bp_v1) book.api.register(bp_v1) return bp_v1from flask import Blueprintfrom app.api.v1 import book, userdef create_blueprint_v1(): bp_v1 = Blueprint(&apos;v1&apos;, __name__) book.api.register(bp_v1, url_prefix=&apos;/book&apos;) user.api.register(bp_v1, url_prefix=&apos;/user&apos;) return bp_v1 2.3 蓝图向Flask核心对象的注册app/app.py1234567891011121314151617181920from flask import Flask# 将Blueprint注册到flask核心对象上,并传入一个前缀&apos;/v1&apos;def register_blueprints(app): # from app.api.v1.user import user #（这些是没改造前，用blueprint的注册方式） # from app.api.v1.book import book # app.register_blueprint(user) # app.register_blueprint(book) from app.api.v1 import create_blueprint_v1 app.register_blueprint(create_blueprint_v1(), url_prefix = &apos;/v1&apos;)def create_app(): app = Flask(__name__) # 实例化flask核心对象 app.config.from_object(&apos;app.config.secure&apos;) # 读取配置文件下的secure ,app/config/secure.py app.config.from_object(&apos;app.config.setting&apos;) # 读取配置文件下的setting, app/config/setting.py register_blueprints(app) # 注册蓝图到核心对象上 return app 3.实现Redprint因为我们的红图的作用就是要代替蓝图来实现试图函数的拆分，所以功能实现上可以参考蓝图的实现。 3.1 装饰性route的实现蓝图的实现1234567891011def route(self, rule, **options):&quot;&quot;&quot;Like :meth:`Flask.route` but for a blueprint. The endpoint for the:func:`url_for` function is prefixed with the name of the blueprint.&quot;&quot;&quot;def decorator(f):# 获取endpoint，默认为试图函数名endpoint = options.pop(&quot;endpoint&quot;, f.__name__)# 注册视图函数self.add_url_rule(rule, endpoint, f, **options)return freturn decorator 红图的实现可以模仿蓝图的实现结构 ，由于红图的route里没有办法拿到蓝图的对象，所以我们可以先把他们存储起来，等碰到的时候再进行注册12345678910class Redprint: def __init__(self,name): self.name = name self.mound = [] def route(self, rule, **options): def decorator(f): self.mound.append((f, rule, options)) return f return decorator 3.2 register方法在register方法中可以获取到蓝图对象，所以之前route中视图函数的注册延迟到这里进行1234567891011121314151617181920212223242526# 红图的实现可以模仿蓝图的实现结构 ，# 由于红图的route里没有办法拿到蓝图的对象，# 所以我们可以先把他们存储起来，等碰到的时候再进行注册class Redprint: def __init__(self,name): self.name = name self.mound = [] def route(self, rule, **options): def decorator(f): self.mound.append((f, rule, options)) return f return decorator # 在register方法中可以获取到蓝图对象， # 所以之前route中视图函数的注册延迟到这里进行 def register(self, bp, url_prefix = None): # 如果不传url_prefix 则默认使用name if url_prefix is None: url_prefix = &apos;/&apos;+self.name # 定义 Redprint 前缀 # python的自动拆包 for f, rule, options in self.mound: endpoint = options.pop(&quot;endpoint&quot;, f.__name__) # 将视图函数注册到蓝图上来 bp.add_url_rule(url_prefix + rule, endpoint, f, **options) 流程梳理 模仿Blueprint自定义Redprint app/api/v1/book.py中实例化一个Redprint 来注册视图函数。 app/api/v1/init.py 中创建一个Bluerint,把Redprint注册到Blueprint上，并传入Redprint一个前缀,如: ‘/book’ 在app/init.py 中 将Blueprint注册到flask核心对象上,并传入一个前缀，如： ‘/v1’]]></content>
      <categories>
        <category>flask-api</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask构建可扩展的RESTful-API-2--REST基本特征]]></title>
    <url>%2Fflask-api%2FFlask%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84RESTful-API-2--REST%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[2. REST基本特征1.REST的最基本特征我们把服务器提供的服务统一称为资源。 我们可以使用URL来定位资源，如/v1/book/user/1 来定位一个用户 定位到资源以后，可以使用HTPP动词来操作资源，类似使用DDL操作数据库。 对于视图函数的URL，尽量不应该包含动词，因为URL是用来定位资源的，例如我们之前的试图函数，应该这样改写12345678910111213141516171819202122232425262728# from flask import Blueprint# user = Blueprint(&apos;user&apos;,__name__)# @user.route(&apos;/v1/user/get&apos;)# def get_user():# return &apos;imwl&apos;from app.libs.redprint import Redprintapi = Redprint(&apos;user&apos;)#@api.route(&apos;/get&apos;) URL中不应该包含动词@api.route(&apos;&apos;,methods = [&apos;GET&apos;])def get_user(): return &apos;get_user&apos;@api.route(&apos;&apos;,methods = [&apos;PUT&apos;])def update_user(): return &apos;update_user&apos;@api.route(&apos;&apos;,methods = [&apos;DELETE&apos;])def delete_user(): return &apos;deletete_user&apos;@api.route(&apos;&apos;,methods = [&apos;POST&apos;])def create_user(): return &apos;create_user&apos; 2.为什么标准的REST不适合内部开发REST的使用场景有两个：内部开发API，开放API。 标准的REST比较适合开放性的API。只负责提供数据，不负责业务逻辑 由于内部的开发，业务逻辑非常复杂，想用简单的四个接口来标示所有的业务逻辑，基本上是不可能的 REST的接口粒度比较粗（返回的资源属性比较多；服务器不会负责处理数据），这样前端的开发是不太方便的 标准的REST会造成HTTP请求的数量大幅度的增加 3.建议 尽量遵从REST的设计风格规范 要灵活一些，如果前端要考虑业务逻辑的话，我们就不要遵从资源的限制了，应该让API具有业务逻辑的性质 如果前端需要几个资源合并在一起的数据，那么我们就为前端定制一个合并数据的接口]]></content>
      <categories>
        <category>flask-api</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask构建可扩展的RESTful-API-3--自定义异常对象]]></title>
    <url>%2Fflask-api%2FFlask%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84RESTful-API-3--%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[3.1 关于用户的思考 不管是网站也好，还是API也好，我们都逃脱不了用户这个概念，我们下面就要来讨论用户的相关操作 对于用户而言，第一件事情，我们就要完成用户注册的操作，说到注册用户，我们想到，可以在视图函数文件中增加一个注册用户的视图函数–create_user，并且我们会在其中接受账号和密码，来完成用户的注册，这个逻辑是通常意义上的用户的概念。 普通用户：使用鱼书的人相对于鱼书来说，就是用户；我们相对于QQ和微信，也是他的用户。 但是我们在做API的时候，不能只考虑这些普通意义的用户，我们还要考虑一些特别的用户。例如：我们开发了一个向外提供数据的API，加入有一天，有一个公司，想使用我们的API开发他们自己的产品（小程序或者APP），这些其他的客户端，都是我们API的用户 根据以上的分析，我们可以得出几个结论：对于API而言，再叫做用户就不太合适 ，我们更倾向于把人，第三方的产品等同于成为客户端（client）来代替User。客户端的种类非常多，注册的形式就非常多。如对于普通的用户而言，就是账号和密码，但是账号和密码又可以分成，短信，邮件，社交用户。对于多种的注册形式，也不是所有的都需要密码，如小程序就不需要。API和普通的业务系统是不一样的，他具有开发性和通用性。因为注册的形式就非常多，所以我们不可能用万能的方式来解决。如果我们不能很好的处理多种多样的形式，我们的代码就会非常的杂乱 3.2 注册client对于登录/注册这些比较重要的接口，我们建议提供一个统一的调用接口，而不应该拆分成多个。 我们可以编写一个枚举类，来枚举所有的客户端类型。app\libs\enums.py1234567891011from enum import Enum# 定义一个枚举class ClientTypeEnum(Enum): USER_EMAIL = 100 USER_MOBILE = 101 # 微信小程序 USER_MINA = 200 #微信公众号 UESR_WX = 201 1.构建client验证器app\validators\forms.py123456789101112131415161718from wtforms import Form, StringField, IntegerField # 字符串类型,数字类型from wtforms.validators import DataRequired, lengthfrom app.libs.enums import ClientTypeEnum# 构建client验证器class ClientForm(Form): account = StringField(validators=[DataRequired(), length(min=1, max=32)]) secret = StringField() # 由于客户端类型的不同，密码不一定要传入 type = IntegerField(validators=[DataRequired()]) # 验证client_type def validate_type(self, value): try: # 将用户传来的参数去枚举类中匹配，如果匹配失败，则抛出异常 # 如果匹配成功则将int转换成枚举 client = ClientTypeEnum(value.data) # value.data 取到值 except ValueError as e: raise e 2.处理不同客户端注册的方案由于python没有switch-case，我们可以使用dict来替换app\api\v1\client.py1234567891011121314151617181920212223242526272829303132from app.libs.redprint import Redprintfrom app.validators.forms import ClientFormfrom flask import requestfrom app.libs.enums import ClientTypeEnumapi = Redprint(&apos;client&apos;) # 实例化一个Redprint@api.route(&apos;/register&apos;, methods = [&apos;PSOT&apos;] ) # 路由注册def create_client(): # 表单 - 一般网页 json - 一般移动端 # 注册 登录 # 参数 校验 接收参数 # WTForms 验证表单#用来接收json类型的参数 data = request.json# 关键字参数data是wtform中用来接收json参数的方法 form = ClientForm(data=data) if form.validate():# 替代switchcase-&#123;Enum_name:handle_func&#125; promise = &#123; ClientTypeEnum.USER_EMAIL: __register_user_by_email#, # ClientTypeEnum.USER_MINA: __register_user_by_MINA # 可在此处构建多种枚举类型 &#125;def __register_user_by_email(): pass# def __register_user_by_MINA():# pass 3.用户模型的设计app\models\base.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from datetime import datetimefrom flask_sqlalchemy import SQLAlchemy as _SQLAlchemy, BaseQueryfrom sqlalchemy import Column, Integer, SmallIntegerfrom contextlib import contextmanagerclass SQLAlchemy(_SQLAlchemy): @contextmanager def auto_commit(self): try: yield self.session.commit() except Exception as e: db.session.rollback() raise eclass Query(BaseQuery): def filter_by(self, **kwargs): if &apos;status&apos; not in kwargs.keys(): kwargs[&apos;status&apos;] = 1 return super(Query, self).filter_by(**kwargs)db = SQLAlchemy(query_class=Query)class Base(db.Model): __abstract__ = True create_time = Column(Integer) status = Column(SmallInteger, default=1) def __init__(self): self.create_time = int(datetime.now().timestamp()) @property def create_datetime(self): if self.create_time: return datetime.fromtimestamp(self.create_time) else: return None def set_attrs(self, attrs_dict): for key, value in attrs_dict.items(): if hasattr(self, key) and key != &apos;id&apos;: setattr(self, key, value) def delete(self): self.status = 0 app\models\user.py 12345678910111213141516171819202122232425from sqlalchemy import inspect, Column, Integer, String, SmallInteger, ormfrom werkzeug.security import generate_password_hash, check_password_hash# from app.libs.error_code import NotFound, AuthFailedfrom app.models.base import Baseimport datetimeclass User(Base): id = Column(Integer, primary_key=True) email = Column(String(24), unique=True, nullable=False) nickname = Column(String(24), unique=True) auth = Column(SmallInteger, default=1) # 做层级的标志 _password = Column(&apos;password&apos;, String(100)) def keys(self): return [&apos;id&apos;, &apos;email&apos;, &apos;nickname&apos;, &apos;auth&apos;] @property def password(self): return self._password # 对密码的处理 @password.setter def password(self, raw): self._password = generate_password_hash(raw) # 对密码的处理 添加一个注册的方法1234567891011121314151617181920212223242526272829303132333435from sqlalchemy import inspect, Column, Integer, String, SmallInteger, ormfrom werkzeug.security import generate_password_hash, check_password_hash# from app.libs.error_code import NotFound, AuthFailedfrom app.models.base import Base , dbimport datetimeclass User(Base): id = Column(Integer, primary_key=True) email = Column(String(24), unique=True, nullable=False) nickname = Column(String(24), unique=True) auth = Column(SmallInteger, default=1) # 做层级的标志 _password = Column(&apos;password&apos;, String(100)) def keys(self): return [&apos;id&apos;, &apos;email&apos;, &apos;nickname&apos;, &apos;auth&apos;] @property def password(self): return self._password # 对密码的处理 @password.setter def password(self, raw): self._password = generate_password_hash(raw) # 对密码的处理 @staticmethod def register_by_email(nickname, account, secret): with db.auto_commit(): user = User() user.nickname = nickname user.email = account user.password = secret db.session.add(user) 插件的注册app__init__.py1234567891011121314151617181920212223242526272829from flask import Flask# 将Blueprint注册到flask核心对象上,并传入一个前缀&apos;/v1&apos;def register_blueprints(app): # from app.api.v1.user import user # from app.api.v1.book import book # app.register_blueprint(user) # app.register_blueprint(book) from app.api.v1 import create_blueprint_v1 app.register_blueprint(create_blueprint_v1(), url_prefix = &apos;/v1&apos;)def registe_plugin(app): # 插件的注册 from app.models.base import db db.init_app(app) with app.app_context(): # 上下文环境 把app推入到上下文栈中 才能使用create_all db.create_all() # 来创建所有数据库，数据表def create_app(): app = Flask(__name__) # 实例化flask核心对象 app.config.from_object(&apos;app.config.secure&apos;) # 读取配置文件下的secure app.config.from_object(&apos;app.config.setting&apos;) # 读取配置文件下的setting register_blueprints(app) # 注册蓝图到核心对象上 registe_plugin(app) # 最后调用 registe_plugin return app 4.完成客户端注册之前我们的ClientForm并没有nickname，但是注册email用户的时候是需要的，所以我们建立一个UserEmailForm继承ClientForm完成他自己的业务不能从request.json 中拿，因为这个参数没经过校验12345678910111213141516171819202122232425262728293031323334353637from wtforms import Form, StringField, IntegerField ,ValidationError # 字符串类型,数字类型,异常from wtforms.validators import DataRequired, length, Email, Regexpfrom app.libs.enums import ClientTypeEnumfrom app.models.user import User# 构建client验证器class ClientForm(Form): account = StringField(validators=[DataRequired(), length(min=1, max=32)]) secret = StringField() # 由于客户端类型的不同，密码不一定要传入 type = IntegerField(validators=[DataRequired()]) # 验证client_type def validate_type(self, value): try: # 将用户传来的参数去枚举类中匹配，如果匹配失败，则抛出异常 # 如果匹配成功则将int转换成枚举 client = ClientTypeEnum(value.data) # value.data 取到值 except ValueError as e: raise e # 面向对象的继承特性，减少代码量，ClientForm是很有必要存在的 self.type = client # 将枚举赋值给 typeclass UserEmailForm(ClientForm): account = StringField(validators=[ Email(message=&apos;validate email&apos;) ]) # 必须是Email secret = StringField(validators=[ DataRequired(), Regexp(r&apos;^[A-Za-z0-9_*&amp;$#@]&#123;6,22&#125;$&apos;) ]) #必须要密码，密码格式 nickname = StringField(validators=[DataRequired(), length(min=2, max=22)]) # 新增一个个性化参数nickname def validate_account(self, value): # 验证账号是否已经注册 if User.query.filter_by(email=value.data).first(): # 如果能查询到email raise ValidationError() # 则抛出异常 完成视图函数的编写1234567891011121314151617181920212223242526272829303132333435363738394041424344from app.libs.redprint import Redprintfrom app.validators.forms import ClientForm,UserEmailFormfrom flask import requestfrom app.libs.enums import ClientTypeEnumfrom app.models.user import Userapi = Redprint(&apos;client&apos;) # 实例化一个Redprint@api.route(&apos;/register&apos;, methods = [&apos;POST&apos;] ) # 路由注册 # 因为这里把POST打成PSOT，导致不能使用POST访问，状态码405def create_client(): # 表单 - 一般网页 json - 一般移动端 # 注册 登录 # 参数 校验 接收参数 # WTForms 验证表单#用来接收json类型的参数 data = request.json# 关键字参数data是wtform中用来接收json参数的方法 form = ClientForm(data = data) # data = 来接收json if form.validate():# 替代switchcase-&#123;Enum_name:handle_func&#125; promise = &#123; ClientTypeEnum.USER_EMAIL: __register_user_by_email#, # ClientTypeEnum.USER_MINA: __register_user_by_MINA # 可在此处构建多种枚举类型 &#125; promise[form.type.data]() return &apos;sucess&apos; # 暂时返回sucess#总 ↑#分 ↓def __register_user_by_email(): form = UserEmailForm(data=request.json) if form.validate(): User.register_by_email(form.nickname.data, form.account.data, form.secret.data)# def __register_user_by_MINA():# pass create_client和__register_user_by_email是一个总-分的关系，客户端注册的种类是比较多的，但是这些众多的种类又有一些共通的东西，比如处理客户端的type的值，就是所有的客户端都要携带的参数。对于这些共有的参数，我们就统一在create_client,ClientForm中进行处理 对于不同的客户端的特色的属性和功能，我们放在“分”里面来，比如email的nikename 3.3 重构代码-自定义验证对象我们之前写的代码，有一些细节问题。 1.传入错误的参数，虽然没有添加到数据库，但是返回 结果显示正常这是因为，form.validate()如果校验不通过，他不会抛出异常，而是会将异常信息存储在form对象中。 所以这个时候我们应该判断如果校验不通过，就抛出一个自定义的异常。 比如我之前在”type” = “100”,错误，但还是会return sucess。 werkzeug为我们提供的大量的异常，都继承自HTTPException，但是这些异常都很具体，不能为我们所用。不过我们可以自己定义一个异常来继承HTTPException 2.自定义异常rest中状态码代表的意义400 参数错误401 未授权403 禁止访问404 没有找到资源或者页面500 服务器未知错误200 查询成功201 更新/创建成功204 删除成功301/302 重定向 app\libs\erro_code.py12345678from werkzeug.exceptions import HTTPException# 自定义异常类class ClientTypeErro(HTTPException): code = 400 description = ( &apos;client is invalid&apos; ) 修改后的试图函数app\api\v1\client.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from app.libs.redprint import Redprintfrom app.validators.forms import ClientForm,UserEmailFormfrom flask import requestfrom app.libs.enums import ClientTypeEnumfrom app.models.user import User# from werkzeug.exceptions import HTTPException # 异常from app.libs.erro_code import ClientTypeErro # 导入自定义异常api = Redprint(&apos;client&apos;) # 实例化一个Redprint@api.route(&apos;/register&apos;, methods = [&apos;POST&apos;] ) # 路由注册 # 因为这里把POST打成PSOT，导致不能使用POST访问，状态码405def create_client(): # 表单 - 一般网页 json - 一般移动端 # 注册 登录 # 参数 校验 接收参数 # WTForms 验证表单#用来接收json类型的参数 data = request.json# 关键字参数data是wtform中用来接收json参数的方法 form = ClientForm(data = data) # data = 来接收json if form.validate():# 替代switchcase-&#123;Enum_name:handle_func&#125; promise = &#123; ClientTypeEnum.USER_EMAIL: __register_user_by_email#, # ClientTypeEnum.USER_MINA: __register_user_by_MINA # 可在此处构建多种枚举类型 &#125; promise[form.type.data]() else: raise ClientTypeErro() # 抛出自定义异常 return &apos;sucess&apos; # 暂时返回sucess#总 ↑#分 ↓def __register_user_by_email(): form = UserEmailForm(data=request.json) if form.validate(): User.register_by_email(form.nickname.data, form.account.data, form.secret.data)# def __register_user_by_MINA():# pass 修改完成之后，已经修复了之前的缺陷，但是这样爆出了两个问题： 1.代码太啰嗦了，每个试图函数里，都需要这么写 2.ClientTypeError只是代表客户端类型异常，其他的参数校验不通过也抛出这个异常的话不合适 2.异常返回的标准与重要性我们的restapi返回的信息主要分为以下三类: 1.页数数据信息 2.操作成功提示信息 3.错误异常信息 如果错误异常信息不够标准，那么客户端很难去处理我们的错误异常。 无论上面三种，都属于输出，REST-API要求输入输出都要返回JSON 3.自定义ApiException通过分析HttpException的get_body,get_header源码我们可以知道，这两个方法分别组成了默认异常页面的header和html文本，所以如果要让我们的异常返回json格式的信息，需要继承HttpException并重写这两个方法. 万不得已,不要动框架源代码 HttpException 源代码部分123456789101112131415161718192021222324252627282930313233class HTTPException(Exception): &quot;&quot;&quot; Baseclass for all HTTP exceptions. This exception can be called as WSGI application to render a default error page or you can catch the subclasses of it independently and render nicer error messages. &quot;&quot;&quot; code = None description = None def __init__(self, description=None, response=None): Exception.__init__(self) if description is not None: self.description = description self.response = response def get_body(self, environ=None): &quot;&quot;&quot;Get the HTML body.&quot;&quot;&quot; return text_type(( u&apos;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 3.2 Final//EN&quot;&gt;\n&apos; u&apos;&lt;title&gt;%(code)s %(name)s&lt;/title&gt;\n&apos; u&apos;&lt;h1&gt;%(name)s&lt;/h1&gt;\n&apos; u&apos;%(description)s\n&apos; ) % &#123; &apos;code&apos;: self.code, &apos;name&apos;: escape(self.name), &apos;description&apos;: self.get_description(environ) &#125;) def get_headers(self, environ=None): &quot;&quot;&quot;Get a list of headers.&quot;&quot;&quot; return [(&apos;Content-Type&apos;, &apos;text/html&apos;)] app\libs\erro.py123456789101112131415161718192021222324252627282930313233343536373839404142from werkzeug.exceptions import HTTPExceptionfrom flask import request,json# 重写 HTTPExceptionclass APIException(HTTPException): # 定义默认异常信息 code = 500 msg = &apos;sorry, we make a mistake&apos; erro_code = 999 # 自定义的错误码 # 建议新建一个code.md记录自定义的错误码 def __init__(self, msg = None, code = None, erro_code = None, headers = None): # 给定None ,不传就是默认值 # 传了的话，就是选传的值 if code: self.code = code if erro_code: self.erro_code = erro_code if msg: self.msg = msg super(APIException, self).__init__(self.msg, None) # 继承 def get_body(self, environ=None): body = dict( msg = self.msg, erro_code = self.erro_code, # request = &apos;POST v1/client/register&apos; request = request.method+&apos; &apos;+self.get_url_no_param() ) text = json.dumps(body) # 将字典转换为json 文本 json 序列化 return text def get_headers(self, environ=None): return [(&apos;Content-Type&apos;, &apos;application/json&apos;)] # 将返回标识成json @staticmethod def get_url_no_param(): # 没有？后面的参数 full_path = request.full_path # 拿到 url完整路径 main_path = full_path.split(&apos;?&apos;) # 去掉？和后面 return main_path[0]]]></content>
      <categories>
        <category>flask-api</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask构建可扩展的RESTful-API-4--理解WTForms并灵活改造她]]></title>
    <url>%2Fflask-api%2FFlask%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84RESTful-API-4--%E7%90%86%E8%A7%A3WTForms%E5%B9%B6%E7%81%B5%E6%B4%BB%E6%94%B9%E9%80%A0%E5%A5%B9%2F</url>
    <content type="text"><![CDATA[4.1 重写WTForms优化1之前的代码，修改完成之后，已经修复了之前的缺陷，但是这样爆出了两个问题： 1.代码太啰嗦了，每个试图函数里，都需要这么写 2.ClientTypeError只是代表客户端类型异常，其他的参数校验不通过也抛出这个异常的话不合适 为了解决上面的问题，我们需要重写wtforms 思路 继承原有的wtforms,重写validate_for_api，修改wtforms为抛出异常定义一个自定义BaseForm，让其他的Form来继承app\validators\base.py123456789101112from wtforms import Formfrom app.libs.erro_code import ParameterExceptionclass BaseForm(Form): def __init__(self, data): super(BaseForm, self).__init__(data=data) # 调用父类构造函数 def validate_for_api(self): valid = super(BaseForm, self).validate() # 调用父类的构造方法 # 验证是否通过 if not valid: # 没通过 # 所有异常类信息在form errors 中 raise ParameterException(msg=self.errors) # 抛出异常 # 公共的自定义异常类 定义公共异常类 app\libs\erro_code.py123456789101112from app.libs.erro import APIExceptionclass ClientTypeErro(APIException): code = 400 msg = &apos;client is invalid&apos; erro_code = 1006class ParameterException(APIException): code = 400 msg = &apos;invalid parameter&apos; erro_code = 1000 以后我们的试图函数就可以这样编写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from app.libs.redprint import Redprintfrom app.validators.forms import ClientForm,UserEmailFormfrom flask import requestfrom app.libs.enums import ClientTypeEnumfrom app.models.user import User# from werkzeug.exceptions import HTTPException # 异常from app.libs.erro_code import ClientTypeErro # 导入自定义异常api = Redprint(&apos;client&apos;) # 实例化一个Redprint@api.route(&apos;/register&apos;, methods = [&apos;POST&apos;] ) # 路由注册 # 因为这里把POST打成PSOT，导致不能使用POST访问，状态码405def create_client(): # 表单 - 一般网页 json - 一般移动端 # 注册 登录 # 参数 校验 接收参数 # WTForms 验证表单#用来接收json类型的参数 data = request.json# 关键字参数data是wtform中用来接收json参数的方法 form = ClientForm(data = data) # data = 来接收json form.validate_for_api()# 替代switchcase-&#123;Enum_name:handle_func&#125; promise = &#123; ClientTypeEnum.USER_EMAIL: __register_user_by_email#, # ClientTypeEnum.USER_MINA: __register_user_by_MINA # 可在此处构建多种枚举类型 &#125; promise[form.type.data]() return &apos;sucess&apos; # 暂时返回sucess#总 ↑#分 ↓def __register_user_by_email(): form = UserEmailForm(data=request.json) if form.validate(): User.register_by_email(form.nickname.data, form.account.data, form.secret.data)# def __register_user_by_MINA():# pass 优化2目前我们每次都需要从request中取出json信息再传入到Form对象中，优化的思路是，直接传入request，在BaseForm中取出jsonapp\validators\base.py123456789101112131415from wtforms import Formfrom app.libs.erro_code import ParameterExceptionfrom flask import requestclass BaseForm(Form): # def __init__(self, data): def __init__(self): data = request.json super(BaseForm, self).__init__(data=data) # 调用父类构造函数 def validate_for_api(self): valid = super(BaseForm, self).validate() # 调用父类的构造方法 # 验证是否通过 if not valid: # 没通过 # 所有异常类信息在form errors 中 raise ParameterException(msg=self.errors) # 抛出异常 # 公共的自定义异常类 优化3每次都需要实例化Form对象，再调用validate_for_api()方法，我们可以让validate_for_api方法返回一个self对象，这样就只需要一行代码就可以解决了app\validators\base.py12345678910111213141516from wtforms import Formfrom app.libs.erro_code import ParameterExceptionfrom flask import requestclass BaseForm(Form): # def __init__(self, data): def __init__(self): data = request.json super(BaseForm, self).__init__(data=data) # 调用父类构造函数 def validate_for_api(self): valid = super(BaseForm, self).validate() # 调用父类的构造方法 # 验证是否通过 if not valid: # 没通过 # 所有异常类信息在form errors 中 raise ParameterException(msg=self.errors) # 抛出异常 # 公共的自定义异常类 return self 优化4操作成功也需要返回json结构，且结构应该和异常的时候一样，所以我们可以定义一个Success继承APIExceptionapp\libs\erro_code.py12345678910111213141516171819202122232425262728293031323334353637# from werkzeug.exceptions import HTTPException# # 自定义异常类# class ClientTypeErro(HTTPException):# code = 400# description = (# &apos;client is invalid&apos;# ) # ↑ 不再继承HTTPException# ↓ 继承APIExceptionfrom app.libs.erro import APIExceptionclass ClientTypeErro(APIException): code = 400 msg = &apos;client is invalid&apos; erro_code = 1006class ParameterException(APIException): code = 400 msg = &apos;invalid parameter&apos; erro_code = 1000# 将成功返回也当作一中 APIException，来优化代码class Success(APIException): code = 201 msg = &apos;ok&apos; erro_code = 0 class ServerError(APIException): code = 500 msg = &apos;sorry,we made a mistaake&apos; erro_code = 999 优化后视图函数app\api\v1\client.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from app.libs.redprint import Redprintfrom app.validators.forms import ClientForm,UserEmailForm# from flask import request # 转移到Baseform中去了from app.libs.enums import ClientTypeEnumfrom app.models.user import User# from werkzeug.exceptions import HTTPException # 异常from app.libs.erro_code import ClientTypeErro, ParameterException ,Success # 导入自定义异常api = Redprint(&apos;client&apos;) # 实例化一个Redprint@api.route(&apos;/register&apos;, methods = [&apos;POST&apos;] ) # 路由注册 # 因为这里把POST打成PSOT，导致不能使用POST访问，状态码405def create_client(): # 表单 - 一般网页 json - 一般移动端 # 注册 登录 # 参数 校验 接收参数 # WTForms 验证表单#用来接收json类型的参数 # data = request.json# 关键字参数data是wtform中用来接收json参数的方法 # form = ClientForm(data = data) # data = 来接收json # form = ClientForm() # 转移到 BaseForm 中 # form.validate_for_api() form = ClientForm().validate_for_api()# 替代switchcase-&#123;Enum_name:handle_func&#125; promise = &#123; ClientTypeEnum.USER_EMAIL: __register_user_by_email#, # ClientTypeEnum.USER_MINA: __register_user_by_MINA # 可在此处构建多种枚举类型 &#125; promise[form.type.data]() return Success() # 将成功返回也当作一中 APIException#总 ↑#分 ↓def __register_user_by_email():# form = UserEmailForm()# # if form.validate():# form.validate_for_api() form = UserEmailForm().validate_for_api() # 为什么有括号 User.register_by_email(form.nickname.data, form.account.data, form.secret.data)# def __register_user_by_MINA():# pass 我们可以接受定义时候的复杂，但是不能够接受调用的时候复杂 定义是一次性的，但是调用是多次的，如果调用太过于复杂，会使得我们的 代码太过于臃肿 4.2 全局异常处理当系统抛出不是我们自己定义的APIException的时候，返回的结果仍然会变成一个HTML文本。 我们在写代码的过程中，有那么类型的异常： 1.已知异常：我们可以预知的。如枚举转换的时候抛出的异常，这时候我们就会提前使用try-except进行处理。也可以抛出APIException 2.未知异常：完全没有预料到的。会由框架抛出的内置异常 我们可以使用flask给我们提供的处理全局异常的装饰器，采用AOP的设计思想，捕捉所有类型的异常。1234567891011121314151617181920212223242526from app import create_appfrom app.libs.erro_code import ServerErrorfrom app.libs.erro import APIExceptionfrom werkzeug.exceptions import HTTPExceptionapp = create_app()@app.errorhandler(Exception) # python 基类的异常,因为我们要捕捉所有异常def framework_error(e): if isinstance(e, APIException): return e if isinstance(e, HTTPException): # 转化成APIException code = e.code msg = e.description error_code = 1007 return APIException(msg, code, error_code) else: if not app.config[&apos;DEBUG&apos;]: # 判断是否在调试模式,不再,直接返回 return ServerError() else: raise e return ServerError()if __name__ == &apos;__main__&apos;: app.run(debug=True)]]></content>
      <categories>
        <category>flask-api</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask构建可扩展的RESTful-API-5--Token与HTTPBasic验证-——-用令牌来管理用户]]></title>
    <url>%2Fflask-api%2FFlask%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84RESTful-API-5--Token%E4%B8%8EHTTPBasic%E9%AA%8C%E8%AF%81-%E2%80%94%E2%80%94-%E7%94%A8%E4%BB%A4%E7%89%8C%E6%9D%A5%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[5.1 Token1.Token概述以下是网站登录和使用API登录的区别 与网站登录不同的是，网站登录将登录信息写入cookie存储在浏览器，而API只负责生成token发送给客户端，而客户端怎么存储有自己决定。 Token具有有效期 Token可以标示用户身份，如存储用户id 2.获取Token令牌密码校验–app.models/user.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from sqlalchemy import inspect, Column, Integer, String, SmallInteger, ormfrom werkzeug.security import generate_password_hash, check_password_hashfrom app.libs.erro_code import NotFound, AuthFailedfrom app.models.base import Base , db #, MixinJSONSerializerimport datetimeclass User(Base): id = Column(Integer, primary_key=True) email = Column(String(24), unique=True, nullable=False) nickname = Column(String(24), unique=True) auth = Column(SmallInteger, default=1) # 做层级的标志 _password = Column(&apos;password&apos;, String(100)) def keys(self): return [&apos;id&apos;, &apos;email&apos;, &apos;nickname&apos;, &apos;auth&apos;] @property def password(self): return self._password # 对密码的处理 @password.setter def password(self, raw): self._password = generate_password_hash(raw) # 对密码的处理 @staticmethod def register_by_email(nickname, account, secret): with db.auto_commit(): user = User() user.nickname = nickname user.email = account user.password = secret db.session.add(user) @staticmethod def verify(email, password): user = User.query.filter_by(email=email).first_or_404() # 查询出当前用户 if not user: raise NotFound(msg = &apos;user not found...&apos;) if not user.check_password(password): # 检验密码 raise AuthFailed() #抛出异常 return &#123;&apos;uid&apos;: user.id&#125; #成功，返回uid def check_password(self, raw): # 密码检验 if not self._password: return False return check_password_hash(self._password, raw) 返回token的试图函数，这里稍微破坏一下REST的规则，由于登录操作密码安全性较高，使用GET的话会泄漏app\api\v1\token.py123456789101112131415161718192021222324252627282930313233343536373839404142434445from app.libs.redprint import Redprintfrom flask import current_appfrom app.libs.enums import ClientTypeEnumfrom app.models.user import Userfrom app.validators.forms import ClientFormfrom itsdangerous import TimedJSONWebSignatureSerializer as Serializerfrom flask import jsonifyapi = Redprint(&apos;token&apos;) # 实例化一个Redprint@api.route(&apos;&apos;, methods=[&apos;POST&apos;]) # 路由注册# 返回token的试图函数，这里稍微破坏一下REST的规则，由于登录操作密码安全性较高，使用GET的话会泄漏def get_token(): form = ClientForm().validate_for_api() # 同注册过程，不同client 区分 promise = &#123; ClientTypeEnum.USER_EMAIL: User.verify, #验证 # 在 user中编写 verify # ClientTypeEnum.USER_MINA: __register_user_by_MINA &#125; # 拿到用户信息 identity = promise[form.type.data]( form.account.data, form.secret.data ) # 调用函数生成token expiration = current_app.config[&apos;TOKEN_EXPIRATION&apos;] #过期时间 token = generator_auth_token(identity[&apos;uid&apos;], form.type.data, None, expiration=expiration) t = &#123; &apos;token&apos;: token.decode(&apos;utf-8&apos;) # 因为是byte &#125; return jsonify(t), 201 # 返回 json 字典def generator_auth_token(uid, ac_type, scope=None,expiration=7200): &quot;&quot;&quot;生成令牌 ，拿到uid,client类型，权限作用域，过期时间&quot;&quot;&quot; s = Serializer(current_app.config[&apos;SECRET_KEY&apos;],expires_in=expiration) # expires_in 生成令牌的有效期 return s.dumps(&#123; &apos;uid&apos;: uid, &apos;type&apos;: ac_type.value &#125;) # 将想写入的信息以字典形式写入令牌 app.setting.py 12TOKEN_EXPIRATION = 30 * 24 * 3600 app\libs\erro_code.py12345678910111213141516171819202122232425262728293031323334353637383940from app.libs.erro import APIExceptionclass ClientTypeErro(APIException): code = 400 msg = &apos;client is invalid&apos; erro_code = 1006class ParameterException(APIException): code = 400 msg = &apos;invalid parameter&apos; erro_code = 1000# 将成功返回也当作一中 APIException，来优化代码class Success(APIException): code = 201 msg = &apos;ok&apos; erro_code = 0class ServerError(APIException): code = 500 msg = &apos;sorry,we made a mistaake&apos; erro_code = 999class NotFound(APIException): code = 404 msg = &apos;the resource are not found O__O...&apos; error_code = 1001class AuthFailed(APIException): code = 401 error_code = 1005 msg = &apos;authorization failed&apos;class Forbidden(APIException): code = 403 error_code = 1004 msg = &apos;forbidden, not in scope&apos; 注册到Blueprintapp\api\v1__init__.py 12345678910111213from flask import Blueprintfrom app.api.v1 import user, book ,client ,token # 创建一个Bluerint,把Redprint注册到Blueprint上，并传入Redprint一个前缀&apos;/bookdef create_blueprint_v1(): bp_v1 = Blueprint(&apos;v1&apos;, __name__) user.api.register(bp_v1) # , url_prefix=&apos;/uesr&apos;) book.api.register(bp_v1) # ,url_prefix=&apos;/book&apos;) client.api.register(bp_v1) token.api.register(bp_v1) return bp_v1 3.Token的用处 我们不可能让任何一个用户都来访问我们获取用户资料的接口，必须对这个加以控制，也就是说只有确定了身份的用户可以访问我们的接口。 如何对这个接口做保护呢？ 当用户访问问的接口的时候，我们需要获取他传来的token并进行解析验证，只有token是合法的且没有过期，我们才允许访问。 由于每个需要验证token的试图函数都需要上面的业务逻辑，所以我们可以编写一个装饰器，以面向切面的方式统一处理，编写一个函数验证token，如果验证通过，我们就继续执行试图函数的方法，如果不通过，我们就返回一个自定义异常。 app.libs/token_auth.py 12345678from flask_httpauth import HTTPBasicAuthauth = HTTPBasicAuth()@auth.verify_passworddef verify_password(account, password): pass app/api/v1/user.py123456789from app.libs.redprint import Redprintfrom app.libs.token_auth import authapi = Redprint(&apos;user&apos;)#@api.route(&apos;/get&apos;) URL中不应该包含动词@api.route(&apos;&apos;,methods = [&apos;GET&apos;])@auth.login_requireddef get_user(): return &apos;get_user&apos; 5.2 HTTPBasicAuth1.HTTPBasicAuth基本原理除了自定义发送账号和密码之外，HTTP这种协议本身就有多种规范，来允许我们来传递账号和密码。其中一种就是HTTPBasic HTTPBasic：需要在HTTP请求的头部设置一个固定的键值对key=Authorization,value=basic base64(account:psd) 2.以BasicAuth方式来发送token我们可以将token作为上面所说的账号account，而密码psd传递空值 5.3 Token的发送与验证1.验证tokenapp\libs\token_auth.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 编写一个验证token的装饰器from flask_httpauth import HTTPBasicAuthfrom flask import current_app, gfrom itsdangerous import TimedJSONWebSignatureSerializer as Serializer, BadSignature, \ SignatureExpiredfrom collections import namedtuplefrom app.libs.erro_code import AuthFailedauth = HTTPBasicAuth()User = namedtuple(&apos;User&apos;, [&apos;uid&apos;, &apos;ac_type&apos;, &apos;scope&apos;])# @auth.verify_password# def verify_password(account, password):# # 需要在HTTP请求的头部设置一个固定的键值对# # key=Authorization,value=basic base64(account:psd)# # imwl@live.com:12345678 编码后 aW13bEBsaXZlLmNvbToxMjM0NTY3OA==# # key=Authorization,value=basic aW13bEBsaXZlLmNvbToxMjM0NTY3OA==# return True@auth.verify_passworddef verify_password(token, password): user_info = verify_auth_token(token) # token 赋值给 user_info if not user_info: return False else: g.user = user_info # g 变量 ,代理模式 return Truedef verify_auth_token(token): s = Serializer(current_app.config[&apos;SECRET_KEY&apos;]) try: data = s.loads(token) # 解密 token # token不合法抛出的异常 except BadSignature: raise AuthFailed(msg=&apos;token is valid&apos;, erro_code=1002) # token过期抛出的异常 except SignatureExpired: raise AuthFailed(msg=&apos;token is expired&apos;, erro_code=1003) uid = data[&apos;uid&apos;] ac_type = data[&apos;type&apos;] # 生成令牌的时候写入了 uid ac_type return User(uid, ac_type, &apos;&apos;) # 定义对象式 接口返回回去 ,scope 先返回为空字符串 2.视图函数的编写app\api\v1\user.py1234567891011121314151617181920from app.libs.redprint import Redprintfrom app.libs.token_auth import authfrom app.models.user import Userfrom app.models.base import dbfrom flask import jsonifyapi = Redprint(&apos;user&apos;)#@api.route(&apos;/get&apos;) URL中不应该包含动词@api.route(&apos;/&lt;int:uid&gt;&apos;, methods = [&apos;GET&apos;]) # 获取到用户的uid@auth.login_requireddef get_user(uid): # 接收 uid user = User.query.get_or_404 (uid) # 获取到用户，用get_or_404简化判断用户是否存在 # 因为get_or_404 抛出的不是APIException,所以要重写 # query 属性下的方法 r = &#123; &apos;nickname&apos;:user.nickname, &apos;email&apos;:user.email, &apos;password&apos;:user.password &#125; # 追求更好的写法 3.重写后的get_or_404,抛出自定义异常app\models\base.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from datetime import datetimefrom flask_sqlalchemy import SQLAlchemy as _SQLAlchemy, BaseQueryfrom sqlalchemy import Column, Integer, SmallIntegerfrom contextlib import contextmanagerclass SQLAlchemy(_SQLAlchemy): @contextmanager def auto_commit(self): try: yield self.session.commit() except Exception as e: db.session.rollback() raise efrom app.libs.erro_code import NotFoundclass Query(BaseQuery): def filter_by(self, **kwargs): if &apos;status&apos; not in kwargs.keys(): kwargs[&apos;status&apos;] = 1 return super(Query, self).filter_by(**kwargs) # 仿照源码改写get_or_404，覆盖原来的 get_or_404] def get_or_404(self, ident): &quot;&quot;&quot;Like :meth:`get` but aborts with 404 if not found instead of returning ``None``.&quot;&quot;&quot; rv = self.get(ident) if rv is None: raise NotFound() return rv def first_or_404(self): rv = self.first() if rv is None: raise NotFound() return rvdb = SQLAlchemy(query_class=Query)class Base(db.Model): __abstract__ = True create_time = Column(Integer) status = Column(SmallInteger, default=1) def __init__(self): self.create_time = int(datetime.now().timestamp()) @property def create_datetime(self): if self.create_time: return datetime.fromtimestamp(self.create_time) else: return None def set_attrs(self, attrs_dict): for key, value in attrs_dict.items(): if hasattr(self, key) and key != &apos;id&apos;: setattr(self, key, value) def delete(self): self.status = 0 4.获取令牌信息12345678910111213141516171819@api.route(&apos;/secret&apos;, methods=[&apos;POST&apos;])def get_token_info():&quot;&quot;&quot;获取令牌信息&quot;&quot;&quot; form = TokenForm().validate_for_api() s = Serializer(current_app.config[&apos;SECRET_KEY&apos;]) try: data = s.loads(form.token.data, return_header=True) except SignatureExpired: raise AuthFailed(msg=&apos;token is expired&apos;, error_code=1003) except BadSignature: raise AuthFailed(msg=&apos;token is invalid&apos;, error_code=1002) r = &#123; &apos;scope&apos;: data[0][&apos;scope&apos;], &apos;create_at&apos;: data[1][&apos;iat&apos;], &apos;expire_in&apos;: data[1][&apos;exp&apos;], &apos;uid&apos;: data[0][&apos;uid&apos;] &#125; return jsonify(r)]]></content>
      <categories>
        <category>flask-api</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask构建可扩展的RESTful-API-6--模型对象的序列化]]></title>
    <url>%2Fflask-api%2FFlask%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84RESTful-API-6--%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[6. 模型对象的序列化1.理解序列化时的default函数我们最想做的一件事情，就是在视图函数中，读取出模型之后，还要把他的属性读出来，转换成一个字典。我们想直接jsonfiy(user) 现在jsonfiy并不能直接序列化对象，所以我们的目标就是必须想办法让jsonfiy直接序列化对象。 jsonfiy在序列化对象的时候，如果不知道如何序列化当前传进来的参数，就会去调用JSONEncoder类的default函数。1234567891011121314151617181920212223242526def default(self, o):&quot;&quot;&quot;Implement this method in a subclass such that it returns aserializable object for ``o``, or calls the base implementation (toraise a :exc:`TypeError`).For example, to support arbitrary iterators, you could implementdefault like this::def default(self, o): try: iterable = iter(o) except TypeError: pass else: return list(iterable) return JSONEncoder.default(self, o)&quot;&quot;&quot; if isinstance(o, datetime): return http_date(o.utctimetuple()) if isinstance(o, date): return http_date(o.timetuple()) if isinstance(o, uuid.UUID): return str(o) if hasattr(o, &apos;__html__&apos;): return text_type(o.__html__()) return _json.JSONEncoder.default(self, o) 目前的default是没有提供对对象的序列化的，所以我们这里最关键的就是要重写default方法。在重写的过程中实现对对象的序列化就可以了 2.不完美的对象转字典我们首先要做到的就是让Flask可以调用到我们自己定义的default函数。要做到这一点，我们需要继承JSONEncoder，然后重写defualt方法，然后继承Flask，在子类里，替换掉Flask原有的json_encoder对象。然后，是实例化Flask核心对象的时候，使用我们的子类进行实例化app__init__.py1234567891011121314151617181920212223242526272829303132333435363738from flask import Flask as _Flaskfrom flask.json import JSONEncoder as _JSONEncoderclass JSONEncoder(_JSONEncoder): def default(self,o): # return o.__dict__ # 内置方法，将对象转化为字典 # 缺点是只能转换实例变量，不能将类变量也转换成字典 return dict(o)class Flask(_Flask): # 定义自己的Flask核心对象，继承原来的Flask核心对象 json_encoder = JSONEncoder # 替换原本的JSONEncoder# 将Blueprint注册到flask核心对象上,并传入一个前缀&apos;/v1&apos;def register_blueprints(app): # from app.api.v1.user import user # from app.api.v1.book import book # app.register_blueprint(user) # app.register_blueprint(book) from app.api.v1 import create_blueprint_v1 app.register_blueprint(create_blueprint_v1(), url_prefix = &apos;/v1&apos;)def registe_plugin(app): # 插件的注册 from app.models.base import db db.init_app(app) with app.app_context(): # 上下文环境 把app推入到上下文栈中 才能使用create_all db.create_all() # 来创建所有数据库，数据表def create_app(): app = Flask(__name__) # 实例化flask核心对象 app.config.from_object(&apos;app.config.secure&apos;) # 读取配置文件下的secure app.config.from_object(&apos;app.config.setting&apos;) # 读取配置文件下的setting register_blueprints(app) # 注册蓝图到核心对象上 registe_plugin(app) # 最后调用 registe_plugin return app 上面的写法o.dict只能转换实例变量，不能将类变量也转换成字典。 3.深入理解dict机制在Python中创建一个dict有很多种方式: 直接定义一个字典 123r = &#123;&apos;name&apos;: &apos;gwf&apos;&#125; 使用dict函数 1r = dict(name=&apos;gwf&apos;) 将一个对象传入dict函数 值得研究的是这第三种方法，当将一个对象传入dict函数的时候，他会去调用keys函数 keys 方法的目的就是为了拿到字典里所有的键，至于说这些键有那么，完全有我们自己来定义。keys 返回的必须是一个元组或者列表来声明要序列化的键。 而dict会以中括号的形式来拿到对应的值，如o[“name”]，但是默认是不能这么访问的，我们需要编写getitem函数123456789101112131415161718192021r = &#123;&apos;name&apos;: &apos;weilai&apos;&#125; # 直接定义一个字典r = dict(name= &apos;weilai&apos;) # 使用dict函数class Wei(): name = &apos;weilai&apos; age = &apos;age&apos; def __init__(self): self.gender = &apos;male&apos; def keys(self): return (&apos;name&apos;,&apos;age&apos;,&apos;gender&apos;) # 取到 key , 做到自定义key # # return (&apos;name&apos;,) # 一个元素的元组 # return [&apos;name&apos;] # return 序列类型的都可以 def __getitem__(self,item): return getattr(self,item) # 取到 key对应的valueo = Wei()print(dict(o)) # &#123;&apos;name&apos;: &apos;weilai&apos;, &apos;age&apos;: &apos;age&apos;, &apos;gender&apos;: &apos;male&apos;&#125; 这样我们就成功的讲一个对象转化成了字典的形式，并且无论类变量和实例变量，都可以转化，更加灵活的是，我们可以自己控制，那些变量需要转化，哪些变量不需要转化 4.序列化SQLALChemy模型有了之前的基础，我们就知道怎么序列化user对象了，我们只需要在User类中定义keys和getitem方法，然后在default函数中使用dict()函数即可123456class JSONEncoder(_JSONEncoder): def default(self, o): return dict(o)class Flask(_Flask): json_encoder = JSONEncoder models/user.py12345678910111213141516171819202122class User(Base): id = Column(Integer, primary_key=True) email = Column(String(50), unique=True, nullable=False) auth = Column(SmallInteger, default=1) nickname = Column(String(24), nullable=False) _password = Column(&apos;password&apos;, String(128))# SQLALChemy的实例化是不会调用__init__函数的，要想让他调用就需要# @orm.reconstructor这个装饰器 @orm.reconstructor def __init__(self): self.fields = [&apos;id&apos;, &apos;email&apos;, &apos;nickname&apos;] def keys(self): return self.fields # 支持隐藏字段 def hide(self, *keys): [self.fields.remove(key) for key in keys] # 支持添加字段 def append(self, *keys): [self.fields.append(key) for key in keys] 5.完善序列化优化1：每一个模型如果需要序列化，都要有getitem方法，可以放到基类里面去 优化2：default函数，是递归调用的，只要遇到不能序列化的对象，就会调用default函数。所以如果有其他类型，我们需要修改完善我们的default函数 优化3：我们的default函数需要增加容错性12345678910class JSONEncoder(_JSONEncoder): def default(self,o): # return o.__dict__ # 内置方法，将对象转化为字典 # 缺点是只能转换实例变量，不能将类变量也转换成字典 # return dict(o) # 考虑不全面.o得有上次定义的那两种方法才不会报错 if hasattr(o, &apos;keys&apos;) and hasattr(o, &apos;__getitem__&apos;): return dict(o) # 得有这两种方法 才会return dict(o) if isinstance(o, date): # 如果是 时间类型 return o.strftime(&apos;%Y-%m-%d&apos;) raise ServerError() 优化4：之前编写的新的Flask类，JsonEncoder类都是不会轻易改变的，放到app.py中。一些其他方法，却是 经常改变的，应该把他们放在init文件中 6.ViewModel对于API有意义吗？viewmodel对于API来说，特别是内部开发来说非常有意义 viewmodel是为了我们的视图层，提供个性化的试图模型。SQLALChemy返回的模型是原始模型（格式和数据库中存储的一模一样）。 而前端可能需要我们返回一个意义更加明确的字段。 原始模型是根据数据库来生成的，他的格式是一定的，但是我们在视图层中或者API的返回中，要根据业务去具体的个性化一个个属性的 格式，这就必然存在一个由原始模型向视图模型转换的过程，这个过程最适合的是在View_model中进行一个转换。 我们在视图层写转换的代码，一来会污染视图层的代码，二来会难以复用 并且有的试图模型可能会比较复杂，设计到多个原始模型，这个代码必定会比较复杂，写在视图函数中就会非常不合适 对于完全严格意义上的RESTFul，viewmodel的意义并不大，因为完全资源意义的RESTFul是不考虑业务逻辑的]]></content>
      <categories>
        <category>flask-api</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask构建可扩展的RESTful-API-7--权限控制]]></title>
    <url>%2Fflask-api%2FFlask%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84RESTful-API-7--%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[7.1 删除模型的注意事项1.204 的HTTP状态码代表的是NO CONTENT，无内容。所以如果状态码是204，那么无论返回什么，前端都接受不到，但是我们要尽量返回格式化的信息，让前端能够判断，为此，我们可以使用状态码202，并且添加一个特殊的error_code=-1 来代表删除操作 2.由于我们的删除是逻辑删除，使用get的方法会一直可以查询出当前用户，这里我们应该使用filter_by()，传入status=1，好在，我们之前已经在基类重写了filter_by()，所以我们只需要调用filter_by()传入id即可app\api\v1\user.py123456789@api.route(&apos;/&lt;int:uid&gt;&apos;, methods = [&apos;DELETE&apos;]) @auth.login_requireddef delete_user(uid): with db.auto_commit(): # user = User.query.get_or_404(uid) #软删除后，用get 还是能查询到，所以改写 user = User.query.filter_by(id=uid).first_or_404() user.delete() # 软删除 # return &apos;delete sucess&apos; return DeleteSuccess() app\libs\erro_code.py123class DeleteSuccess(Success): code = 202 error_code = 1 3.防止超权现象 id=1的用户，不能删除id=2的用户，为了解决这个问题，我们的uid不能由用户传入，而是应该从他传入的token中取出来。由于我们之前做token验证的时候，已经把取出来的信息存入到了flask的g中，所以我们只需要从g中取出来做判断即可12345678910111213@api.route(&apos;&apos;, methods = [&apos;DELETE&apos;]) @auth.login_requireddef delete_user(): uid = g.user.uid # 防止超权，从token中读取 已存储在 g 变量中 ，g 变量线程隔离。 # 对于管理员来说，可以超权，删除别的用户 with db.auto_commit(): # user = User.query.get_or_404(uid) #软删除后，用get 还是能查询到，所以改写 user = User.query.filter_by(id=uid).first_or_404() user.delete() # 软删除 # return &apos;delete sucess&apos; return DeleteSuccess() 两个知识点1.g.user.uid之所以可以这样用.的方式获取uid，是因为我们在向g中存储user的时候，使用的是namedtuple，而不是dict，不然我们就只能g.user[‘uid’]这样获取了2.即使两个用户同时访问这个接口，我们也不会出错，g会正确的指向每一个请求的user，这是因为g是线程隔离的 4.我们是需要一个超级管理员用户的试图函数super_delete_user，可以通过传入uid来删除指定用户的。但是对这两个接口，普通用户应该只能访问delete_user，而超级管理员都能够访问。 首先我们需要创建一个管理员用户，不过管理员用户不能通过公开API来创建，而应该直接在数据库里创建，但是这又涉及到一个问题，就是直接在数据库里创建，密码不好生成。所以最好的方式是创建一个离线脚本文件.也可以普通注册，改auth为212345678910111213141516from app import create_appfrom app.models.base import dbfrom app.models.user import Userapp = create_app()with app.app_context(): with db.auto_commit(): # 离线脚本，创建一个超级管理员 user = User() user.nickname = &apos;Super&apos; user.password = &apos;123456&apos; user.email = &apos;999@qq.com&apos; user.auth = 2 db.session.add(user)# 直接运行就能创建 这个脚本不仅仅可以生成管理员，还可以使用它生成大量的假数据，测试数据 7.2 权限管理方案通过之前的分析，我们可以发现，我们之前的get_user，实际上应该是super_get_user，而我们应该在多添加一个get_user作为普通用户的获取方法123456789101112@api.route(&apos;/&lt;int:uid&gt;&apos;, methods=[&apos;GET&apos;])@auth.login_requireddef super_get_user(uid): user = User.query.filter_by(id=uid).first_or_404(uid) return jsonify(user)@api.route(&apos;&apos;, methods = [&apos;GET&apos;]) @auth.login_requireddef get_user(): uid = g.user.uid user = User.query.filter_by(id=uid).first_or_404() return jsonify(user) 1.不太好的权限管理方案我们只要可以在视图函数中获取到用户的权限，就可以根据权限来判断，用户的身份，来做出不同的控制。 要做到这一点，我们只需要在生成令牌的时候，将is_admin的字段写入到token中。然后再视图函数中取出这个字段来进行不同的判断就好了。 这样的方案有两个缺点： 1.代码太啰嗦了，每个视图函数都需要做这样的判断。 2.我们把全新想的太简单了，我们这个项目只有管理员和普通用户两种，但是真正的权限应该有各种分组，每个分组每个用户都有不同的权限，如果这样，再在视图函数里进行控制基本上是不可能 2.比较好的权限管理方案假如说我们在代码里做三张表（Mysql，Redis，配置文件），每一张表都记录着某一种权限，现在假如某一个请求过来了。当用户访问@auto.login的接口的话，他必须要带有一个token令牌中的，而我们是可以从token中读取到当前的权限种类的，并且我们是可以知道他所访问的接口的。我们可以拿权限种类和接口做匹配，然后来做判断。 这样做还有一个很好的优势，是我们可以在进入方法前进行权限判断，如果不能够访问根本就不会进入该方法。 7.3 Scope权限管理的实现遇到的坑用的之前生成的token，当时token并没有写入scope,所以报错重新生成就好了。 1.编码实现根据上一小节的编写，我们来动手编写权限管理方案 1.1 scope配置app/libs/scope.py1234567891011121314class AdminScope: allow_api = [&apos;v1.super_get_user&apos;] # 因为是注册在Blueprint上，所以endpoint 前缀为 v1 class UserScope: allow_api = [&apos;v1.get_user&apos;] # 判断当前访问的endpoint是否在scope中def is_in_scope(scope, endpoint): # 反射获取类 scope = globals()[scope]() # globals使用类的名字动态创建对象 if endpoint in scope.allow_api: return True else: return False 1.2 生成令牌app/models/user.py1234567@staticmethoddef verify(email, password): user = User.query.filter_by(email=email).first_or_404() # 查询出当前用户 if not user.check_password(password): # 检验密码 raise AuthFailed() #抛出异常 scope = &apos;AdminScope&apos; if user.auth == 2 else &apos;UserScope&apos; # 判断用户作用域，假设只有两个作用域 return &#123;&apos;uid&apos;: user.id,&apos;scope&apos;: scope&#125; #成功，返回uid # 返回scope app/api/v1/token.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546from app.libs.redprint import Redprintfrom flask import current_appfrom app.libs.enums import ClientTypeEnumfrom app.models.user import Userfrom app.validators.forms import ClientFormfrom itsdangerous import TimedJSONWebSignatureSerializer as Serializerfrom flask import jsonifyapi = Redprint(&apos;token&apos;) # 实例化一个Redprint@api.route(&apos;&apos;, methods=[&apos;POST&apos;]) # 路由注册# 返回token的试图函数，这里稍微破坏一下REST的规则，由于登录操作密码安全性较高，使用GET的话会泄漏def get_token(): form = ClientForm().validate_for_api() # 同注册过程，不同client 区分 promise = &#123; ClientTypeEnum.USER_EMAIL: User.verify, #验证 # 在 user中编写 verify # ClientTypeEnum.USER_MINA: __register_user_by_MINA &#125; # 拿到用户信息 identity = promise[form.type.data]( form.account.data, form.secret.data ) # 调用函数生成token expiration = current_app.config[&apos;TOKEN_EXPIRATION&apos;] #过期时间 token = generator_auth_token(identity[&apos;uid&apos;], form.type.data, identity[&apos;scope&apos;], expiration=expiration) t = &#123; &apos;token&apos;: token.decode(&apos;ascii&apos;) # 因为是byte &#125; return jsonify(t), 201 # 返回 json 字典def generator_auth_token(uid, ac_type, scope=None,expiration=7200): &quot;&quot;&quot;生成令牌 ，拿到uid,client类型，权限作用域，过期时间&quot;&quot;&quot; s = Serializer(current_app.config[&apos;SECRET_KEY&apos;],expires_in=expiration) # expires_in 生成令牌的有效期 return s.dumps(&#123; &apos;uid&apos;: uid, &apos;type&apos;: ac_type.value, &apos;scope&apos;: scope &#125;) # 将想写入的信息以字典形式写入令牌 1.3 验证令牌12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 编写一个验证token的装饰器from flask_httpauth import HTTPBasicAuthfrom flask import current_app, g, requestfrom itsdangerous import TimedJSONWebSignatureSerializer as Serializer, BadSignature, \ SignatureExpiredfrom collections import namedtuplefrom app.libs.erro_code import AuthFailed, Forbiddenfrom app.libs.scope import is_in_scopeauth = HTTPBasicAuth()User = namedtuple(&apos;User&apos;, [&apos;uid&apos;, &apos;ac_type&apos;, &apos;scope&apos;])# @auth.verify_password# def verify_password(account, password):# # 需要在HTTP请求的头部设置一个固定的键值对# # key=Authorization,value=basic base64(account:psd)# # imwl@live.com:12345678 编码后 aW13bEBsaXZlLmNvbToxMjM0NTY3OA==# # key=Authorization,value=basic aW13bEBsaXZlLmNvbToxMjM0NTY3OA==# return True@auth.verify_passworddef verify_password(token, password): user_info = verify_auth_token(token) # token 赋值给 user_info if not user_info: return False else: g.user = user_info # g 变量 ,代理模式 return Truedef verify_auth_token(token): s = Serializer(current_app.config[&apos;SECRET_KEY&apos;]) try: data = s.loads(token) # 解密 token # token不合法抛出的异常 except BadSignature: raise AuthFailed(msg=&apos;token is valid&apos;, erro_code=1002) # token过期抛出的异常 except SignatureExpired: raise AuthFailed(msg=&apos;token is expired&apos;, erro_code=1003) uid = data[&apos;uid&apos;] ac_type = data[&apos;type&apos;] # 生成令牌的时候写入了 uid ac_type scope = data[&apos;scope&apos;] # 也可在这拿到当前request的视图函数 allow = is_in_scope(scope ,request.endpoint) # request.endpoint 拿到当前视图函数的endpoint 判断是否有权限。 if not allow: raise Forbidden() return User(uid, ac_type, scope) # 定义对象式 接口返回回去 ,scope 先返回为空字符串 7.4 Scope优化1.支持权限相加假如我们的UserScope的权限是A，B，C。而AdminScope的权限是A，B，C，D。按照我们的写法，我们的A，B，C就需要些两遍。况且这只是一个简单的例子，实际情况下会更复杂。所以我们需要实现一种方法，可以让AdminScope的allow_api可以和UserScope的allow_api相加得到新的allow_api。 1234567891011class UserScope: allow_api = [&apos;v1.A&apos;,&apos;v1.B&apos;]class SuperScope: # 相加操作 allow_api = [&apos;v1.C&apos;,&apos;v1.D&apos;] def __init__(self): self.add(UserScope())# 这个方法可以将其他的Scope合并到当前Scope。省去重复代码的编写 def add(self, other): self.allow_api = self.allow_api + other.allow_api 2.支持权限链式相加现在我们只能讲AdminScope和UserScope的权限相加，如果还想再加上其他的Scope，就需要链式的操作12345678910111213141516class AdminScope: allow_api = [&apos;v1.super_get_user&apos;] # 因为是注册在Blueprint上，所以endpoint 前缀为 v1 class UserScope: allow_api = [&apos;v1.A&apos;,&apos;v1.B&apos;]class SuperScope: # 相加操作 allow_api = [&apos;v1.C&apos;,&apos;v1.D&apos;] def __init__(self): self.add(UserScope()).add(AdminScope()) def add(self, other): self.allow_api = self.allow_api + other.allow_api return self # 将self return不然第二段调用为None.add(),报错 3.所有子类支持相加add方法不应该写在具体的Scope类中，因为这样就只有当前Scope类有该功能了。应该将add方法写在基类Scope中1234567891011121314151617181920212223242526class Scope: allow_api = [] def add(self, other): self.allow_api = self.allow_api + other.allow_api return selfclass AdminScope(Scope): allow_api = [&apos;v1.super_get_user&apos;] # 因为是注册在Blueprint上，所以endpoint 前缀为 v1 def __init__(self): self.add(UserScope())class UserScope(Scope): allow_api = [&apos;v1.A&apos;,&apos;v1.B&apos;]class SuperScope(Scope): # 相加操作 allow_api = [&apos;v1.C&apos;,&apos;v1.D&apos;] def __init__(self): self.add(UserScope()).add(AdminScope()) # 重复问题，得去重SuperScope为[&apos;v1.C&apos;, &apos;v1.D&apos;, &apos;v1.A&apos;, &apos;v1.B&apos;, &apos;v1.super_get_user&apos;, &apos;v1.A&apos;, &apos;v1.B&apos;]# 要是能直接相加就好了 self + UserScope() + AdminScope() 4.运算符重载现在我们一直使用add()方法，太啰嗦了，我们可以修改我们的代码，使得我们可以使用+号来完成add()方法的功能。 要完成这个功能，就要使用到运算符重载的技术123456789101112131415161718192021222324class Scope: allow_api = [] # def add(self, other):# 运算符重载，支持对象相加操作 def __add__(self, other): self.allow_api = self.allow_api + other.allow_api return selfclass AdminScope(Scope): allow_api = [&apos;v1.super_get_user&apos;] # 因为是注册在Blueprint上，所以endpoint 前缀为 v1 def __init__(self): self + UserScope()class UserScope(Scope): allow_api = [&apos;v1.A&apos;,&apos;v1.B&apos;]class SuperScope(Scope): # 相加操作 allow_api = [&apos;v1.C&apos;,&apos;v1.D&apos;] def __init__(self): self + UserScope() + AdminScope() 5.去重我们现在的scope，编写完成之后，由于可能会连续相加，会有很多重复的试图函数，如SuperScope()中会出现两次v1.A,现在我们就需要将这些重复的试图函数去除掉。我们只需要使用set这个数据结构，就可以完成。12345678class Scope: allow_api = [] # def add(self, other):# 运算符重载，支持对象相加操作 def __add__(self, other): self.allow_api = self.allow_api + other.allow_api self.allow_api = list(set(self.allow_api)) # 先转化为set，后转为list 从而去重 return self 也可以直接定义的时候，就定义成集合,例如：allow_api = {&#39;v1.C&#39;,&#39;v1.D&#39;} 以上全部代码1234567891011121314151617181920212223242526272829303132333435class Scope: allow_api = [] # def add(self, other):# 运算符重载，支持对象相加操作 def __add__(self, other): self.allow_api = self.allow_api + other.allow_api self.allow_api = list(set(self.allow_api)) # 先转化为set，后转为list 从而去重 return selfclass AdminScope(Scope): allow_api = [&apos;v1.super_get_user&apos;] # 因为是注册在Blueprint上，所以endpoint 前缀为 v1 def __init__(self): self + UserScope()class UserScope(Scope): allow_api = [&apos;v1.A&apos;,&apos;v1.B&apos;]class SuperScope(Scope): # 相加操作 allow_api = [&apos;v1.C&apos;,&apos;v1.D&apos;] def __init__(self): self + UserScope() + AdminScope() # 判断当前访问的endpoint是否在scope中def is_in_scope(scope, endpoint): # 反射获取类 scope = globals()[scope]() # globals使用类的名字动态创建对象 if endpoint in scope.allow_api: return True else: return False 6.模块级别的Scope现在我们的Scope都是试图函数级别的，加入我们的user下面有100个试图函数，我们就需要把这100个全都加入进来，我们可以想办法，让我们的Scope支持可以添加一个模块下的视图函数。 我们可以添加一个变量，allow_moudle，来标示允许通过的模块。然后现在我们的is_in_scope只是简单的判断endpoint是否在scope.allow_api中，endpoint默认的形式是blueprint.view_func 的形式，我们可以自定义endpoint为blueprint.moudle_name+view_func这样的形式，这样我们我们就可以在is_in_scope进行模块的判断 修改红图的注册：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Scope: allow_api = [] allow_moudle = [] # def add(self, other):# 运算符重载，支持对象相加操作 def __add__(self, other): self.allow_api = self.allow_api + other.allow_api self.allow_api = list(set(self.allow_api)) # 先转化为set，后转为list 从而去重 return selfclass AdminScope(Scope): allow_api = [&apos;v1.super_get_user&apos;] # 因为是注册在Blueprint上，所以endpoint 前缀为 v1 def __init__(self): self + UserScope()class UserScope(Scope): allow_api = [&apos;v1.A&apos;,&apos;v1.B&apos;]class SuperScope(Scope): # 相加操作 allow_api = [&apos;v1.C&apos;,&apos;v1.D&apos;] allow_moudle = [&apos;v1.user&apos;] def __init__(self): self + UserScope() + AdminScope() # def add(self, other): # self.allow_api = self.allow_api + other.allow_api # return self # 将self return不然第二段调用为None.add(),报错# 提取到基类中，每个都继承这个基类 # 判断当前访问的endpoint是否在scope中def is_in_scope(scope, endpoint): # 反射获取类 scope = globals()[scope]() # globals使用类的名字动态创建对象 splits = endpoint.split(&apos;+&apos;) red_name = splits[0] if endpoint in scope.allow_api: return True # v1.view_func 改为v1.moudle_name+view_func # 改写endpoint # 从Redprint 入手 v1.red_name +view_func &apos;&apos;&apos; 从 endpoint = options.pop(&quot;endpoint&quot;, f.__name__) 改为 endpoint = self.name + &apos;+&apos; + options.pop(&quot;endpoint&quot;, f.__name__) # 改成Redprint+视图函数名字 &apos;&apos;&apos; if red_name in scope.allow_moudle: return True else: return False 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Scope: allow_api = [] allow_moudle = [] # def add(self, other):# 运算符重载，支持对象相加操作 def __add__(self, other): self.allow_api = self.allow_api + other.allow_api self.allow_api = list(set(self.allow_api)) # 先转化为set，后转为list 从而去重 self.allow_moudle = self.allow_moudle + other.allow_moudle self.allow_moudle = list(set(self.allow_moudle)) # 模块级别的相加操作 return selfclass AdminScope(Scope): allow_api = [&apos;v1.user+super_get_user&apos;,&apos;v1.user+super_delete_user&apos;] # 因为是注册在Blueprint上，所以endpoint 前缀为 v1 # allow_moudle = [&apos;v1.user&apos;] def __init__(self): self + UserScope()class UserScope(Scope): allow_api = [&apos;v1.user+get_user&apos;,&apos;v1.user+delete_user&apos;]# class SuperScope(Scope): # 相加操作# allow_api = [&apos;v1.C&apos;,&apos;v1.D&apos;]# allow_moudle = [&apos;v1.user&apos;]# def __init__(self):# self + UserScope() + AdminScope() # def add(self, other): # self.allow_api = self.allow_api + other.allow_api # return self # 将self return不然第二段调用为None.add(),报错# 提取到基类中，每个都继承这个基类 # 判断当前访问的endpoint是否在scope中def is_in_scope(scope, endpoint): # 反射获取类 scope = globals()[scope]() # globals使用类的名字动态创建对象 splits = endpoint.split(&apos;+&apos;) red_name = splits[0] if endpoint in scope.allow_api: return True # v1.view_func 改为v1.moudle_name+view_func # 改写endpoint # 从Redprint 入手 v1.red_name +view_func &apos;&apos;&apos; 从 endpoint = options.pop(&quot;endpoint&quot;, f.__name__) 改为 endpoint = self.name + &apos;+&apos; + options.pop(&quot;endpoint&quot;, f.__name__) # 改成Redprint+视图函数名字 &apos;&apos;&apos; if red_name in scope.allow_moudle: return True else: return False 模块级别的权限控制一定得特别注意 7.支持排除如果一个模块又100个视图函数，UserScope需要访问98个，AdminScope需要访问所有，那么UserScope的编写就太麻烦了，我们可以让我们的Scope 支持排除操作，这样UserScope就可以添加AdminScope的全部，然后再排除掉他不能访问的两个就好了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Scope: allow_api = [] allow_moudle = [] forbidden = [] # def add(self, other):# 运算符重载，支持对象相加操作 def __add__(self, other): self.allow_api = self.allow_api + other.allow_api self.allow_api = list(set(self.allow_api)) # 先转化为set，后转为list 从而去重 self.allow_moudle = self.allow_moudle + other.allow_moudle self.allow_moudle = list(set(self.allow_moudle)) # 模块级别的相加操作 self.forbidden = self.forbidden + other.forbidden self.forbidden = list(set(self.forbidden)) return selfclass AdminScope(Scope): # allow_api = [&apos;v1.user+super_get_user&apos;,&apos;v1.user+super_delete_user&apos;] # 因为是注册在Blueprint上，所以endpoint 前缀为 v1 allow_moudle = [&apos;v1.user&apos;] # def __init__(self): # self + UserScope()class UserScope(Scope): forbidden = [&apos;v1.user+super_get_user&apos;,&apos;v1.user+super_delete_user&apos;] # allow_api = [&apos;v1.user+get_user&apos;,&apos;v1.user+delete_user&apos;] def __init__(self): self + AdminScope()# class SuperScope(Scope): # 相加操作# allow_api = [&apos;v1.C&apos;,&apos;v1.D&apos;]# allow_moudle = [&apos;v1.user&apos;]# def __init__(self):# self + UserScope() + AdminScope() # def add(self, other): # self.allow_api = self.allow_api + other.allow_api # return self # 将self return不然第二段调用为None.add(),报错# 提取到基类中，每个都继承这个基类 # 判断当前访问的endpoint是否在scope中def is_in_scope(scope, endpoint): # 反射获取类 scope = globals()[scope]() # globals使用类的名字动态创建对象 splits = endpoint.split(&apos;+&apos;) red_name = splits[0] if endpoint in scope.forbidden: # 排除 return False if endpoint in scope.allow_api: return True # v1.view_func 改为v1.moudle_name+view_func # 改写endpoint # 从Redprint 入手 v1.red_name +view_func &apos;&apos;&apos; 从 endpoint = options.pop(&quot;endpoint&quot;, f.__name__) 改为 endpoint = self.name + &apos;+&apos; + options.pop(&quot;endpoint&quot;, f.__name__) # 改成Redprint+视图函数名字 &apos;&apos;&apos; if red_name in scope.allow_moudle: return True else: return False# 首先判断是否在要排除的列表里]]></content>
      <categories>
        <category>flask-api</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask构建可扩展的RESTful-API-8--补充完善]]></title>
    <url>%2Fflask-api%2FFlask%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84RESTful-API-8--%E8%A1%A5%E5%85%85%E5%AE%8C%E5%96%84%2F</url>
    <content type="text"><![CDATA[会报内置错误，因为在body中指定了json格式。可以更改为slient模式 app\validators\base.py1234567891011121314151617181920from wtforms import Formfrom app.libs.erro_code import ParameterExceptionfrom flask import request,jsonifyclass BaseForm(Form): # def __init__(self, data): def __init__(self): # data = request.json data = request.get_json(silent = True) # 出现错误，不报异常 args = request.args.to_dict() # 完成查询参数的获取 super(BaseForm, self).__init__(data=data,**args) # 调用父类构造函数 def validate_for_api(self): valid = super(BaseForm, self).validate() # 调用父类的构造方法 # 验证是否通过 if not valid: # 没通过 # 所有异常类信息在form errors 中 raise ParameterException(msg=self.errors) # 抛出异常 # 公共的自定义异常类 return self 搜索界面不需要返回全部字段，详情页面则返回全部字段。可以在app\modles\book.py中隐藏12345678910111213141516171819202122232425262728293031from sqlalchemy import Column, String, Integer, ormfrom app.models.base import Baseclass Book(Base): id = Column(Integer, primary_key=True, autoincrement=True) title = Column(String(50), nullable=False) author = Column(String(30), default=&apos;未名&apos;) binding = Column(String(20)) publisher = Column(String(50)) price = Column(String(20)) pages = Column(Integer) pubdate = Column(String(20)) isbn = Column(String(15), nullable=False, unique=True) summary = Column(String(1000)) image = Column(String(50)) fields = [&apos;id&apos;, &apos;title&apos;, &apos;author&apos;, &apos;binding&apos;, &apos;publisher&apos;, &apos;price&apos;,&apos;pages&apos;, &apos;pubdate&apos;, &apos;isbn&apos;, &apos;summary&apos;, &apos;image&apos;] def keys(self): return self.fields def hide(self,key): self.fields.remove(key) return self 第一次能够隐藏成功，而第二次会受到第一次的影响从而隐藏失败因为改动的是类变量改动如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from sqlalchemy import Column, String, Integer, ormfrom app.models.base import Baseclass Book(Base): id = Column(Integer, primary_key=True, autoincrement=True) title = Column(String(50), nullable=False) author = Column(String(30), default=&apos;未名&apos;) binding = Column(String(20)) publisher = Column(String(50)) price = Column(String(20)) pages = Column(Integer) pubdate = Column(String(20)) isbn = Column(String(15), nullable=False, unique=True) summary = Column(String(1000)) image = Column(String(50)) # fields = [&apos;id&apos;, &apos;title&apos;, &apos;author&apos;, &apos;binding&apos;, # &apos;publisher&apos;, # &apos;price&apos;,&apos;pages&apos;, &apos;pubdate&apos;, &apos;isbn&apos;, # &apos;summary&apos;, # &apos;image&apos;] &apos;&apos;&apos; 第一次能够隐藏成功，而第二次会受到第一次的影响从而隐藏失败。 因为改动的是类变量,改写如下: &apos;&apos;&apos; @orm.reconstructor # 因为通过sqlalchemy创建的构造函数不会被执行，通过这个装饰器构造函数可以执行 # 这就是有追求的啊 def __init__(self): self.fields = [&apos;id&apos;, &apos;title&apos;, &apos;author&apos;, &apos;binding&apos;, &apos;publisher&apos;, &apos;price&apos;,&apos;pages&apos;, &apos;pubdate&apos;, &apos;isbn&apos;, &apos;summary&apos;, &apos;image&apos;] # 定义成实例变量。 def keys(self): return self.fields def hide(self,*keys): # 支持隐藏多个关键字 for key in keys: self.fields.remove(key) return self 并非只有book模型需要隐藏字段，所以可以提取到base基类中,同理，还可以追加append. 1234567891011121314151617181920212223242526from sqlalchemy import Column, String, Integer, ormfrom app.models.base import Baseclass Book(Base): id = Column(Integer, primary_key=True, autoincrement=True) title = Column(String(50), nullable=False) author = Column(String(30), default=&apos;未名&apos;) binding = Column(String(20)) publisher = Column(String(50)) price = Column(String(20)) pages = Column(Integer) pubdate = Column(String(20)) isbn = Column(String(15), nullable=False, unique=True) summary = Column(String(1000)) image = Column(String(50)) @orm.reconstructor def __init__(self): self.fields = [&apos;id&apos;, &apos;title&apos;, &apos;author&apos;, &apos;binding&apos;, &apos;publisher&apos;, &apos;price&apos;,&apos;pages&apos;, &apos;pubdate&apos;, &apos;isbn&apos;, &apos;summary&apos;, &apos;image&apos;] # 定义成实例变量。 app\api\v1\book.py12345678910111213141516171819202122232425262728293031323334from flask import jsonifyfrom sqlalchemy import or_ # 模糊查询 或from app.libs.redprint import Redprintfrom app.models.book import Bookfrom app.validators.forms import BookSearchFormapi=Redprint(&apos;book&apos;)@api.route(&apos;/create&apos;)def create_book(): return &apos;create_book&apos;@api.route(&apos;/get&apos;)def get_book(): return &apos;get book&apos;@api.route(&apos;/search&apos;)def search(): #url http://locahost:5000/v1/book/search?q=&#123;&#125; # request.args.to_dict() 在base中完成 form = BookSearchForm().validate_for_api() # 完成验证 q=&apos;%&apos;+form.q.data+&apos;%&apos; # 模糊搜索前后得加 % # return q books=Book.query.filter(or_(Book.title.like(q),Book.publisher.like(q))).all() #like 指定关键字 q books=[book.hide(&apos;summary&apos;,&apos;id&apos;).append(&apos;pages&apos;) for book in books] # 只 返回指定的 关键字 # 隐藏summary，id.追加pages. return jsonify(books)@api.route(&apos;/&lt;int:isbn&gt;/detail&apos;)def detail(isbn): book=Book.query.filter_by(isbn=isbn).first_or_404() # detail 中可以返回所有字段 return jsonify(book) 新建礼gift模型app\models\gift.py12345678910111213141516from sqlalchemy import Column, String, Boolean, Integer, ForeignKeyfrom sqlalchemy.orm import relationshipfrom app.models.base import Baseclass Gift(Base): id = Column(Integer, primary_key=True) # 建立和user关系 user = relationship(&apos;User&apos;) uid = Column(Integer, ForeignKey(&apos;user.id&apos;)) isbn = Column(String(15), nullable=False) launched = Column(Boolean, default=False) app\api\v1\gift.py12345678910111213141516171819202122232425262728from flask import gfrom app.libs.erro_code import Success, DuplicateGiftfrom app.libs.redprint import Redprintfrom app.libs.token_auth import authfrom app.models.base import dbfrom app.models.book import Bookfrom app.models.gift import Gift# 得去app\api\v1\__init__.py注册到Blueprintapi = Redprint(&apos;gift&apos;) @api.route(&apos;/&lt;isbn&gt;&apos;, methods=[&apos;POST&apos;])@auth.login_requireddef create(isbn): uid = g.user.uid # 拿到当前需要赠送礼物的uid号 with db.auto_commit(): Book.query.filter_by(isbn=isbn).first_or_404() #检测是否是在数据库中 gift = Gift.query.filter_by(isbn=isbn, uid=uid).first() if gift: # 检测是否重复 raise DuplicateGift() gift = Gift() gift.isbn = isbn gift.uid = uid db.session.add(gift) return Success() 为token新增一个接口验证是否过期1234567891011121314151617181920@api.route(&apos;/secret&apos;, methods=[&apos;POST&apos;])def get_token_info(): &quot;&quot;&quot;获取令牌信息&quot;&quot;&quot; form = TokenForm().validate_for_api() s = Serializer(current_app.config[&apos;SECRET_KEY&apos;]) try: data = s.loads(form.token.data, return_header=True) # 不报错就是合法的token except SignatureExpired: raise AuthFailed(msg=&apos;token is expired&apos;, erro_code=1003) except BadSignature: raise AuthFailed(msg=&apos;token is invalid&apos;, erro_code=1002) r = &#123; &apos;scope&apos;: data[0][&apos;scope&apos;], &apos;create_at&apos;: data[1][&apos;iat&apos;], # 创建时间 &apos;expire_in&apos;: data[1][&apos;exp&apos;], # 过期时间 &apos;uid&apos;: data[0][&apos;uid&apos;] &#125; # 把令牌信息读取出来，以明文方式返回到客户端去 # 自定义返回字段，甚至不返回，只提供验证功能 return jsonify(r)]]></content>
      <categories>
        <category>flask-api</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[杂]]></title>
    <url>%2Fflask-api%2F%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>flask-api</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[flask高级编程_鱼书项目_填坑记]]></title>
    <url>%2Fflask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2Fflask%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B_%E9%B1%BC%E4%B9%A6%E9%A1%B9%E7%9B%AE_%E5%A1%AB%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[详细过程可以去我的个人博客上查看，另有flask构建可扩展restful-api过程.个人博客，gitbook 下 本文主要是记录我在鱼书项目遇到的问题很多bug都是因为一点小小的原因导致的，所以以后还得仔细。 1. 数据库表不能添加数据产生场景localhost:2333/register 注册用户信息，提交后出现如下提示: 产生原因自己粗心，之前已经有添加_password,后来又在末尾加了_password,导致数据表生成不了password,所以在/register 注册后，出现bug。 解决过程在数据库user表中查询不到password字段，于是到model/user.py中查看到自己多写了一遍_password 代码，删除后成功。 2. 搜索isbn成功，搜索关键字时失败 产生原因restful 格式 为 search?q= xxx,重构代码后。route修改有问题。 解决过程修改后正常，还是得细心。注意事项chrome 浏览器有缓存，修改后，即使网址 为 .../book/search?q=xxx,也会跳转成.../book/searc/q=xxx导致出错，清空一下浏览数据就可以了。 3. 路由问题产生场景注册后，重定向产生Bug 产生原因flask_login 中的重定向格式为web.login，这一段可能是我输入有误吧。直接给出了解决方案。 解决过程 将web/login 更改为web.login 4. 有关于前端的问题因为最初 的时候，有一段前端代码得注释，当时不熟悉这一块，我还是按照python 中的方法，在前面加#号处理的，结果有问题，后来才发现不应该这样做。很久以前的问题了，当时也没保存，所以没有具体图片。当时的解决方案是把那些要注释掉的前端代码全部删除掉了。 5. flask调试调试端口号默认为5000。localhost:5000，之前没仔细查看，一直在生产模式下调试，还一直进不了断点0.0 6. 新增个人中心 代码如下12345678@web.route(&apos;/personal&apos;)def personal_center(): cur_user = User.query.get_or_404(current_user.id) # 从数据库中查询出当前用户数据 user = cur_user.summary # summary返回一个自定义的字典，详情在user模型下 # b = a.summary return render_template(&apos;personal.html&apos;, user=user) # 网页模板下 因为 user 是一个字典形式，从而得到数据。 7. 新增修改密码之前没有看前端代码，所以password字段有问题，更改后，成功123456789101112@web.route(&apos;/change/password&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])@login_required def change_password(): form = ChangePasswordForm(request.form) if request.method == &apos;POST&apos; and form.validate(): if current_user.check_password(form.old_password.data): current_user.change_password(form.password1.data) flash(&apos;您的密码已重置，请使用新密码登录&apos;) return redirect(url_for(&apos;web.login&apos;)) flash(&apos;密码更改失败&apos;) return render_template(&apos;auth/change_password.html&apos;) 把 前端代码中的原密码改成old_password,新密码，确认新密码改为password1,password2 就可以了。暴露的问题，对前端这一块不熟。 ###8 . 新增API搜索的图书保存的mysql中最初使用的如下方式，一点都不优雅，后更改1234567891011121314151617181920@classmethoddef insert_into_sql(cls, books): for b in books: # 优化后如上 with db.auto_commit(): try: if Book.query.filter_by(isbn=b.isbn).first(): continue book = Book() book.title = b.title book.author = b.author book.binding =b.binding book.publisher = b.publisher book.price = b.price book.pages = b.pages book.isbn = b.isbn book.summary = b.summary book.image = b.image db.session.add(book) except sqlalchemy.exc.DataError: pass 如下：12345678910111213@classmethoddef insert_into_sql(cls, books): # book model 写入 import sqlalchemy for b in books: # books是一个列表，每个元素是一个Book实例化后的对象 # print(111111111111, b.pages) if Book.query.filter_by(isbn=b.isbn).first(): # 因为重复的isbn不能添加 continue with db.auto_commit(): book = Book() book.set_attrs(b.__dict__) # [b1, b2, b3] # 类实例化后的一个对象 b.author b.title db.session.add(book) base模型的部分代码：123456789101112class Base(db.Model): __abstract__ = True create_time = Column(&apos;create_time&apos;,Integer) status = Column(SmallInteger, default=1) def __init__(self): self.create_time = int(datetime.now().timestamp()) def set_attrs(self, attrs_dict): for key, value in attrs_dict.items(): if hasattr(self, key) and key != &apos;id&apos;: setattr(self, key, value) 详细解释这一块，考虑的点特别多。因为从API拿来的数据，并不是很可靠。所以有一些数据为None,或者超出了长度，用以前的代码可能会报错1234567891011121314151617181920212223 def __init__(self, data): self.title = data[&apos;title&apos;] self.author = &apos;、&apos;.join(data[&apos;author&apos;]) self.binding = data[&apos;binding&apos;] self.publisher = data[&apos;publisher&apos;] self.image = data[&apos;image&apos;] # self.price = &apos;￥&apos; + data[&apos;price&apos;] # 因为价格可能为NONE,str不能和NONE相加，会报错。# &apos;￥&apos;去掉，因为api中部分带货币单位 self.price = data[&apos;price&apos;] self.isbn = data[&apos;isbn&apos;] self.pubdate = data[&apos;pubdate&apos;]# summuy长度最多取1000. self.summary = data[&apos;summary&apos;][:1000] if data[&apos;summary&apos;] else &apos;&apos; self.pages = data[&apos;pages&apos;].replace(&apos;页&apos;, &apos;&apos;) if data[&apos;pages&apos;] else None @property def intro(self): intros = filter(lambda x: True if x else False, [self.author, self.publisher, self.price]) return &apos; / &apos;.join(intros) 以上是在view_modles 下book.py做的处理。要细心，多进行代码优化。 web/book.py部分代码12345678910111213141516171819202122232425262728293031323334353637383940414243@web.route(&quot;/book/search&quot;)def search(): &quot;&quot;&quot; 搜索书籍路由 &quot;&quot;&quot; # 实例化我们自定义的SearchForm，需要传入一个字典作为要校验的参数 form = SearchForm(request.args) # validate()方法返回True/False来标示是否校验通过 books = BookCollection() # if not form.validate(): # # errors为错误信息提示（上面定义的message） # flash(&quot;搜索的关键字不符合要求，请重新输入关键字&quot;) # return render_template(&apos;search_result.html&apos;, books=books) # 从form中获取校验后的参数，不从request里拿，#因为我们可能会对数据进行预处理或者默认值的给定 q = form.q.data.strip() page = form.page.data isbn_or_key = is_isbn_or_key(q) yushu_book = YuShuBook() if form.validate(): if isbn_or_key == &apos;isbn&apos;: yushu_book.search_by_isbn(q) books.fill(yushu_book,q) # print(11111, books.books) # for b in books.books: # print(&apos;title&apos;, b.title) # print(&apos;author&apos;, b.author) # result = YuShuBook.search_by_isbn(q) # result = BookViewModel.package_single(result,q) else: yushu_book.search_by_key(q,page) # result = YuShuBook.search_by_keyword(q,page) # result = BookViewModel.package_collection(result,q) # return jsonify(result) books.fill(yushu_book,q) Book.insert_into_sql(books.books) # 搜索的信息保存到SQL中 else: flash(&quot;搜索的关键字不符合要求，请重新输入关键字&quot;) # return jsonify(books) # TypeError: Object of type BookCollection is not JSON serializable # return json.dumps(books, default=lambda o: o.__dict__) return render_template(&apos;search_result.html&apos;, books=books)]]></content>
      <categories>
        <category>flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[flask初识]]></title>
    <url>%2Fflask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2Fflask%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[准备工作 安装 python 环境 检验 python 和 pip 是否安装好（pip是安装python包的工具）(python到官网上下载安装升级，pip更新命令python -m pip install --upgrade pip) 新建项目文件夹 mkdir fisher (安装virtualenv)(虚拟环境可以隔离不同的版本) # 可以直接第五步 安装使用pipnv (pip install pipenv)(全局安装pipenv)(使用pipenv创建一个与项目绑定的虚拟环境。cd fisher 然后pipenv install) ,(pipenv shell进入虚拟环境)。 # pipenv是Python官方推荐的包管理工具。可以说，它集成了virtualenv, pip和pyenv三者的功能。 安装各种包(例如flask :pipenv install flask)##一些常用命令退出虚拟环境exit进入虚拟环境pipenv shell卸载包 eg: pipenv uninstall flask使用pipenv graph命令可以看到依赖树 一些工具开发工具Pycharm(VScode) (Pycharm 在断点调试和自动重启服务器支持较好)Xampp(MySQL)Navicat(数据库可视化管理工具) 第一个flask应用12345678910from flask import Flaskapp = Flask(__name__) #类的实例化@app.route(&apos;/hello&apos;) # 使用 route() 装饰器来告诉 Flask 触发函数的 URL 。 /hello 可以访问#@app.route(&apos;/hello/&apos;) #兼容/ 把/hello 重定向到/hello/def hello(): return &apos;hello world&apos;app.run() route装饰器 ：可以使用Flask应用实例的route装饰器将一个URL规则绑定到 一个视图函数上，优雅方便但不够灵活基于类的视图(即插视图),基于函数的视图 另一种路由注册方式add_url_rule12345678910from flask import Flaskapp = Flask(__name__) def hello1(): return &apos;hello China&apos;app.add_url_rule(&apos;/hello1&apos;,view_func = hello1)app.run() 一般都是用route装饰器，但即插视图，必须使用add_url_rule 运行方式12345#app.run() #直接运行#app.run(debug=True) #开启调试模式#app.run(host=&apos;192.168.2.136&apos;,debug=True) #指定ip地址，仅本机，网卡为192.168.2.136的可访问#app.run(host=&apos;0.0.0.0&apos;,debug=True) #起它ip地址也可以访问#app.run(host=&apos;0.0.0.0&apos;,debug=True,port=1) #改端口 关于端口取值 一般用到的是1到65535,其中0不使用,1-1023为系统端口,也叫BSD保留端口; 1024-65535为用户端口， 又分为: BSD临时端口(1024-5000)和BSD服务器(非特权)端口(5001-65535). 0-1023: BSD保留端口,也叫系统端口,这些端口只有系统特许的进程才能使用; 1024-5000: BSD临时端口,一般的应用程序使用1024到4999来进行通讯; 5001-65535: BSD服务器(非特权)端口,用来给用户自定义端口. 一般的应用程序就是指系统中的ftp，apache，ssh之类的应用程序。而用户自定义的应用程序就是你自己在系统上开发的应用程序。属于你的东西。操作系统不会把它作为一个通用的功能，集成到系统去。 在生产环境下同一个包中另建一个config.py模块,配置如下：12DEBUG = True #配置文件全大写，因为小写的找不到#注意事项: DEBUG默认为False 生产环境下12345678910111213from flask import Flask__author__ = &apos;weilai&apos;app = Flask(__name__) app.config.from_object(&apos;config&apos;)@app.route(&apos;/hello/&apos;)def hello2(): return &apos;hello world&apos;if __name__ == &apos;__main__&apos;: app.run(host=&apos;0.0.0.0&apos;,debug=app.config[&apos;DEBUG&apos;],port=1) 生产环境下使用的是： nginx + uwsgi因为是调用这个模块，所以if name 下面不会运行，这样就不会启用flask内置服务器 视图函数中return与普通函数的区别12345678910111213141516171819202122232425from flask import Flask,make_response #创建response对象__author__ = &apos;weilai&apos;#普通函数的returndef hello1(): return &apos;hello weilai&apos;app = Flask(__name__)app.config.from_object(&apos;config&apos;)@app.route(&apos;/hello&apos;)def hello(): headers = &#123; &apos;content-type&apos;:&apos;text/plain&apos;, #把它当作普通字符串 &apos;location&apos;: &apos;https://www.baidu.com&apos; # 301重定向 #&apos;content-type&apos;: &apos;application/json&apos; #json字符串 #下面response就返回的json字符串 &#125; response = make_response(&apos;&lt;html&gt;&lt;html&gt;&apos;,301) #301是状态码，只是一个标识，不会影响内容 response.headers = headers return response #return &apos;&lt;html&gt;&lt;html&gt;&apos;,301,headers #上面3行也可以这样简写if __name__ == &apos;__main__&apos;: app.run(host=&apos;0.0.0.0&apos;,debug=app.config[&apos;DEBUG&apos;],port=1) 视图函数不仅仅返回字符串，还返回一下 。。 等 #status code 200,404,301 #content-type http headers #content-type = text/html (默认情况) #本质上返回的 Response对象]]></content>
      <categories>
        <category>flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初识鱼书项目]]></title>
    <url>%2Fflask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2F%E5%88%9D%E8%AF%86%E9%B1%BC%E4%B9%A6%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[#定义参数，判断查询参数q是否是isbn号1234567891011121314151617@app.route(&quot;/search/&lt;q&gt;/&lt;page&gt;&quot;)def search(q,page): &quot;&quot;&quot; 搜索书籍路由 :param q: 关键字 OR isbn :param page: 页码 &quot;&quot;&quot; # isbn isbn13 由13个0-9在数字组成 # isbn10 由10表0-9表数字组组成，中间可能包含&apos; - &apos; isbn_or_key = &apos;key&apos; if len(q) == 13 and q.isdigit(): isbn_or_key = &apos;isbn&apos; short_q = q.replace(&apos;-&apos;, &apos;&apos;) if &apos;-&apos; in q and len(short_q) == 10 and short_q.isdigit(): isbn_or_key = &apos;isbn&apos; pass 知识点： 字符串有一个函数isdigit()可以判断是否为数字 in 关键字可以判断一个字符串是否在另一个字符串内 多个逻辑判断排列原则：1.大部分判断结果为假的条件应该放在前面；2.需要查询数据库的操作由于会消耗资源，应该尽量靠后 #简单的重构将上一小节的判断语句全都写到search函数中的几个缺点： 使得代码非常的臃肿，现在只有两个判断就占用了6行，如果有多个判断，search方法就要爆炸了 如果有其他地方的代码也要进行这个判断，那么就需要再重新写一遍，同样的代码重现在了两个地方 代码可读性查，作为一个路由函数，代码阅读者很难一眼看出路由函数的主要功能。 重构后的代码fisher.py12345678@app.route(&quot;/search/&lt;q&gt;/&lt;page&gt;&quot;)def search(q, page): &quot;&quot;&quot; 搜索书籍路由 :param q: 关键字 OR isbn :param page: 页码 &quot;&quot;&quot; isbn_or_key = is_isbn_or_key(q) helper.py123456789101112131415def is_isbn_or_key(word): &quot;&quot;&quot; 判断word是isbn号还是查询关键字key isbn isbn13 由13个0-9在数字组成 isbn10 由10表0-9表数字组组成，中间可能包含&apos; - &apos; :param word: :return: key or isbn &quot;&quot;&quot; isbn_or_key = &apos;key&apos; if len(word) == 13 and word.isdigit(): isbn_or_key = &apos;isbn&apos; short_word = word.replace(&apos;-&apos;, &apos;&apos;) if &apos;-&apos; in word and len(short_word) == 10 and short_word.isdigit(): isbn_or_key = &apos;isbn&apos; return isbn_or_key 知识点： 其他地方的代码多一点还可以接受，视图函数中不可以，因为视图函数是一个web项目的入口。所有人阅读都是从这里入手，应该把细节屏蔽掉，给阅读者一个选择。 看源码的技巧：先通读整体，了解整体过程，再回过头来了解细节，不要从一开始就深究每一个细节 过多的注释会让代码变的臃肿，尽量使用易懂的函数名来代替注释，保持代码的简洁性使用三元表达式优化12345678910111213141516171819import requestsclass HTTP: #class HTTP(object):有无都无所谓 @staticmethod def get(url,return_json=True): r = requests.get(url) if r.status_code == 200: if return_json(): return r.json() else: return r.text else: if return_json: return &#123;&#125; else: return &apos;&apos; 优化后 123456789101112import requestsclass HTTP: #class HTTP(object):有无都无所谓 @staticmethod def get(url,return_json=True): r = requests.get(url) if r.status_code != 200: return &#123;&#125; if return_json else &apos;&apos; #特例情况 return r.json() if return_json else r.text #正常返回 知识点： 简化if-else语句的几种方式 1.使用三元表达式 ；2.if+return；3.将if-else里的代码提取成函数 if+return的理解：把最后一句return前的if+return 全都理解为正常流程之外的一种特例情况的处理；多次if-return，提前结束一些逻辑分支，可以提高代码思维的清晰性 requests的一些说明：1.get()发送get请求；2.返回结果r.status_code 获取返回状态吗；3.r.json()将返回结果序列化成json;4.r.text 将返回结果不做处理直接返回 从API获取数据将具体调用HTTP请求，获取结果的业务代码封装到YuShuBook中123456789101112131415class YuShuBook: search_by_isbn_url = &quot;http://t.yushu.im/v2/book/search/isbn/&#123;&#125;&quot; search_by_key_url = &quot;http://t.yushu.im/v2/book/search?q=&#123;&#125;&amp;count=&#123;&#125;&amp;start=&#123;&#125;&quot; @classmethod def search_by_isbn(cls, isbn): url = cls.search_by_isbn_url.format(isbn) return HTTP.get(url) @classmethod def search_by_key(cls, q, count=15, start=0): url = cls.search_by_key_url.format(q, count, start) return HTTP.get(url) 使用json.dumps 序列表返回结果，在视图函数中进行返回，并声明状态码和返回类型(一个元组)123456789101112@app.route(&quot;/book/search/&lt;q&gt;/&lt;page&gt;&quot;)def search(q, page): &quot;&quot;&quot; 搜索书籍路由 :param q: 关键字 OR isbn :param page: 页码 &quot;&quot;&quot; isbn_or_key = is_isbn_or_key(q) if isbn_or_key == &apos;isbn&apos;: result = YuShuBook.search_by_isbn(q) else: result = YuShuBook.search_by_key(q) return json.dumps(result), 200, {&apos;content-type&apos;: &apos;application/json&apos;} 可以使用flask提供的jsonify替换的json.dumps和元组 return jsonify(result) 2.6 将视图函数拆分到单独的模块中1.将试图函数都放在一个文件中有哪些不足：1.代码太长，不利于维护2.从业务模型抽象的角度，不应该把他们都放在一个文件中。关于书籍相关的API就应该放在书籍模型的视图函数文件中，跟用户相关的API就应该放在用户模型相关的文件中3.入口文件的意义比较独特，会启动web服务器以及做很多初始化的操作，就算要放在一个文件也不应该业务的操作放在入口文件中来 2.尝试拆分模块思路，将试图函数抽离到单独的包中，然后在新的试图文件中引入flask.py来导入app核心对象。为了新的试图文件中的路由可以成功注册，再在flask.py中引入刚刚抽离出的试图模块 修改后的fisher.py 1234567891011from flask import Flask# 为了可以注册book.py中的路由from app.web import bookapp = Flask(__name__)app.config.from_object(&quot;config&quot;)if __name__ == &quot;__main__&quot;:app.run(host=app.config[&quot;HOST&quot;], debug=app.config[&quot;DEBUG&quot;], port=app.config[&quot;PORT&quot;]) 新增的book.py 123456789101112131415161718192021222324from flask import jsonifyfrom helper import is_isbn_or_keyfrom yushu_book import YuShuBook# 为了让book.py模块可以使用app对象from fisher import app__author__ = &quot;gaowenfeng&quot;@app.route(&quot;/book/search/&lt;q&gt;/&lt;page&gt;&quot;)def search(q, page):&quot;&quot;&quot;搜索书籍路由:param q: 关键字 OR isbn:param page: 页码&quot;&quot;&quot;isbn_or_key = is_isbn_or_key(q)if isbn_or_key == &apos;isbn&apos;:result = YuShuBook.search_by_isbn(q)else:result = YuShuBook.search_by_key(q)return jsonify(result) 但是这样做并不是正确的做法，结果表明，这样修改以后，访问search api会404 为了知道为什么这样做不行，我们需要先刨铣一下Flask路由机制的原理 3.Flask路由机制flask的基本思想是内部会维护一个字典。每一个url都会对应一个视图函数，但是不仅仅是这样。每一个url还会对应一个endpoint端点。用于反向构建URL（后面会讲解) flask的路由注册app_url_rule(url=,view_func=,endpoint=)会接受三个参数，前两个我们都知道了，第三个就是上面说的endpoint。他的默认值是view_func的名称。当然，app.route(&#39;url&#39;,endpoint=)也可以传入 flask route的部分源码 12345678910111213141516171819202122232425262728293031323334353637383940414243# 注册路由的装饰器def route(self, rule, **options):def decorator(f):endpoint = options.pop(&apos;endpoint&apos;, None)# 装饰器内部也是调用了add_url_ruleself.add_url_rule(rule, endpoint, f, **options)return freturn decorator# 注册路由@setupmethoddef add_url_rule(self, rule, endpoint=None, view_func=None,provide_automatic_options=None, **options):# 如果endpoint传入的None，则使用视图函数名作为endpointif endpoint is None:endpoint = _endpoint_from_view_func(view_func)options[&apos;endpoint&apos;] = endpointmethods = options.pop(&apos;methods&apos;, None)# 默认的method是GET请求if methods is None:methods = getattr(view_func, &apos;methods&apos;, None) or (&apos;GET&apos;,)if isinstance(methods, string_types):raise TypeError(&apos;Allowed methods have to be iterables of strings, &apos;&apos;for example: @app.route(..., methods=[&quot;POST&quot;])&apos;)methods = set(item.upper() for item in methods).........rule = self.url_rule_class(rule, methods=methods, **options)rule.provide_automatic_options = provide_automatic_options# 将url-&gt;endpoint 的规则维护到url_mapself.url_map.add(rule)if view_func is not None:old_func = self.view_functions.get(endpoint)if old_func is not None and old_func != view_func:raise AssertionError(&apos;View function mapping is overwriting an &apos;&apos;existing endpoint function: %s&apos; % endpoint)# 记录endpoint 所指向的view_funcself.view_functions[endpoint] = view_func 通过端点调试可以发现，Flask内部由url_map 维护一个url-&gt;endpoint 的指向。由view_functions 记录 endpoint所指向视图函数的函数，这样请求进入到Flask内部，才能通过Url找到对应的视图函数 4. 循环引入流程分析从上面的断点调试中发现，我们的url_maph和view_functions中都已经维护了相关的信息。但是为什么还是会出现404的情况，这是因为fisher.py和book.py出现了循环引入的情况。 下面看下fisher.py和book.py的具体流程图 回答流程图中的两个问题：问题1：因为都是由fisher引入book，一个模块只会引入另一个模块一次。所以只执行了一次book问题2：由于一次是主流程执行fisher文件；一次是由book模块导入 fisher。 5.找不到视图函数的最终解释和证明整个流程中，出现了两次核心app对象的初始化，注册路由是在蓝色流程中初始化的app注册的。但是启动服务是红色流程中的app启动的book中注册路由所使用的app对象，是他自己所导入fisher模块的app对象（蓝色流程中），而不是红色主流程中所实例化的app对象下面来加入一些日志出数验证我们的结论。我们在app实例化，启动，注册路由是哪个地方加入日志信息，来观察一下 book.py 12345678910111213141516print(&quot;id为&quot;+str(id(app))+&quot;的app注册路由&quot;)@app.route(&quot;/book/search/&lt;q&gt;/&lt;page&gt;&quot;)def search(q, page):&quot;&quot;&quot;搜索书籍路由:param q: 关键字 OR isbn:param page: 页码&quot;&quot;&quot;isbn_or_key = is_isbn_or_key(q)if isbn_or_key == &apos;isbn&apos;:result = YuShuBook.search_by_isbn(q)else:result = YuShuBook.search_by_key(q)return jsonify(result) fisher.py 1234567891011app = Flask(__name__)print(&quot;id为&quot;+str(id(app))+&quot;的app实例化&quot;)app.config.from_object(&quot;config&quot;)# 为了可以注册book.py中的路由from app.web import bookif __name__ == &quot;__main__&quot;:print(&quot;id为&quot; + str(id(app)) + &quot;的app启动&quot;)app.run(host=app.config[&quot;HOST&quot;], debug=app.config[&quot;DEBUG&quot;], port=app.config[&quot;PORT&quot;]) 执行结果 12345678pydev debugger: process 63816 is connectingid为4350444824的app实例化id为4355159656的app实例化id为4355159656的app注册路由id为4350444824的app启动* Debugger is active!* Debugger PIN: 176-669-651 可以看到注册路由的app，和启动服务的app不是同一个app。并且最后启动的app是最先实例化的app，而注册路由的app是后实例化的app，.]]></content>
      <categories>
        <category>flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows下mysql的安装]]></title>
    <url>%2Fflask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2Fwindows%E4%B8%8Bmysql%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[先去官网下载点击的MySQL的下载：https://dev.mysql.com/downloads/mysql/ 下载完成后解压 配置系统环境变量 复制解压后的mysql到C盘或者其他磁盘下 系统的环境变量的path里添加一个mysql的配置 ，指向mysql的bin目录 配置初始化的my.ini文件的文件解压后的目录并没有的my.ini文件，没关系可以自行创建在安装根目录下添加的my.ini（新建文本文件，将文件类型改为的.ini），写入基本配置： 12345678910111213141516171819202122232425[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=C:\Program Files\MySQL# 设置mysql数据库的数据的存放目录datadir=C:\Program Files\MySQL\Data# 允许最大连接数max_connections=200# 允许连接失败的次数。max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证#mysql_native_passworddefault_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 安装服务在安装时，尽量用管理员身份运行CMD，否则在安装时可能会报错，会导致安装失败的情况。进入CMD直接进入的mysql的目录。在MySQL的安装目录的仓目录下执行命令： mysqld --initialize --console 安装服务mysqld --install, 启动MySQL的服务net start mysql 改密]]></content>
      <categories>
        <category>flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(18) python异常]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常异常的概念 程序在运行时，如果 Python 解释器 遇到 到一个错误，会停止程序的执行，并且提示一些错误信息，这就是 异常 程序停止执行并且提示错误信息 这个动作，我们通常称之为：抛出(raise)异常 程序开发时，很难将 所有的特殊情况 都处理的面面俱到，通过 异常捕获 可以针对突发事件做集中的处理，从而保证程序的 稳定性和健壮性 [图片上传失败…(image-81f29f-1542201966094)] 捕获异常：try except else finally简单的捕获异常语法 在程序开发中，如果 对某些代码的执行不能确定是否正确，可以增加 try(尝试) 来 捕获异常 1234try: 尝试执行的代码except: 出现错误的处理 try 尝试，下方编写要尝试代码，不确定是否能够正常执行的代码 except 如果不是，下方编写尝试失败的代码 简单异常捕获1 —— 要求用户输入整数 12345try: # 提示用户输入一个数字 num = int(input(&quot;请输入数字：&quot;))except: print(&quot;请输入正确的数字&quot;) 错误类型捕获 在程序执行时，可能会遇到 不同类型的异常，并且需要 针对不同类型的异常，做出不同的响应，这个时候，就需要捕获错误类型了 1234567891011try: # 尝试执行的代码 passexcept 错误类型1: # 针对错误类型1，对应的代码处理 passexcept (错误类型2, 错误类型3): # 针对错误类型2 和 3，对应的代码处理 passexcept Exception as result: print(&quot;未知错误 %s&quot; % result) 当 Python 解释器 抛出异常 时，最后一行错误信息的第一个单词，就是错误类型 异常类型捕获2 —— 要求用户输入整数 12345678try: num = int(input(&quot;请输入整数：&quot;)) result = 8 / num print(result)except ValueError: print(&quot;请输入正确的整数&quot;)except ZeroDivisionError: print(&quot;除 0 错误&quot;) 捕获未知错误 在开发时，要预判到所有可能出现的错误，还是有一定难度的 如果希望程序 无论出现任何错误，都不会因为 Python 解释器 抛出异常而被终止，可以再增加一个 except 语法如下： 12except Exception as result: print(&quot;未知错误 %s&quot; % result) 异常捕获完整语法 在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下： 123456789101112131415161718192021try: # 尝试执行的代码 passexcept 错误类型1: # 针对错误类型1，对应的代码处理 passexcept 错误类型2: # 针对错误类型2，对应的代码处理 passexcept (错误类型3, 错误类型4): # 针对错误类型3 和 4，对应的代码处理 passexcept Exception as result: # 打印错误信息 print(result)else: # 没有异常才会执行的代码 passfinally: # 无论是否有异常，都会执行的代码 print(&quot;无论是否有异常，都会执行的代码&quot;) else 只有在没有异常时才会执行的代码 finally 无论是否有异常，都会执行的代码 之前一个演练的 完整捕获异常 的代码如下： 1234567891011121314try: num = int(input(&quot;请输入整数：&quot;)) result = 8 / num print(result)except ValueError: print(&quot;请输入正确的整数&quot;)except ZeroDivisionError: print(&quot;除 0 错误&quot;)except Exception as result: print(&quot;未知错误 %s&quot; % result)else: print(&quot;正常执行&quot;)finally: print(&quot;执行完成，但是不保证正确&quot;) 异常的传递 异常的传递 —— 当 函数/方法 执行 出现异常，会 将异常传递 给 函数/方法 的 调用一方 如果 传递到主程序，仍然 没有异常处理，程序才会被终止 提示： 在开发中，可以在主函数中增加 异常捕获，而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的异常捕获中 这样就不需要在代码中，增加大量的异常捕获，能够保证代码的整洁 123456789101112131415161718&apos;&apos;&apos;需求:1\. 定义函数 `demo1()` **提示用户输入一个整数并且返回**2\. 定义函数 `demo2()` 调用 `demo1()`3\. 在主程序中调用 `demo2()`&apos;&apos;&apos;def demo1(): return int(input(&quot;请输入一个整数：&quot;))def demo2(): return demo1()try: print(demo2())except ValueError: print(&quot;请输入正确的整数&quot;)except Exception as result: print(&quot;未知错误 %s&quot; % result) 抛出异常： raise应用场景 在开发中，除了 代码执行出错 Python 解释器会 抛出 异常之外 还可以根据 应用程序 特有的业务需求 主动抛出异常 示例 提示用户 输入密码，如果 长度少于 8，抛出 异常 [图片上传失败…(image-3d2a0b-1542201966092)] 抛出异常 Python 中提供了一个 Exception 异常类 在开发时，如果满足 特定业务需求时，希望 抛出异常，由其他需要处理的函数捕获异常，可以： 创建 一个 Exception 的 对象 使用 raise 关键字 抛出 异常对象 12345678910111213141516171819202122232425262728&apos;&apos;&apos;**需求*** 定义 `input_password` 函数，提示用户输入密码* 如果用户输入长度 &lt; 8，抛出异常* 如果用户输入长度 &gt;=8，返回输入的密码&apos;&apos;&apos;def input_password(): # 1\. 提示用户输入密码 pwd = input(&quot;请输入密码：&quot;) # 2\. 判断密码长度，如果长度 &gt;= 8，返回用户输入的密码 if len(pwd) &gt;= 8: return pwd # 3\. 密码长度不够，需要抛出异常 # 1&gt; 创建异常对象 - 使用异常的错误信息字符串作为参数 ex = Exception(&quot;密码长度不够&quot;) # 2&gt; 抛出异常对象 raise extry: user_pwd = input_password() print(user_pwd)except Exception as result: print(&quot;发现错误：%s&quot; % result) 参考文章：https://www.jianshu.com/p/ebc19de7a204]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(19) 网络编程]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Python进行网络编程，就是在Python程序本身这个进程内，连接别的服务器进程的通信端口进行通信。 TCP/IP 简介互联网上每个计算机的唯一标识就是IP地址，类似123.123.123.123。如果一台计算机同时接入到两个或更多的网络，比如路由器，它就会有两个或多个IP地址，所以，IP地址对应的实际上是计算机的网络接口，通常是网卡。 IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。 IPv4地址实际上是一个32位整数，以字符串表示的。IP地址如192.168.0.1实际上是把32位整数按8位分组后的数字表示，目的是便于阅读IPv6地址全部长度128位(bit)，每16位为一个双字节。 TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。 socket是电脑网络中进程间数据流的端点 主要分为UDP和TCP两种通信方式 TCP编程Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。 大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。 创建一个基于TCP连接的Socket，可以这样做：1234567# 导入socket库:import socket# 创建一个socket:s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect((&apos;www.baidu.com&apos;, 80)) 创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议，这样，一个Socket对象就创建成功，但是还没有建立连接。 客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。新浪网站的IP地址可以用域名www.sina.com.cn自动转换到IP地址。80端口是Web服务的标准端口。其他服务都有对应的标准端口号，例如SMTP服务是25端口，FTP服务是21端口，等等。端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。 因此，连接新浪服务器的代码如下：1s.connect((&apos;www.baidu.com&apos;, 80)) 注意参数是一个tuple，包含地址和端口号。 建立TCP连接后，我们就可以向百度服务器发送请求，要求返回首页的内容：12# 发送数据:s.send(b&apos;GET / HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: close\r\n\r\n&apos;) TCP连接创建的是双向通道，双方都可以同时给对方发数据。但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。 发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收百度服务器返回的数据了：12345678910# 接收数据:buffer = []while True: # 每次最多接收1k字节: d = s.recv(1024) if d: buffer.append(d) else: breakdata = b&apos;&apos;.join(buffer) 接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。 当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了：12# 关闭连接:s.close() 接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件：123456header, html = data.split(b&apos;\r\n\r\n&apos;, 1)print(header.decode(&apos;utf-8&apos;))# python3.x版本，网络数据的发送接受都是byte类型，需要解码# 把接收的数据写入文件:with open(&apos;baidu.html&apos;, &apos;wb&apos;) as f: f.write(html) 现在，只需要在浏览器中打开这个baidu.html文件，就可以看到百度的首页了。1234567891011121314151617import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((&apos;www.baidu.com&apos;, 80))s.send(b&apos;GET / HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: close\r\n\r\n&apos;)buffer = []while True: d = s.recv(1024) if d: buffer.append(d) else: breakdata = b&apos;&apos;.join(buffer)s.close()header, html = data.split(b&apos;\r\n\r\n&apos;, 1)print(header.decode(&apos;utf-8&apos;))with open(&apos;baidu.html&apos;, &apos;wb&apos;) as f: f.write(html) 服务器和客户端编程相比，服务器编程就要复杂一些。 服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。 所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。 但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。 我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上Hello再发回去。 首先，创建一个基于IPv4和TCP协议的Socket： 1s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。 端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用9999这个端口号。请注意，小于1024的端口号必须要有管理员权限才能绑定： 12# 监听端口:s.bind((&apos;127.0.0.1&apos;, 9999)) 紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量： 12s.listen(5)print(&apos;Waiting for connection...&apos;) 接下来，服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接: 1234567# 不断循环，不断接受数据while True: # 接受一个新连接: sock, addr = s.accept() # 创建新线程来处理TCP连接: t = threading.Thread(target=tcplink, args=(sock, addr)) t.start() 每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接： 12345678910111213def tcplink(sock, addr): print(&apos;Accept new connection from %s:%s...&apos; % addr) sock.send(b&apos;Welcome!&apos;) # 不断接受客服端发来的消息 while True: data = sock.recv(1024) time.sleep(1) if not data or data.decode(&apos;utf-8&apos;) == &apos;exit&apos;: # 退出 break sock.send((&apos;Hello, %s!&apos; % data.decode(&apos;utf-8&apos;)).encode(&apos;utf-8&apos;)) #处理客户端数据 sock.close() print(&apos;Connection from %s:%s closed.&apos; % addr) 连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上Hello再发送给客户端。如果客户端发送了exit字符串，就直接关闭连接。 要测试这个服务器程序，我们还需要编写一个客户端程序： 123456789101112s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect((&apos;127.0.0.1&apos;, 9999))# 接收欢迎消息:print(s.recv(1024).decode(&apos;utf-8&apos;))for data in [b&apos;Michael&apos;, b&apos;Tracy&apos;, b&apos;Sarah&apos;]: # 发送数据: s.send(data) print(s.recv(1024).decode(&apos;utf-8&apos;))s.send(b&apos;exit&apos;)s.close() 我们需要打开两个命令行窗口，一个运行服务器程序，另一个运行客户端程序，就可以看到效果了： 需要注意的是，客户端程序运行完毕就退出了，而服务器程序会永远运行下去，必须按Ctrl+C退出程序。 小结用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，然后，对每一个新的连接，创建一个线程或进程来处理。通常，服务器程序会无限运行下去。 同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。 #UDP 编程 TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。 使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。 虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。 我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口： 123s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 绑定端口:s.bind((&apos;127.0.0.1&apos;, 9999)) 创建Socket时，SOCK_DGRAM指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是不需要调用listen()方法，而是直接接收来自任何客户端的数据： 123456print(&apos;Bind UDP on 9999...&apos;)while True: # 接收数据: data, addr = s.recvfrom(1024) print(&apos;Received from %s:%s.&apos; % addr) s.sendto(b&apos;Hello, %s!&apos; % data, addr) recvfrom()方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用sendto()就可以把数据用UDP发给客户端。 注意这里省掉了多线程，因为这个例子很简单。 客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用connect()，直接通过sendto()给服务器发数据： 1234567s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)for data in [b&apos;Michael&apos;, b&apos;Tracy&apos;, b&apos;Sarah&apos;]: # 发送数据: s.sendto(data, (&apos;127.0.0.1&apos;, 9999)) # 接收数据: print(s.recv(1024).decode(&apos;utf-8&apos;))s.close() 从服务器接收数据仍然调用recv()方法。 仍然用两个命令行分别启动服务器和客户端测试，结果如下： 小结UDP的使用与TCP类似，但是不需要建立连接。此外，服务器绑定UDP端口和TCP端口互不冲突，也就是说，UDP的9999端口与TCP的9999端口可以各自绑定。]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(17) python文件操作]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件文件####文件的概念 计算机的 文件，就是存储在某种 长期储存设备 上的一段 数据 长期存储设备包括：硬盘、U 盘、移动硬盘、光盘… 文件的作用：将数据长期保存下来，在需要的时候使用文件的存储方式：在计算机中，文件是以 二进制 的方式保存在磁盘上的文本文件：可以使用 文本编辑软件 查看，本质上还是二进制文件二进制文件：保存的内容 不是给人直接阅读的，而是 提供给其他软件使用的，例如：图片文件、音频文件、视频文件等等，二进制文件不能使用 文本编辑软件 查看 文件的基本操作操作文件的套路：在 计算机 中要操作文件的套路非常固定，一共包含三个步骤： 打开文件 读、写文件 读 将文件内容读入内存 写 将内存内容写入文件 关闭文件 操作文件的函数/方法在 Python 中要操作文件 序号 函数/方法 说明 01 open 打开文件，并且返回文件操作对象 02 read 将文件内容读取到内存 03 write 将指定内容写入文件 04 close 关闭文件 open 函数负责打开文件，并且返回文件对象read/write/close 三个方法都需要通过 文件对象 来调用 读取文件示例 open 函数的第一个参数是要打开的文件名（文件名区分大小写）如果文件 存在，返回 文件操作对象如果文件 不存在，会 抛出异常 read 方法可以一次性 读入 并 返回 文件的 所有内容 close 方法负责 关闭文件如果 忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问 注意：read 方法执行后，会把 文件指针 移动到 文件的末尾 123456789# 1\. 打开 - 文件名需要注意大小写file = open(&quot;README&quot;)# 2\. 读取text = file.read()print(text)# 3\. 关闭file.close() 提示 在开发中，通常会先编写 打开 和 关闭 的代码，再编写中间针对文件的 读/写 操作！ &lt;补&gt; 文件指针 文件指针 标记 从哪个位置开始读取数据 第一次打开 文件时，通常 文件指针会指向文件的开始位置 当执行了 read 方法后，文件指针 会移动到 读取内容的末尾 默认情况下会移动到 文件末尾 思考：如果执行了一次 read 方法，读取了所有内容，那么再次调用 read 方法，还能够获得到内容吗？答案：不能！第一次读取之后，文件指针移动到了文件末尾，再次调用不会读取到任何的内容。 &lt;补&gt; 打开文件的方式 open 函数默认以 只读方式 打开文件，并且返回文件对象 1f = open(&quot;文件名&quot;, &quot;访问方式&quot;) 访问方式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常 w 以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 a 以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 r+ 以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常 w+ 以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 a+ 以读写方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 提示：频繁的移动文件指针，会影响文件的读写效率，开发中更多的时候会以 只读、只写 的方式来操作文件 写入文件示例 12345678# 打开文件f = open(&quot;README&quot;, &quot;w&quot;)f.write(&quot;hello python！\n&quot;)f.write(&quot;今天天气真好&quot;)# 关闭文件f.close() &lt;补&gt; 按行读取文件内容：readline() read 方法默认会把文件的 所有内容 一次性读取到内存 如果文件太大，对内存的占用会非常严重 readline 方法可以一次读取一行内容 方法执行后，会把 文件指针 移动到下一行，准备再次读取 读取大文件的正确姿势 12345678910111213141516# 打开文件file = open(&quot;README&quot;)while True: # 读取一行内容 text = file.readline() # 判断是否读到内容 if not text: break # 每读取一行的末尾已经有了一个 `\n` print(text, end=&quot;&quot;)# 关闭文件file.close() 复制大文件 打开一个已有文件，逐行读取内容，并顺序写入到另外一个文件 123456789101112131415161718# 1\. 打开文件file_read = open(&quot;README&quot;)file_write = open(&quot;README[复件]&quot;, &quot;w&quot;)# 2\. 读取并写入文件while True: # 每次读取一行 text = file_read.readline() # 判断是否读取到内容 if not text: break file_write.write(text)# 3\. 关闭文件file_read.close()file_write.close() 文件/目录的常用管理操作 在 终端 / 文件浏览器、 中可以执行常规的 文件 / 目录 管理操作，例如： 创建、重命名、删除、改变路径、查看目录内容、…… 在 Python 中，如果希望通过程序实现上述功能，需要 import os 模块 文件管理操作 序号 方法名 说明 示例 01 rename 重命名文件 os.rename(源文件名, 目标文件名) 02 remove 删除文件 os.remove(文件名) 目录管理操作 序号 方法名 说明 示例 01 listdir 目录列表 os.listdir(目录名) 02 mkdir 创建目录 os.mkdir(目录名) 03 rmdir 删除目录 os.rmdir(目录名) 04 getcwd 获取当前目录 os.getcwd() 05 chdir 修改工作目录 os.chdir(目标目录) 06 path.isdir 判断是否是文件 os.path.isdir(文件路径) 提示：文件或者目录操作都支持 相对路径 和 绝对路径 文本文件的编码格式 文本文件存储的内容是基于 字符编码 的文件，常见的编码有 ASCII 编码，UNICODE 编码等 Python 2.x 默认使用 ASCII 编码格式Python 3.x 默认使用 UTF-8 编码格式 ASCII 编码 计算机中只有 256 个 ASCII 字符 一个 ASCII 在内存中占用 1 个字节 的空间 8 个 0/1 的排列组合方式一共有 256 种，也就是 2 ** 8 UTF-8 编码格式 计算机中使用 1~6 个字节 来表示一个 UTF-8 字符，涵盖了 地球上几乎所有地区的文字 大多数汉字会使用 3 个字节 表示 UTF-8 是 UNICODE 编码的一种编码格式 123456789# *-* coding:utf8 *-*# 在字符串前，增加一个 `u` 表示这个字符串是一个 utf8 字符串hello_str = u&quot;你好世界&quot;print(hello_str)for c in hello_str: print(c)]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(13) python中用字典代替switch]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E7%94%A8%E5%AD%97%E5%85%B8%E4%BB%A3%E6%9B%BFswitch%2F</url>
    <content type="text"><![CDATA[switch语句类型12345678910111213&apos;&apos;&apos;switch(n)&#123;case 1: 执行代码块 1 break;case 2: 执行代码块 2 break;default: n 与 case 1 和 case 2 不同时执行的代码&#125;&apos;&apos;&apos; 例如：12345678910111213141516&apos;&apos;&apos;switch (day)&#123;case 0: x=&quot;Today it&apos;s Sunday&quot;; break;case 1: x=&quot;Today it&apos;s Monday&quot;; break;case 2: x=&quot;Today it&apos;s Tuesday&quot;; break;case 3: x=&quot;unknown&quot;&#125;&apos;&apos;&apos; python中字典方式123456789day = 3switcher = &#123; 0:&apos;Today it\&apos;s Sunday&apos;, 1:&apos;Today it\&apos;s Monday&apos;, 2:&apos;Today it\&apos;s Tuesday&apos;&#125;#day_name =switcher[day] #并不能显示defaultday_name = switcher.get(day,&apos;Unknown&apos;)print(day_name) 函数12345678910111213141516171819202122day = 3def get_monday(): return &apos;Monday&apos;def get_sunday(): return &apos;Sunday&apos;def get_tuesday(): return &apos;Tuesday&apos;def get_default(): return &apos;Unknown&apos;switcher1 = &#123; 0:get_sunday, 1:get_monday, 2:get_tuesday&#125; day_name = switcher1.get(day,get_default)()print(day_name)]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(15) python中的None]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E7%9A%84None%2F</url>
    <content type="text"><![CDATA[None 表示空 不同于 空字符串 空的列表 0 False 类型不同，值不同1234567print(type(None)) &lt;class &apos;NoneType&apos;&gt;None是None类a=&apos;&apos;b=Falsec=[]print(a==None) #Falseprint(b==None) #Falseprint(c==None) #False #值不相等 深入123456789101112131415def fun(): return Nonea = fun()if not a: print(&apos;S&apos;)else: print(&apos;F&apos;)if a is None: print(&apos;S&apos;)else: print(&apos;F&apos;)#S#S 123456789101112131415def fun(): return Nonea = []if not a: print(&apos;S&apos;)else: print(&apos;F&apos;)if a is None: print(&apos;S&apos;)else: print(&apos;F&apos;)#S#F 类中默认非空123456789class Test(): passtest = Test()if test: print(&apos;S&apos;)else: print(&apos;F&apos;)#S 类中为空的情况12345678910class Test(): def __len__(self): return 0 #(只能为int类型)test = Test()if test: print(&apos;S&apos;)else: print(&apos;F&apos;)#F 123456789class Test(): def __len__(self): return 0 #(只能为int类型)test = Test()print(bool(None)) #Falseprint(bool(&#123;&#125;))#Falseprint(bool([]))#Falseprint(bool(test))#False 由bool决定True or False,与len无关(即print 只有 bool call True,或者bool call False ))12345678910111213class Test(): def __bool__(self): print(&apos;bool called&apos;) return False#(/True) def __len__(self): print(&apos;len called&apos;) return True #(只能为int类型)print(bool(Test()))#bool called#False#(/True)]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(14) python中的列表推导式]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[#####列表推导式 #####集合字典也可 #####元组也可 1234a=[1,2,3,4,5,6,7,8,9]b=[i**3 for i in a if i &lt;=5]print(b) #b=&#123;....&#125;为集合，b(...)为元组，与a&#123;[(...)]&#125;,什么的无关。#为b()时，是一个对象 也可以map filter表示1234list_a=[1,2,3,4,5,6,7,8,9]r=filter(lambda x:x if x&lt;=5 else 0,list_a)s=map(lambda x:x*x,r)print(list(s)) 12345#同上，不建议list_a=[1,2,3,4,5,6,7,8,9]r=filter(lambda x:x if x&lt;=5 else 0,list_a)s=map(lambda x:x**3,filter(lambda x:x if x&lt;=5 else 0,list_a))print(list(s)) #####当为字典时123456789students =&#123; &apos;wei&apos;:18, &apos;lai&apos;:19, &apos;wan&apos;:20&#125;b = [key for key,value in students.items()]print(b)#[&apos;wei&apos;, &apos;lai&apos;, &apos;wan&apos;]for x in b: print(x)#wei#lai#wan **交换key和value12345678students =&#123; &apos;wei&apos;:18, &apos;lai&apos;:19, &apos;wan&apos;:20&#125;b =&#123;value:key for key,value in students.items()&#125;print(b)#&#123;18: &apos;wei&apos;, 19: &apos;lai&apos;, 20: &apos;wan&apos;&#125;]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(16) python补充]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[1234567num2 = 100sum1 = lambda num1 : num1 + num2 num2 = 10000sum2 = lambda num1 : num1 + num2 print( sum1( 1 ) )#10001print( sum2( 1 ) )#10001 lambda 表达式中的 num2 是一个自由变量，在运行时绑定值，而不是定义时就绑定，这跟函数的默认值参数定义是不同的。打印乘法表占位符12345678910111213#方法1for i in range(1, 10): for j in range(1, i+1): # end=&apos;&apos; 意思是末尾不换行，加空格 print(&apos;&#123;&#125;x&#123;&#125;=&#123;&#125;\t&apos;.format(i, j, i*j), end=&apos;&apos;) print()#方法2for m in range(1, 10): for n in range(1, m+1): print(&apos;%d*%d=%d\t&apos;%(n,m,n*m), end=&apos;&apos;) print() while 与for (待补充) 从键盘获取输入信息：input在 Python 中可以使用 input 函数从键盘等待用户的输入用户输入的 任何内容 Python 都认为是一个 字符串 格式化输出：print如果希望输出文字信息的同时，一起输出 数据，就需要使用到 格式化操作符% 被称为 格式化操作符，专门用于处理字符串中的格式包含 % 的字符串，被称为 格式化字符串% 和不同的 字符 连用，不同类型的数据 需要使用 不同的格式化字符 格式化字符 含义%s 字符串%d 有符号十进制整数，%06d 表示输出的整数显示位数，不足的地方使用 0 补全%f 浮点数，%.2f 表示小数点后只显示两位%% 输出 % 随机数生成1234567import random#导入模块后，可以直接在 模块名称 后面敲一个 . 然后按 Tab 键，会提示该模块中包含的所有函数#random.randint(a, b) ，返回 [a, b] 之间的整数，包含 a 和 brandom.randint(12, 20) # 生成的随机数n: 12 &lt;= n &lt;= 20 random.randint(20, 20) # 结果永远是 20 random.randint(20, 10) # 该语句是错误的，下限必须小于上限。 随机数的小游戏 12345678910111213141516171819202122232425262728import random# 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3）player = int(input(&quot;请输入您要出的拳 石头（1）／剪刀（2）／布（3）：&quot;))# 电脑 随机 出拳 —— 先假定电脑只会出石头，完成整体代码功能computer = random.randint(1, 3)print(&quot;玩家选择的拳头是 %d - 电脑出的拳是 %d&quot; % (player, computer))# 比较胜负# 1 石头 胜 剪刀# 2 剪刀 胜 布# 3 布 胜 石头# if (()# or ()# or ()):if ((player == 1 and computer == 2) or (player == 2 and computer == 3) or (player == 3 and computer == 1)): print(&quot;欧耶，电脑弱爆了！&quot;)# 平局elif player == computer: print(&quot;真是心有灵犀啊，再来一盘&quot;)# 其他的情况就是电脑获胜else: print(&quot;不服气，我们决战到天明！&quot;) 12345678910111213141516import randomguess_list = [&quot;石头&quot;, &quot;剪刀&quot;, &quot;布&quot;]win_combination = [[&quot;布&quot;, &quot;石头&quot;], [&quot;石头&quot;, &quot;剪刀&quot;], [&quot;剪刀&quot;, &quot;布&quot;]]while True: computer = random.choice(guess_list) people = input(&apos;请输入：石头,剪刀,布\n&apos;).strip() if people not in guess_list: continue elif computer == people: print (&quot;平手，再玩一次！&quot;) elif [computer, people] in win_combination: print (&quot;电脑获胜，再玩，人获胜才能退出！&quot;) else: print (&quot;人获胜！&quot;) break 函数1234567891011121314151617181920def print_code(code): print(code) #return Noneprint_code(&apos;python&apos;) # pythondef add(x,y): result=x+y return resulta = add(1,2)print(a) # 3def add1(x,y): result = x + y print(result)add1(1,2) # 3def add2(x,y): result = x + y print(&apos;%d + %d = %d&apos;%(x,y,x+y))add2(1,2) # 1 + 2 = 3 ####多值参数有时可能需要 一个函数 能够处理的参数 个数 是不确定的，这个时候，就可以使用 多值参数。 python 中有 两种 多值参数： 参数名前增加 一个 * 可以接收 元组参数名前增加 两个 ** 可以接收 字典 一般在给多值参数命名时，习惯使用以下两个名字 args —— 存放 元组 参数，前面有一个 kwargs —— 存放 字典 参数，前面有两个 123456789101112131415161718192021def demo(num, *args, **kwargs): print(num) print(args) print(kwargs)demo(1, 2, 3, 4, 5, name=&quot;小明&quot;, age=18, gender=True)#1#(2, 3, 4, 5)#&#123;&apos;name&apos;: &apos;小明&apos;, &apos;age&apos;: 18, &apos;gender&apos;: True&#125;demo(1,(2,3,4,5),&#123;&quot;name&quot;:&quot;小明&quot;, &quot;age&quot;:18, &quot;gender&quot;:True&#125;)#1#((2, 3, 4, 5), &#123;&apos;name&apos;: &apos;小明&apos;, &apos;age&apos;: 18, &apos;gender&apos;: True&#125;)#&#123;&#125;demo(1,(2,3,4,5), name=&quot;小明&quot;, age=18, gender=True)#1#((2, 3, 4, 5),)#&#123;&apos;name&apos;: &apos;小明&apos;, &apos;age&apos;: 18, &apos;gender&apos;: True&#125; 元组和字典的拆包在调用带有多值参数的函数时，如果希望：将一个 元组变量，直接传递给 args将一个 字典变量，直接传递给 kwargs就可以使用 拆包，简化参数的传递，拆包 的方式是：在 元组变量前，增加 一个 在 字典变量前，增加 两个 12345678910111213141516def demo(*args, **kwargs): print(args) print(kwargs)# 需要将一个元组变量/字典变量传递给函数对应的参数gl_nums = (1, 2, 3)gl_xiaoming = &#123;&quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 18&#125;# 会把 num_tuple 和 xiaoming 作为元组传递个 argsdemo(gl_nums, gl_xiaoming)#((1, 2, 3), &#123;&apos;name&apos;: &apos;小明&apos;, &apos;age&apos;: 18&#125;)#&#123;&#125;demo(*gl_nums, **gl_xiaoming)#(1, 2, 3)#&#123;&apos;name&apos;: &apos;小明&apos;, &apos;age&apos;: 18&#125; 函数的返回值12# Python 专有，利用元组交换两个变量的值a, b = b, a #面向对象(补充)]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(10) python中的枚举]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[在python中，枚举的本质是一个类，所有枚举类都是Enum的子类枚举值不能动态更改且标签唯一，标签唯一但是数值不唯一。如果数值不唯一，相当于起别名 表示类型的三种方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101from enum import Enumclass VIP(Enum): #所有枚举类都是Enum的子类 YELLOW = 1 #常量是不能更改的 用大写表示（约定的，python中没有真的常量） GREEN = 2 RED = &apos;str&apos; BLACK = 4 PINK = 1 # 其实就是YELLOW = 1， 可以看作YELLOW 的别名， #YELLOW = 1 #会报错，不能同时有两个YELLOW Attempted to reuse key: &apos;YELLOW&apos; # GREEN = 6 #会报错，不能继续使用GREEN这个标签 Attempted to reuse key: &apos;GREEN&apos;#class Common(): # YELLOW = 1 #VIP.YELLOW =6 #会报错，枚举中的值不能被更改print(VIP.PINK)print(VIP.YELLOW) #VIP.YELLOW (不关心取值)print(VIP.PINK) #VIP.YELLOW 可以看作YELLOW 的别名print(type(VIP.YELLOW)) #&lt;enum &apos;VIP&apos;&gt; 枚举类型print(VIP.YELLOW.name) #YELLOW 获取标签名字print(type(VIP.YELLOW.name)) #&lt;class &apos;str&apos;&gt; 字符串类型print(VIP[&apos;YELLOW&apos;]) #VIP.YELLOWprint(VIP.YELLOW.value) #1 获取值#枚举类型、枚举的名字、枚举的值for v in VIP: #遍历枚举类型(并不会把别名打印出来) print(v) #VIP.YELLOW #VIP.GREEN #VIP.RED #VIP.BLACK #枚举的比较运算#枚举不可以进行大小比较，但可以进行等值比较，身份比较result = VIP.YELLOW == VIP.PINK #枚举之间的等值比较 #Trueresult1 = VIP.YELLOW == 1 #False#result = VIP.YELLOW &gt;= VIP.PINK #枚举不能进行大小比较报错 #&apos;&gt;=&apos; not supported between instances of &apos;VIP&apos; and &apos;VIP&apos;result2 = VIP.YELLOW is VIP.PINK #True 身份比较print(result) print(result1)print(result2) class VIP1(Enum): YELLOW = 1 GREEN = 2 RED = &apos;3&apos; BLACK = 4 PINK = 1result = VIP.YELLOW == VIP1.YELLOW #Fales 虽然值相等，但其实是两个不同的枚举类型print(result) for v in VIP.__members__.items(): #遍历枚举类型(把别名也打印出来) print(v)&apos;&apos;&apos;(&apos;YELLOW&apos;, &lt;VIP.YELLOW: 1&gt;)(&apos;GREEN&apos;, &lt;VIP.GREEN: 2&gt;)(&apos;RED&apos;, &lt;VIP.RED: 3&gt;)(&apos;BLACK&apos;, &lt;VIP.BLACK: 4&gt;)(&apos;PINK&apos;, &lt;VIP.YELLOW: 1&gt;)&apos;&apos;&apos;for v in VIP.__members__: print(v) #枚举的名字（包括别名）&apos;&apos;&apos;YELLOWGREENREDBLACKPINK&apos;&apos;&apos;a = 1a = VIP(a) #把a变成一个枚举类型print(a) #VIP.YELLOW from enum import IntEnum #(枚举的值得是int类型)from enum import IntEnum,unique #(枚举的值得是int类型,且不能重复)class VIP2(IntEnum): YELLOW = 1 GREEN = 2 # RED = &apos;str&apos; #会报错,(枚举的值得是int类型) BLACK = 4 PINK = 1 @uniqueclass VIP3(IntEnum): YELLOW = 1 GREEN = 2 # RED = &apos;str&apos; #会报错,(枚举的值得是int类型) BLACK = 4 # PINK = 1 #会报错,取值重复#枚举 是单例模式 #23种设计模式 实践中]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(9) python之闭包]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B9%8B%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包闭包 = 函数 + 环境变量(函数定义的时候) 一个最简单的闭包1234567def curve_pre(): def curve(): print(&apos;This is a function&apos;) return curvef = curve_pre()f() #This is a function 闭包不受外部变量影响1234567891011121314def curve_pre1(): a = 25 def curve1(x): return a*x**2 return curve1#闭包 = 函数 + 环境变量(函数定义的时候)a = 20 #全局变量f1 = curve_pre1()print(f1.__closure__) #(&lt;cell at 0x00000216457D06D8: int object at 0x00007FFEF75AD720&gt;,)实质返回了一个闭包print(f1.__closure__[0].cell_contents) #25 取出环境变量f1(2) print(f1(2)) #100 调用时 a 取 25 非闭包1234567891011121314def f2(): a = 10 def f3(): #a(=20)被python 认为是一个局部变量,没有引用上面的a(=10)(环境变量)就不是闭包了 a = 20 print(a) print(a) f3() print(a)f2()#首先运行f2() ,a=10，print(a)即为10#然后运行f3() ,a=20，print(a)即为20，此时a为f3()中的局部变量#最后print(a)即为10 闭包12345678910def f4(): a = 10 def f5(): c = 20 * a #调用了 a=10 return f5f = f4()print(f) #&lt;function f4.&lt;locals&gt;.f5 at 0x0000015AF4F479D8&gt;print(f.__closure__)#(&lt;cell at 0x0000015AF4ED06D8: int object at 0x00007FFC0F54D540&gt;,) 闭包 只是一种思维方式，函数式编程 闭包可以记忆上次调用的状态 例题，origin 最初为0，累加计算12345678910111213141516171819#闭包模式origin = 0def factory(pos): def go(step): nonlocal pos #pos不是本地局部变量 new_pos = pos +step pos = new_pos return new_pos return gotourist = factory(origin) #初始化为 0print(tourist(2)) #即step为2print(tourist.__closure__[0].cell_contents)#取环境变量#2记住了调用的值print(tourist(3))print(tourist.__closure__[0].cell_contents)#5print(tourist(5))print(tourist.__closure__[0].cell_contents)#10print(origin) #0 使用闭包，并没有改变全局变量,所有操作都在函数内部 1234567891011121314#非闭包origin = 0def go(step): global origin #定义一个全局变量 new_pos = origin + step origin = new_pos return new_posprint(go(2))#2print(origin)#2 #改变了全局变量的值print(go(3))#5print(origin)#5print(go(5))#10print(origin)#10 1234567891011121314#面向对象编程class Tourist(): origin = 0 def pos(self,new_pos): self.origin += new_postourist=Tourist()print(tourist.origin)tourist.pos(2)print(tourist.origin)tourist.pos(3)print(tourist.origin)tourist.pos(5)print(tourist.origin)]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(11) python之函数式编程]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[函数式编程是一种思维，闭包只是其一种体现 匿名函数12345678#例如 x+y#普通函数def add(x,y): return x+y#匿名函数lambda x,y:x+y 三元表达式12345678# x,y x大于y，取x 否则，取y# x &gt; y ? x:y (其他语言中)# x if x &gt; y else y #python中#条件为真时返回的结果 if 条件判断 else 条件为假时的返回结果 x = 1y = 4r = x if x &gt; y else yprint(r) #4 map类12345678910111213141516list_a = [1,2,3,4,5,6,7,8]def square(x): return x * xr = map(square,list_a)print(r) #&lt;map object at 0x0000026BCECDE9E8&gt;#map类print(list(r)) #[1, 4, 9, 16, 25, 36, 49, 64]#map:将集合里每个元素传到square里去，并且映射到新的集合中#也可以用fordef square1(x): return x * xfor x in list_a: x = square1(x) print(x)#1, 4, 9, 16, 25, 36, 49, 64 map常用方法1234list_a = [1,2,3,4,5,6,7,8]r = map(lambda x:x * x,list_a)print(list(r))#[1, 4, 9, 16, 25, 36, 49, 64] 12345list_a = [1,2,3,4,5,6,7,8]list_b = [1, 4, 9, 16, 25, 36, 49]s = map(lambda x,y:x * x + y,list_a,list_b) #map中传入多个listprint(list(s)) #[2, 8, 18, 32, 50, 72, 98] 长度取决于列表少的那个 reduce 连续计算，连续计算，连续调用lambda12345from functools import reducelist_a = [1,2,3,4,5,6,7,8]r = reduce(lambda x,y:x + y,list_a,10) #初始值为10 #10+1,得到11，11+2,得到13.....等一系列计算print(r) #46 12345#初始值为50，从0累加到99from functools import reducea = range(0,100)r = reduce(lambda x,y:x+y,a,50)print(r) map/reduce编程模型 映射 归纳并行计算函数式编程 filter 过滤1234list_a = [1,1,0,0,1,1,0,1,0]# r = filter(lambda x: True if x==1 else False, list_a)r = filter(lambda x:x,list_a) #因为0代表Falseprint(list(r))]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(12) python中的装饰器]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[对修改是封闭的，对扩展是开放的 ####在原有函数上调用时加时间1234567891011121314import timedef a(): print(&apos;This is a function&apos;) def b(): print(&apos;Hello world&apos;) def print_current_time(abc): print(time.time()) abc()print_current_time(a)print_current_time(b) 等同于12345678910111213141516import timedef a(): print(&apos;This is a function&apos;) def b(): print(&apos;Hello world&apos;) def print_current_time(abc): print(time.time()) abc()print(time.time())a()print(time.time())b() 更改了内部实现，不够优雅 ####装饰器12345678910111213import timedef decorator(func): def wrapper(): print(time.time()) func() return wrapperdef f1(): print(&apos;This is a function&apos;) f = decorator(f1)f() 修改一下 1234567891011121314import timedef decorator(func): def wrapper(): print(time.time()) func() return wrapper@decorator #@装饰器名字def f1(): print(&apos;This is a function&apos;) f1() #并没有改变原有函数的调用方式#这才是装饰器 意义所在 进一步优化，支持不同个数的参数1234567891011121314151617181920import timedef decorator(func): def wrapper(*args): print(time.time()) func(*args) return wrapper@decorator #@装饰器名字def f1(func_name): print(&apos;This is a function&apos;+ func_name) @decoratordef f2(func_name1,func_name2,func_name3): print(&apos;hello world&apos;+ func_name1) print(&apos;hello world&apos;+ func_name2) print(&apos;hello world&apos;+ func_name3) f1(&apos;tset func&apos;) f2(&apos;tset func1&apos;,&apos;tset func2&apos;,&apos;tset func3&apos;) 进一步优化，加入关键字参数12345678910111213141516171819202122232425262728import timedef decorator(func): def wrapper(*args,**kw): print(time.time()) func(*args,**kw) return wrapper@decorator #@装饰器名字def f1(func_name): print(&apos;This is a function&apos;+ func_name) @decoratordef f2(func_name1,func_name2,func_name3): print(&apos;hello world&apos;+ func_name1) print(&apos;hello world&apos;+ func_name2) print(&apos;hello world&apos;+ func_name3) @decoratordef f3(func_name1,func_name2,**kw): print(&apos;hello world&apos;+ func_name1) print(&apos;hello world&apos;+ func_name2) print(kw)f1(&apos;tset func&apos;) f2(&apos;tset func1&apos;,&apos;tset func2&apos;,&apos;tset func3&apos;)f3(&apos;tset func1&apos;,&apos;tset func2&apos;,a = 1,b = 2,c = &apos;123&apos;) 装饰器也可以用来控制访问一个函数上就可以加多个装饰器]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(8) python之初识JSON]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B9%8B%E5%88%9D%E8%AF%86JSON%2F</url>
    <content type="text"><![CDATA[JSON是一种轻量级的数据交换格式JSON 是一种数据格式字符串是 JSON的表现形式符合JSON格式的字符串叫做 JSON字符串json易于阅读，易于解析，网络传输效率高 跨语言交换数据 json.loads()解码(反序列化),json.dumps()编码(序列化)123456789101112131415import json #反序列化json_str = &apos;&#123;&quot;name&quot;:&quot;weilai&quot;,&quot;age&quot;:18,&quot;a&quot;:true&#125;&apos; #JSON字符串格式，双引号json_str1 = &apos;[&#123;&quot;name&quot;:&quot;weilai&quot;,&quot;age&quot;:18,&quot;a&quot;:false&#125;,&#123;&quot;name&quot;:&quot;weilai&quot;,&quot;age&quot;:18&#125;]&apos;student = json.loads(json_str) #将一个JSON编码的字符串转换回一个Python数据结构student1 = json.loads(json_str1) print(type(student)) #字典格式 &#123;&apos;name&apos;: &apos;weilai&apos;, &apos;age&apos;: 18, &apos;a&apos;: True&#125;print(type(student1)) #列表形式 [&#123;&apos;name&apos;: &apos;weilai&apos;, &apos;age&apos;: 18, &apos;a&apos;: False&#125;, &#123;&apos;name&apos;: &apos;weilai&apos;, &apos;age&apos;: 18&#125;]print(student) print(student1)print(student[&apos;age&apos;]) print(student[&apos;name&apos;]) 序列化12345678910import jsonstudent = [ &#123;&apos;name&apos;: &apos;weilai&apos;, &apos;age&apos;: 18,&apos;a&apos;: False&#125;, &#123;&apos;name&apos;: &apos;weilai&apos;, &apos;age&apos;: 18&#125; ]json_str = json.dumps(student)print(type(json_str)) #&lt;class &apos;str&apos;&gt;print(json_str) #[&#123;&quot;name&quot;: &quot;weilai&quot;, &quot;age&quot;: 18, &quot;a&quot;: false&#125;, &#123;&quot;name&quot;: &quot;weilai&quot;, &quot;age&quot;: 18&#125;] JSON对象，json, json字符串 在python中没有JSON对象 json 是对ecmascript的一种实现 与Javascript相同 json 是一种中间数据类型，有自己的数据类型，与JavaScript相似 rest 服务的标准格式]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(7) python正则表达式的学习过程]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[12345 #优先使用内置函数a = 'C|C++|Java|C#|Python|Javascript'print(a.index('Python')&gt;-1)print('Python' in a) #利用内置函数判断字符串'python'是否在a中 正则表达式是一个特殊的字符序列，帮助检测一个字符串是否与所设定字符序列相匹配。.可快速检索文本、实现一些替换文本的操作。例如:1、检查一串数字是否是电话号码.2、检测一个字符串是否符合email3、把一个文本里指定的单词替换为另外一个单词。 #用正则表达式123456789101112131415161718192021import re # 引入re 模块 a = 'C|C++|Java|C#|Python|Javascript'r = re.findall('Python',a) #findall 方法 print(r)if len(r) &gt; 0: print('字符串中包含Python')else: print('No') ``` 正则表达式不仅可以用来检测字符串，也可以用来替换字符串。```pythonimport re a = 'C0C++7Java12C#9Python67\nJavascript8' #用r来提取a中的数字r = re.findall('\d',a) #\d 来表示数字（0-9）print(r)#用s来提取a中的非数字s = re.findall('\D',a) #\D 来表示非数字的字符print(s) 上面’python’是普通字符，’\d’,’\D’属于元字符正则表达式就是由普通字符和元字符等组合在一起的。 字符集虽然可以提取字符串，但提取出来的都是一个一个字符。只能匹配单一的字符（单个字母，数字）12345import rea = 'abc,acc,adc,aec,adfc,ahc,afc'r = re.findall('a[cf]c',s) #提取afc 或acc,普通字符a,c定界，元字符c，f#[]里表示或。[cf] c或f.[cdf] c或d或f [^cfd]取反，不是c和d和f。[c-f]取c到f。print(r) 概括字符集 \d即 [0-9]\D所有的非数字\w单词字符 ‘[A-Za-z0-9]和下划线_\W 非单词字符，\s 空白字符(空格/制表符/换行符)\S 非空白字符. 匹配除换行符之外其他所有的字符12345import rea = 'C0C++7Java12C#9Python67Javascript8\n\r &amp;^'r = re.findall('\d',a) print(r)#可自行验证 数量词,贪婪与非贪婪123456789101112import rea = 'C0C++7Java12C#9Python67Javascript8\n\r &amp;^'r = re.findall('\w&#123;3&#125;',a) #提取出来的\w 3个一组s = re.findall('[A-Za-z]&#123;3&#125;',a)t = re.findall('[A-Za-z]&#123;3,7&#125;',a)#3到7个一组，优先选择7个#贪婪 与 非贪婪#python默认使用贪婪 按最大的匹配u = re.findall('[A-Za-z]&#123;3,7&#125;?',a)#非贪婪 按最小的匹配，即3个一组print(r) print(s)print(t)print(u) 问号，星号，加号的使用方法123456789import rea = 'pytho0python1pythonn2'r = re.findall('python*',a) #['pytho', 'python', 'pythonn']s = re.findall('python+',a)t = re.findall('python?',a)print(r)print(s)print(t) 1、 对前的字符匹配0次或无限多次2、+ 对+前的字符匹配1次或无限多次3、 ? 对?前的字符匹配0次或1次 与贪婪中的?是不同的 边界匹配123456import re qq = '100001'#qq位数4-10位数r = re.findall('^\d&#123;4,10&#125;$',qq) #^从字符串开头匹配 ， $从字符串末尾匹配#即开头到结尾得在4-10之间print(r) 组1234import rea = 'PythonPythonPythonPythonPythonPython'r = re.findall('(Python)&#123;2&#125;',a)print(r)#['Python', 'Python', 'Python'] 匹配模式 （函数中的第三个参数）re.I 忽略匹配中的大小写re.S 匹配所有的字符，包括换行符123456import rea = &apos;C0C++7Java12C#\n9Python67Javascript#8&apos;r = re.findall(&apos;c#&apos;,a,re.I)r = re.findall(&apos;c#.&#123;1&#125;&apos;,a,re.I|re.S) # | 且print(r)#[&apos;C#&apos;]print(r1)#[&apos;C#\n&apos;] re.sub简单用法12345678import rea = 'C0C++C#7Java12C#\n9Python6C#7JavascriptC#8'r = re.sub('C#','GO',a,0) #无限次替换s = re.sub('C#','GO',a,1) #只替换一次t = a.replace('C#','GO') #python内置函数print(r)print(s)print(t) re.sub高阶用法123456789101112131415import rea = &apos;C0C++C#7Java12C#\n9Python6C#7JavascriptC#8&apos;def convert(value): print(value)#&lt;re.Match object; span=(5, 7), match=&apos;C#&apos;&gt;#&lt;re.Match object; span=(14, 16), match=&apos;C#&apos;&gt;#&lt;re.Match object; span=(25, 27), match=&apos;C#&apos;&gt;#&lt;re.Match object; span=(38, 40), match=&apos;C#&apos;&gt;#所以用value.group() matched = value.group() return &apos;!!&apos; + matched +&apos;!!&apos;r = re.sub(&apos;C#&apos;,convert,a)print(r) 把函数作为传递参数12345678910111213import res = &apos;A1b2c3d4e5f6g7h8i9&apos;def convert1(value): print(value) matched1 = value.group() if int(matched1) &gt;=6: return &apos;9&apos; else: return &apos;0&apos;s = re.sub( r&apos;\d&apos;,convert1,s)print(s) match和searchmatch和search方法类似, 但有些许区别, 顾明思议match是匹配的意思, 从第一个字符开始匹配, 匹配不到就返回search是搜索的意思, 如果第一个字符匹配不到, 会继续往后匹配, 直到字符结束1234567import res = &apos;A1b2c3d4e5f6g7h8i9&apos;r = re.match(r&apos;\d&apos;,s) r1 = re.search(r&apos;\d&apos;,s)print(r) #Noneprint(r1)#&lt;re.Match object; span=(1, 2), match=&apos;1&apos;&gt; group()的用法123456789101112import res = &apos;life is short,i use python&apos;r = re.search(&apos;life.*python&apos;,s)r1 = re.search((&apos;life.*python&apos;),s) #与上行一样r2 = re.search(&apos;life(.*)python&apos;,s)print(r.group())print(r1.group())print(r2.group(0)) #全文匹配print(r2.group(1)) #括号内匹配r3 = re.findall(&apos;life(.*)python&apos;,s)print(r3) 12345678910import res = &apos;life is short,i use python,I love python&apos;r = re.search(&apos;life(.*)python(.*)python&apos;,s)print(r.group())#life is short,i use python,I love pythonprint(r.group(0))#life is short,i use python,I love pythonprint(r.group(1))# is short,i use (第一组)print(r.group(2))#,I love（第二组）print(r.group(0,1,2)) #用元组的方式表达出来#(&apos;life is short,i use python,I love python&apos;, &apos; is short,i use &apos;, &apos;,I love &apos;)print(r.groups()) #只会表示出（.*）的内容#(&apos; is short,i use &apos;, &apos;,I love &apos;)]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(6) python中面向对象]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[有意义的面向对象的代码类 是面向对象最核心的观念类、对象实例化类最基本的作用：封装一定要用self,引用 self.类只负责定义，不会去运行类和对象。数据成员构造函数可以让模板生成不同的对象 类是现实世界或思维世界中的实体在计算机中的反馈它将数据以及这些数据上的操作封装在一起 类 被 实例化后 就成了一个具体的对象类就像是一个模板，通过类 就可以产生很多对象。123456789101112131415#比如这段代码为 1.pyclass Human(): sum = 0 #在class内部定义变量 类变量 （和类相关联在一起的） def __init__(self,name,age):#构造函数 ， #文件夹中得含有 _init_.py 模块才会被认为是一个包。包 导入时会优先运行. #初始化对象属性 self.name = name # 定义实例时需要self，调用实例不需要给self赋参 self.age = age #定义实例变量，实例变量只和对象相关 self. #return NONE (构造函数只能返回NONE) (补充知识) def get_name(self): print(self.name) def do_homework(self): print(&apos;This is a parent method&apos;) 12345678910111213141516171819202122232425from 1.py import Human class Student(Human): #Human是Student的父类，Student是Human的子类 def __init__(self,school,name,age): self.school = school super(Student,self).__init__(name,age) #建议以此方式调用父类 #super 不仅仅可用于构造函数，也可以用于普通的实例方法 # Human.__init__(self,name,age) #子类里调用父类构造函数 #self 用类调用实例方法没意义，所以加self # self.age = age def do_homework(self): #子类和父类同名的话，不会报错，先使用子类 #super(Student,self).do_homework() #This is a parent method print(&apos;English homework&apos;) student1 = Student(&apos;jinan university&apos;,&apos;wei&apos;,18) #实例化student1.do_homework() #English homeworkprint(student1.name) #weiprint(student1.age)#18#继承 单继承 多继承 定义一个类1234567891011121314151617181920class Student(): name = &apos;&apos; #在class内部定义变量 类变量 （和类相关联在一起的） age = 0 #行为 与 特征 def __init__(self,age,name): #构造函数(实例化后，会自动调用) #初始化对象属性 self.neme = name self.age = age #定义实例变量，实例变量只和对象相关 self. # #return NONE (构造函数只能返回NONE) (补充知识) def print_files(self): #在class内部定义函数 print(&apos;name:&apos;+ self.name) print(&apos;age:&apos;+ str(self.age))student = Student() #类的实例化student.print_files() #类下面方法的调用# 建议 类的实例化以及类下面方法的调用 与类的定义放在不同的模块。# 定义实例时需要self，调用实例不需要给self赋参 详解123456789101112# 模块c = 50def add(x, y): c= x+y print(c)add(1,2) #3 函数中局部变量的值print(c) #50 全局变量的值 # 两个print(c)的区别 # 局部变量不会改变全局变量的值 类和模块要区别对待 ‘类变量’ 和 类 关联在一起的######’实例变量’ 和 对象 关联在一起的123456789101112131415161718class Student(): sum=0 name = &apos;weilai&apos; age = 0 def __init__(self,name,age): self.name = name self.age = age def marking(self,sorce): #内部访问 if sorce &lt; 0: #建议通过方法 对 类变量赋值 # sorce =0 return &apos;不能给同学打负分&apos; self.__sorce = sorce print(self.name + &apos;同学本次的考试分数为：&apos; + str(self.__sorce)) return &apos;hello&apos;result = student1.marking(80)#wang同学本次的考试分数为：80print(result) #hello 12345678910111213141516class Student(): sum=0 # 类变量 和类相关 name = &apos;weilai&apos; #在class内部定义变量 类变量 age = 0 # 类中赋值没有意义的。 #21 ，22 其实是与对象相关，不应出现在这 # 行为 与 特征 def __init__(self,name,age): #构造函数(实例化后，会自动调用),是一个特殊的方法 #主要是被用来初始化对象属性 self.name = name #实例方法操控实例变量 self.age = age print(self.__class__.sum) print(Student.sum) self.__class__.sum +=1 #实例方法访问类变量中的sum print(Student.sum)student1 = Student(&apos;wang&apos;,18)student2 = Student(&apos;li&apos;,19) 类方法主要操作和类相关的变量用类调用类方法123456789101112131415161718class Student(): sum=0 name = &apos;weilai&apos; age = 0 def __init__(self,name,age): self.name = name self.age = age @classmethod #让其成为类方法 def plus_sum(cls): #sum每运行一次就+1 cls.sum+=1 print(cls.sum)student1 = Student(&apos;wang&apos;,18)Student.plus_sum() #用类调用类方法student2 = Student(&apos;li&apos;,19)Student.plus_sum() 对象调用类方法(python可用但最好不要用)123456789101112131415161718class Student(): sum=0 name = &apos;weilai&apos; age = 0 def __init__(self,name,age): self.name = name self.age = age @classmethod #让其成为类方法 def plus_sum(cls): #sum每运行一次就+1 cls.sum+=1 print(cls.sum)student1 = Student(&apos;wang&apos;,18)student1.plus_sum() #用对象调用类方法student2 = Student(&apos;li&apos;,19)student2.plus_sum() 静态方法12345678910111213class Student(): sum=0 name = &apos;weilai&apos; age = 0 def __init__(self,name,age): self.name = name self.age = age @staticmethod #静态方法 def add(x): print(Student.sum) print(&apos;this is a static method&apos;) 静态方法 能用的地方 基本可以用 类方法替代(最好用类方法)当和类和对象没多大关系的时候,可以使用静态方法静态方法和类方法 均不能访问 实例变量 类中赋值没有意义的。1234567891011121314151617class Student(): name = &apos;weilai&apos; age = 0 def __init__(self,name,age): name = name age = age student1 = Student(&apos;wang&apos;,18)print(student1.name) #weilaiprint(student1.age) #0print(student1.__dict__) #&#123;&#125; #__dict__显示student1下所有的变量，即没有变量# python 会先在 实列变量上寻找 ，寻找不到就会到类变量里寻找，（然后再到父类里寻找）# 所以即使student1为空，也显示了类变量下的值#公开的 public 私有的（外部不能访问）private 在方法或变量前加__ 表示私有的#__init__ 构造函数是python特有的，可以从外部访问#print(student1._Student__sorce) 表明python中私有只是改了一个名字]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(5) python项目的组织结构]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[包、模块、类→函数、变量 序列解包1234# a=1# b=2# c=3# d,e,f=4,5,6 定义一个函数12345678def damage(skill1,skill2): damage1 = skill1*3 damage2 = skill2*2+10 return damage1,damage2 (不return，就是返回none)skill1s,skill2s=damage(2,3)print(skill1s,skill2s) 1234567891011def add(x,y): result=x+y return result def print_code(code): print(code) returna=add(1,2)print_code(&apos;python&apos;)print(a) 函数参数1234567891011121314151617181920212223def print_student_files(name, gender,age,adress): print(&quot;I&apos;m &quot;+name) print(&quot;I&apos;m &quot;+age+&apos;years old&apos;) print(&quot;I&apos;m &quot;+ gender) print(&quot;I&apos;m living in &quot;+adress)print_student_files(&apos;weilai&apos;,&apos;man&apos;,&apos;18&apos;,&apos;hubei&apos;)def print_student_files1(name, gender=&apos;man&apos;,age=18,adress=&apos;hubei&apos;): print(&quot;I&apos;m &quot;+name) print(&quot;I&apos;m &quot;+str(age)+ &apos;years old&apos;) print(&quot;I&apos;m &quot;+gender) print(&quot;I&apos;m living in &quot;+adress)print_student_files1(&apos;weilai&apos;,&apos;woman&apos;,18,&apos;hubei&apos;)#重点：#1）必须参数:形参(例如name)，实参(&apos;weilai&apos;,&apos;man&apos;,18,&apos;hubei&apos;)#2）关键字参数#3)默认参数：大多数情况下，函数的参数选取的的是一种默认值，可选用默认参数# 注意事项:1、形参没有给默认值的，函数调用时得给一个实参# 2、非默认参数不能放在默认参数之后（调用时，同理）# 3、参数顺序得与默认参数顺序相同（关键字参数有时，可不遵守顺序）# 4、给了默认参数，函数调用时优先使用实参 import1234567891011121314import _init_print(_init_.b)# 注意事项：import 与 from import# 1）如 print t包C7.py中的a# import t.c7 ~ print（t.c7.a） 等价于from t.c7 import a ~print（a）# 等价于from t import c7.a ~print（c7.a）# 2)import t.c7 ~ print（t.c7.a） 等价于import t.c7 as m ~print（m.a）# 3）包和模块不会被重复导入 # 4）避免循环导入 # 5）from t.c7 import * (导入C7中所有的变量) # 6）from t.c7 impor _all_=[&apos;a&apos;,&apos;c&apos;] (导入C7中&apos;a&apos;,&apos;c&apos;两个变量） if12345mood=True if mood: print(&apos;go to left&apos;)else : print(&apos;go to right&apos;) 123456789101112a=1b=2c=3d,e,f=4,5,6 #序列解包if d&lt;a: print(&apos;go to left&apos;)elif d&lt;b: print(&apos;go to left&apos;)elif d&lt;c: print(&apos;go to left&apos;)elif d&lt;e: print(&apos;go to left&apos;) for1234567891011121314151617181920a=[1,2,3,4,5]for x in a: if x==3: break print(x) # continue # print(x)a = [[&apos;apple&apos;,&apos;orange&apos;,&apos;banana&apos;],(1,2,3)]for x in a: for y in x: print(y) print(x)for x in range(0,10): print(x)for x in range(0,10,2): print(x) 注意事项： 1)break和continue区别：break到3就停止，continue跳过3继续 2）注意print()函数的位置，对结果的影响 3）递归用while，遍历用for]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(4) python中流程控制语句]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[条件语句if elif else都是关键字，需要能读和写 基本格式：123456if 条件语句1： 执行语句块1elif 条件语句2： 执行语句块2else： 执行语句块3 执行过程：12a.先判断条件语句1是否为True，如果为True就执行冒号后边的执行语句块1，整个条件结构就执行完了;如果是False，就去判断条件语句2是否为True。b.如果是True就执行执行语句块2，再执行其他语句;如果是False,就直接执行语句块3，再执行其他语句。 注意：冒号后边语句块和冒号所在得语句要保持一个缩进。 if判断条件语句的值是否为True，如果为True，就只执行执行语句块。否则就直接执行if语句后面的其他语句。123456789101112if 条件语句： 执行语句块age=20要求判断年龄是否大于18，如果大于18就输出&apos;成年人&apos;if age&gt;18: print(&apos;成年人&apos;)练习：判断一个数是否是偶数，如果是就打印&apos;xxx是偶数&apos;n=18if n%2==0: print(&apos;%d是偶数&apos;%(n)) 2.if-else判断条件语句是否为True，如果为True，就执行语句块1;否则就执行语句块2.12345678910111213141516171819202122if 条件语句： 执行语句块1else： 执行语句块2n=17if n%2==0: print(&apos;%d是偶数&apos;%(n))else: print(&apos;%d是奇数&apos;%(n))练习：输入一个数，如果这个数大于10，就输出他的2倍值。否 则输出这个数的2次幂。input():从控制台获取键盘输入的一个字符串，以回车结束。inputvalue=input(&apos;请输入一个数：&apos;)print(inputvalue)n=int(inputvalue)比较运算符和+以及*，在运算的时候，两边可以都是字符串，也可以都是数字，但是不可以一样一个。if n&gt;10:num=n*2 print(num)else:num=n**2 print(num) 3.if-elif-elif-else总结: a.如果要求中需要多个判断，可以使用多个elif的if语句。b.一个if/elif/else语句中可以嵌套其他的if语句。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354（1）给一个成绩，判断成绩是优秀(90-100)、良好(80-89)、 中等(60-79)、不及格(60以下)方法一：grade=96if grade&gt;=90: if grade&gt;100: print(&apos;成绩有误&apos;) else: print(&apos;优秀&apos;)elif grade&gt;=80: print(&apos;良好&apos;)elif grade&gt;=60: print(&apos;中等&apos;)elif grade&gt;=0: print(&apos;不及格&apos;)else: print(&apos;成绩有误&apos;)方法二：grade=67if 100&gt;=grade&gt;=90: print(&apos;优秀&apos;)elif 90&gt;grade&gt;=80: print(&apos;良好&apos;)elif 80&gt;grade&gt;=60: print(&apos;中等&apos;)elif 60&gt;grade&gt;=0: print(&apos;不及格&apos;)else: print(&apos;成绩有误&apos;) （2）给个年龄，判断年龄处于：婴儿（0-1岁）、儿童（2-4 岁）、少年（5-12岁）、青年（13-18岁）、成年（19-40）、 中年（41-60）、老年（60以上）age=1if age&lt;2: if age&lt;=0: print(&apos;年龄输入错误&apos;) else: print(&apos;婴儿&apos;)elif age&lt;5: print(&apos;儿童&apos;)elif age&lt;13: print(&apos;少年&apos;)elif age&lt;19: print(&apos;青年&apos;)elif age&lt;41: print(&apos;成年&apos;)elif age&lt;61: print(&apos;中年&apos;)else: print(&apos;老年&apos;)说明：Python中没有switch语法。pass：占位，防止因为没有写块结构而出现语法错误。if n==10: pass 转换函数 1.int()int():将其他的数据转换成int类型的数据123456num=12.56print(int(num)) # 12 将浮点数转换成整数（直接去掉小数部分）bool1=Trueprint(int(bool1)) # 1 将布尔值转换成整数，True-&gt;1 False-&gt;0str1=&apos;123&apos;print(int(str1)) # 123 只有纯数字字符串或者纯数字字符串前有正负号的字符串才能转换成相应的整数。 2.flot()flot():将其他数据转换成浮点型3.bool()bool()：将其他的数据转换成布尔值 数字转换成布尔，非0是True，0是False。1234567print(bool(12)) # Trueprint(bool(-12.3)) # Trueprint(bool(0)) # False字符串转换成布尔，除了空串是False，其他的都是True。print(bool(&apos;abc&apos;)) # Trueprint(bool(&apos;&apos;)) # False 注意：在if或者while循环后的条件语句，可以不是结果为True/False的表达式，也可以是值是其他类型的表达式.判断的是时候就看这个值转换成bool后的结果是True还是False。1234if 10: print(&apos;aaa&apos;) # aaa （10转换成bool后是True) if 0: print(&apos;aaa&apos;) # （0转换成bool后是False） 练习：判断一个字符串是否是空串，如果不是就直接打印这个字符 串，否则打印“空串”123456789101112方法1：str1=&apos;&apos;if str1: print(str1)else: print(&apos;空串&apos;)方法2：str1=&apos;abc&apos;if str1!=&apos;&apos;: print(str1)else: print(&apos;空串&apos;) 4.str()str()：将其他的数据转换成字符串。所有的数据类型都可以转换成字符串。循环python中循环：for循环、while循环（一个操作需要重复执行多次，这个时候就要考虑使用循环）for循环python中的for循环只有for-in循环：123456789101112131415161718192021格式：for 变量名 in 列表： 循环体执行过程：使用变量去依次获取列表中的数据直到获取完为止;没获取一个数据，执行一次循环体。循环次数：由列表中的数据的个数决定。去获取字符串中的每一个字符str1=&apos;abcdef&apos;for char in str1: print(char)去统计字符串中&apos;a&apos;出现的次数str1=&apos;avaadafvaavafaaa&apos;n=0for char in str1: if char==&apos;a&apos;: n=n+1 print(n)range（）函数：可以生成一个数值范围` 1234567打印1-100for n in range(1,101): print(n)用法1：range(n),生成0~n-1的值for x in range(9): print(x)` 用法2：range(m,n),生成m~n-1的数123456for n in range(5,9): print(n)打印0-100之间所有的偶数for x in range(101): if x%2==0: print(x) 用法3：range(m,n,step):从m开始每step取一个数，取到n前 一个数为止。123456for x in range(1,8,2): print(x) # 1,3,5,7 不通过字符串相乘，打印10次“=”,并且打印在同一行。for _ in range(10): print(&apos;=&apos;,end=&apos; &apos;) 求1+2+3…+1001234n=0for x in range(1,101): n=n+xprint(n) 注意：如果循环中的变量取到的值没有意义，循环只是单纯的控制次数，这个时候for后面的变量名一般用“_”代替。 while循环123格式： while 条件语句： 循环体 执行过程：判断条件语句结果是否为True，如果为True就执行一次循环体。执行完循环体后再判断条件语句是否为True，如果为True继续执行循环体。重复这个过程，直到条件语句结果为False for循环可以实现的操作，while循环都可以 打印1-10012345678910方法1：x=0while x&lt;100: x+=1 print(x) 方法2：x=1while x&lt;=100: print(x) x+=1 计算1+2+3+…+100123456x=0n=0while n&lt;100: n+=1 x+=n print(x) 求1-100中所有偶数的和123456789101112131415方法1：n=0x=0while n&lt;=100: if n%2==0: x=x+n n=n+1 print(x)方法2：n=0x=0while n&lt;100: n+=2 x=x+nprint(x) break和continue1、breakbreak是一个让循环提前结束的关键字 如果在for循环或者while循环中遇到了break，那么循环就在break的位置直接结束。结束后程序执行循环后边的代码。 练习:找到1000~9999中第一个能够被13整除的数，打印出来123456789for x in range(1000,10000): if x%13==0: print(x) break for x in range(1,100): if x==50: break print(x) # 1 2 3 ... 49 用while循环实现：不断的让用户去输入数字，直到用户输入的数字是0为止。最后在打印之前输入的数的和。 input()函数：程序执行到input()函数的时候，程序就会停下来，等待用户从键盘输入并且以回车结束，然后才会往下执行。 注意：break只能写在循环中12345678sum1=0while True:num=int(input(&quot;&gt;&gt;&gt;&quot;)) # 获取键盘输入的内容，并且转换成int类型 sum1+=num # 将当次输入的数字加起来 if num==0: # 判断输入的数字是否是0，如果是就让循环结束 break print(num)print(sum1) for循环的特点：次数确定，可以在序列中取数据 while循环：循环次数不确定的（while True + break） randint(m,n):产生一个m到n的随机整数 产生随机数：random模块是python内置用来产生随机数的模块，里面提供了很多产生随机数的函数。 猜数字：随机生成一个整数。用户输入数字。如果用户输入的数字大于这个随机数就提示：“大了”;如果用户输入的数小于随机数就提示：“小了”。直到用户输入的数和这个随机数大小一样游戏结束。123456789101112131415161718import randomnum=random.randint(0,100) # 产生一个0到100的随机数n=0while True:num1=int(input(&quot;请输入你猜的数字：&quot;))n=n+1if num1&gt;num: print(&apos;大了&apos;)elif num1&lt;num: print(&apos;小了&apos;)else: print(&apos;恭喜你，猜对了！&apos;) print(&apos;一共猜了：%d次&apos;%(n),end=&apos; &apos;) if n&lt;=5: print(&apos;你太棒了，只猜了%d次就猜对了&apos;%(n)) else: print(&apos;下次加油！&apos;) break 2、continuecontinue:结束当次循环，进入下次循环12345for x in range(1,10): print(&apos;=&apos;) continue # 遇到continue就不再执行循环体后面的内容，直接进入下一次循环的判断 print(x)` 求1~100中所有奇数的和123456sum=0for x in range(1,100): if x%2==0: continue sum=sum+xprint(sum) 打印100~999中十位数上不是3的所有数：123456 for x in range(100,1000): if x//10%10==3: continue print(x) ``` 统计输入的数字中，偶数的个数。如果输入0，就结束。（必须使用continue） flag=True n=0 while True: num=int(input(‘请输入一个数：’)) # 输入数据 if num%2==1: # 判断是否是奇数 continue if num==0: flag=False n=n+1 print(n)12**else**python中循环语句后面可以加else语句。这个else语句会在循环结束后执行。 for 变量 in 序列： 循环体 else： 循环结束后会执行的语句块 1234567``` 1*2*3...*10 sum1=1 for x in range(1,11): sum1*=x else: print(sum1) 注意：如果再循环语句中使用break，那么else语句不会执行。（continue不存在这个问题） 123…*10，当乘积大于10000就不在执行12345678sum1=1for x in range(1,11): if sum1*x&gt;10000: break sum1*=xprint(sum1)else: print(sum1) # 如果在循环中执行了break，那么else中的语句不会执行 多重循环在循环体里面可以有其他的循环语句，结构为：123456789101112131415for 变量 in 序列： for 变量1 in 序列2： 循环体2 其它的循环语句for 变量 in 序列： 其他的循环语句1 while 条件语句： 循环体2 其他的循环语句2while 条件语句1： while 条件语句2： 循环体2 其他的循环语句2 例如：1234567891011121314151617181920212223242526272829如果n=5 打印112123123412345n=5for x in range(1,n+1): # 控制行数 for b in range(1,x+1): # 控制当前行的数值 print(b,end=&apos;&apos;) print() # 一行结束换行***************n=5for x in range(1,n+1): for b in range(x,n+1): print(&apos;*&apos;,end=&apos;&apos;) print()n=10for x in range(1,n+1): for b in range(x,n+1): print(&apos;*&apos;,end=&apos;&apos;) print() 参考了简书中某人的记录，但找不到具体是谁了。侵删。]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(3) python中变量与运算符]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[变量的命名规则字母，数字，下划线_和他们的组合注意：12345671、首字母不能为数字2、只有下划线_这一种特殊字符3、系统关键字不能作为变量名#True = 1 #报错can&apos;t assign to keyword4、变量是区分大小写的cat_name=1catName=1 #变量的两种命名方式 运算符python运算符有：算术运算符、比较运算符、赋值运算符、逻辑运算符、位运算符、成员运算符、身份运算符、运算符优先级 Python算术运算符1234567+ 加 - 两个对象相加 a + b 输出结果 31- 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -11* 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 210/ 除 - x 除以 y b / a 输出结果 2.1% 取模 - 返回除法的余数 b % a 输出结果 1** 幂 - 返回x的y次幂 a**b 为10的21次方// 取整除 - 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 Python比较运算符123456== 等于 - 比较对象是否相等 (a == b) 返回 False。!= 不等于 - 比较两个对象是否不相等 (a != b) 返回 True。&gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False。&lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。 (a &lt; b) 返回 True。&gt;= 大于等于 - 返回x是否大于等于y。 (a &gt;= b) 返回 False。&lt;= 小于等于 - 返回x是否小于等于y。 (a &lt;= b) 返回 True。 Python赋值运算符12345678= 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c+= 加法赋值运算符 c += a 等效于 c = c + a-= 减法赋值运算符 c -= a 等效于 c = c - a*= 乘法赋值运算符 c *= a 等效于 c = c * a/= 除法赋值运算符 c /= a 等效于 c = c / a%= 取模赋值运算符 c %= a 等效于 c = c % a**= 幂赋值运算符 c **= a 等效于 c = c ** a//= 取整除赋值运算符 c //= a 等效于 c = c // a Python位运算符 按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657下表中变量 a 为 60，b 为 13二进制格式如下：a = 0011 1100b = 0000 1101-----------------a&amp;b = 0000 1100a|b = 0011 1101a^b = 0011 0001~a = 1100 0011运算符 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100| 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。&lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由&quot;&lt;&lt;&quot;右边的数指定移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000&gt;&gt; 右移动运算符：把&quot;&gt;&gt;&quot;左边的运算数的各二进位全部右移若干位，&quot;&gt;&gt;&quot;右边的数指定移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111以下实例演示了Python所有位运算符的操作：实例(Python 3.0+) #!/usr/bin/python3 a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = 0 c = a &amp; b; # 12 = 0000 1100print (&quot;1 - c 的值为：&quot;, c) c = a | b; # 61 = 0011 1101 print (&quot;2 - c 的值为：&quot;, c) c = a ^ b; # 49 = 0011 0001print (&quot;3 - c 的值为：&quot;, c) c = ~a; # -61 = 1100 0011print (&quot;4 - c 的值为：&quot;, c) c = a &lt;&lt; 2; # 240 = 1111 0000print (&quot;5 - c 的值为：&quot;, c) c = a &gt;&gt; 2; # 15 = 0000 1111print (&quot;6 - c 的值为：&quot;, c)以上实例输出结果：1 - c 的值为： 122 - c 的值为： 613 - c 的值为： 494 - c 的值为： -615 - c 的值为： 2406 - c 的值为： 15 Python逻辑运算符123and x and y 布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。or x or y 布尔&quot;或&quot; - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。not not x 布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False Python成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。12in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 Python身份运算符身份运算符用于比较两个对象的存储单元123456789is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 Falseis not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。注： id() 函数用于获取对象内存地址。is 与 == 区别：is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。&gt;&gt;&gt;a = [1, 2, 3] &gt;&gt;&gt; b = a &gt;&gt;&gt; b is a True &gt;&gt;&gt; b == a True &gt;&gt;&gt; b = a[:] &gt;&gt;&gt; b is a False &gt;&gt;&gt; b == a True Python运算符优先级以下表格列出了从最高到最低优先级的所有运算符：12345678910111213** 指数 (最高优先级)~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)* / % // 乘，除，取模和取整除+ - 加法减法&gt;&gt; &lt;&lt; 右移，左移运算符&amp; 位 &apos;AND&apos;^ | 位运算符&lt;= &lt; &gt; &gt;= 比较运算符&lt;&gt; == != 等于运算符= %= /= //= -= += *= **= 赋值运算符is is not 身份运算符in not in 成员运算符and or not 逻辑运算符 一些杂项 `3+2-1 #4 同优先级 左集合c=a+b #先算a+b然后赋值给c 右集合not (1 or 2)+2==3 #True 建议括号只用来改变优先级关系]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(2) python基本数据类型总结]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[整数int与浮点数float整数运算永远是精确的，浮点数的运算可能会有四舍五入。2/2结果为1.0// 表示整除 2//2结果为13//2也是1 并不是四舍五入，而是只保留整数部分1.23x10^9和 12.3x10^8相等1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5进制python中默认为10进制。2进制用0b表示，例如0b10即为2。8进制用0o表示，例如0o10即为8。16进制用0x表示，例如0x10即为16。（8,9,a,b,c,d,e,f,0x10)1234bin() #转化为2进制oct() #转化为8进制int() #转化为10进制hex() #转化为16进制 布尔值bool123456bool()bool(0)bool(&apos;&apos;)bool([])bool(&#123;&#125;)bool(None) 只有bool(0)和bool()括号中为空才表示Fasle。bool(’0‘)等表示True 序列字符串 str 可用单引号，双引号或者三引号表示例如’str’ 或”str “或者’’’str’’’ 其中三引号常用方式如下123456&apos;&apos;&apos;line1line2 . .&apos;&apos;&apos; 在字符串前面加一个R/r 表示原始字符串1print(r&apos;\t\r&apos;) # \t\r 一些转义字符（特殊的字符）123456\n #换行 无法“看见”的字符\&apos; #单引号 与语言本身有冲突的字符\t #横向制表符\r #回车\n #换行\\ #表示\ 元组 tuple ( )与列表list [ ] 元组与列表在python中的唯一区别就是：元组是不可变的，列表是可变的。(元组和字符串是不可变的)12345678910111213141516a = &apos;hello&apos;a=a+&apos;world&apos;print(a) #&apos;helloworld&apos; a变成了一个新的字符串，而不是改变了字符串#列表可变b=[1,2,3]b.append(4)print(b) #[1,2,3,4]#改变的是列表不是元组c = (1,2,3,[4,5,[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]])c[3][2][1] = &apos;d&apos;c[3][0]=&apos;6&apos;c[3][1]=7#c[2]=8 #会报错，因为元组不能被改变&apos;tuple&apos; object does not support item assignmentprint(c) #(1, 2, 3, [&apos;6&apos;, 7, [&apos;a&apos;, &apos;d&apos;, &apos;c&apos;]]) 改变的是列表 而不是 元组 在你有一些不确定长度的相同类型队列的时候使用列表；在你提前知道元素数量的情况下使用元组，因为元素的位置很重要。123456789#元组(1,2,3) ((1,2,3),(4,&apos;hello&apos;,True))(1,2,[3,4],&#123;5,6&#125;,&#123;(1,2,3):10,&apos;hello&apos;:11,100:&apos;hello&apos;&#125;)() #空元组(1,) #一个元素的元组#列表[1,2,3][[1,2,3],[4,&apos;hello&apos;,True],(1,2,3),&#123;7,8&#125;&#123;(1,2,3):10,&apos;hello&apos;:11,100:&apos;hello&apos;&#125;] 序列可以进行加法，与整数相乘，切片操作123456789101112131415161718#与整数相乘&apos;python&apos;*3 # &apos;pythonpythonpython&apos;((1,2,3),(4,&apos;hello&apos;,True))*2 # ((1, 2, 3), (4, &apos;hello&apos;, True), (1, 2, 3), (4, &apos;hello&apos;, True))[[1,2,3],[4,&apos;hello&apos;,True],(1,2,3)]*2 #[[1, 2, 3], [4, &apos;hello&apos;, True], (1, 2, 3), [1, 2, 3], [4, &apos;hello&apos;, True], (1, 2, 3)]#同类型相加&apos;hello&apos;+&apos;world&apos; # &apos;helloword&apos;((1,2,3),(4,&apos;hello&apos;,True))+(7,8,9) #((1, 2, 3), (4, &apos;hello&apos;, True), 7, 8, 9)[[1,2,3],[4,&apos;hello&apos;,True],(1,2,3)]+[4,5,6] #[[1, 2, 3], [4, &apos;hello&apos;, True], (1, 2, 3), 4, 5, 6]#切片&apos;hello world&apos;[0] # &apos;h&apos; 从0开始&apos;hello world&apos;[-1] # &apos;d&apos; 从末尾往前数1&apos;hello world&apos;[1:4] # &apos;ell&apos; 从1开始，4前一位结束&apos;hello world&apos;[0:-2] # &apos;hello wor&apos; 从开头到末尾减去2位&apos;hello world&apos;[:-5] # &apos;hello &apos; 从开头到末尾减去5个字符 &apos;hello world&apos;[1:-2] #&apos;ello wor&apos; 从1到末尾减去2位&apos;hello world&apos;[6:100] # &apos;world&apos; 超过，从第6位取到末尾&apos;hello world&apos;[6:] # &apos;world&apos; 从第6位取得末尾&apos;hello world&apos;[-1:2] #&apos;’‘ 空字符串，不能这样做 集合set {}和字典dict {}集合和字典的特点是 无序，不重复set()表示空集合{} 表示空字典123- #可以用来求两个集合的差集+ #可以用来求两个集合的交集| #可以用来求两个集合的合集 字典是通过key访问value{key1:value1,key2:value2}key不能重复,类型为int,str，tuplevalue可以为任意数据]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(1) python]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%2F</url>
    <content type="text"><![CDATA[编译型语言在程序执行之前，先会通过编译器对程序执行一个编译的过程，把程序转变成机器语言。运行时就不需要翻译，而直接执行就可以了。最典型的例子就是 C 语言。 解释型语言就没有这个编译的过程，而是在程序运行的时候，通过解释器对程序逐行作出解释，然后直接运行，最典型的例子是 Ruby。 Python 是一门先编译后解释的语言。 当 Python 程序运行时，编译的结果则是保存在位于内存中的 PyCodeObject 中，当 Python 程序运行结束时，Python 解释器则将 PyCodeObject 写回到 pyc 文件中。 当 Python 程序第二次运行时，首先程序会在硬盘中寻找 pyc 文件，如果找到，则直接载入，否则就重复上面的过程。 pyc 文件其实是 PyCodeObject 的一种持久化保存方式。 执行 Python 程序的三种方式：解释器、交互式运行、IDE运行]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(4.6) git分支管理-多人协作]]></title>
    <url>%2Fgit%2Fgit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： 12$ git remoteorigin 或者，用git remote -v显示更详细的信息： 123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 1$ git push origin master 如果要推送其他分支，比如dev，就改成： 1$ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： 1234567$ git clone git@github.com:michaelliao/learngit.gitCloning into &apos;learngit&apos;...remote: Counting objects: 40, done.remote: Compressing objects: 100% (21/21), done.remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0Receiving objects: 100% (40/40), done.Resolving deltas: 100% (14/14), done. 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 12$ git branch* master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： 1$ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： 123456789101112131415$ git add env.txt$ git commit -m &quot;add env&quot;[dev 7a5e5dd] add env 1 file changed, 1 insertion(+) create mode 100644 env.txt$ git push origin devCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git f52c633..7a5e5dd dev -&gt; dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： 123456789101112131415161718$ cat env.txtenv$ git add env.txt$ git commit -m &quot;add new env&quot;[dev 7bd91f1] add new env 1 file changed, 1 insertion(+) create mode 100644 env.txt$ git push origin devTo github.com:michaelliao/learngit.git ! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to &apos;git@github.com:michaelliao/learngit.git&apos;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： 12345678910$ git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; dev git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： 12$ git branch --set-upstream-to=origin/dev devBranch &apos;dev&apos; set up to track remote branch &apos;dev&apos; from &apos;origin&apos;. 再pull： 1234$ git pullAuto-merging env.txtCONFLICT (add/add): Merge conflict in env.txtAutomatic merge failed; fix conflicts and then commit the result. 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： 1234567891011$ git commit -m &quot;fix env conflict&quot;[dev 57c53ab] fix env conflict$ git push origin devCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (4/4), done.Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.Total 6 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git 7a5e5dd..57c53ab dev -&gt; dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo搭建个人网站]]></title>
    <url>%2Fvps%2FGitHub%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[过程 GitHub创建个人仓库格式用户名.github.io 安装Githttps://git-scm.com/downloads 安装Node.jshttps://nodejs.org/en/download/ 安装Hexonpm install -g hexo-clihexo init bloghexo new test_my_sitehexo ghexo slocalhost:4000 推送网站改站点配置文件然后hexo cleanhexo ghexo dhttps://itswl.github.io1. GitHub创建个人仓库https://github.com 点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.http://github.io这个用户名使用你的GitHub帐号名称代替，这是固定写法。2. 安装GitGit下载地址：https://git-scm.com/downloads选择对应版本安装即可 Git Bash here，设置user.name和user.email配置信息：git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件：ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 然后直接三个回车即可，默认不需要设置密码然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制 打开https//github.com/settings/keys 页面，新建new SSH Key Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。 在Git Bash中检测GitHub公钥设置是否成功，输入 ssh git@github.com 如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 3. 安装Node.jsHexo基于Node.js，Node.js下载地址:https://nodejs.org/en/download/选择对应版本安装。安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入:node -v检测npm是否安装成功，在命令行中输入npm -v : 到这了，安装Hexo的环境已经全部搭建完成。 4 安装hexo新建一个博客文件夹，在博客文件夹中，Git bash here 使用npm命令安装Hexo，输入：npm install -g hexo-cli 这个安装时间较长耐心等待，安装完成后，初始化我们的博客，输入：hexo init blog 为了检测我们的网站雏形，分别按顺序输入以下三条命令：12345hexo new test_my_site:hexo ghexo s 完成后，打开浏览器输入地址： localhost:4000 可以看出我们写出第一篇博客。 常用的Hexo 命令123456789101112131415npm install hexo -g #安装Hexonpm update hexo -g #升级 hexo init #初始化博客命令简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 5. 推送网址上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站。在blog根目录里的_config.yml文件称为站点配置文件，如下图 根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件，如下图 下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改并保存： 其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令： 1npm install hexo-deployer-git --save 这时，我们分别输入三条命令： 123hexo clean hexo g hexo d 其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径:https://itswl.github.io博客已经上线了，可以在网络上被访问了。]]></content>
      <categories>
        <category>VPS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(4.1) git中分支管理-创建合并]]></title>
    <url>%2Fgit%2Fgit%E4%B8%AD%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-%E5%88%9B%E5%BB%BA%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[#小结Git鼓励大量使用分支：查看分支：git branch创建分支：git branch &lt;name&gt; eg:git branch dev切换分支：git checkout &lt;name&gt; eg:git checkout dev创建+切换分支：git checkout -b &lt;name&gt; eg:git checkout -b dev(相当于上面两条命令）合并某分支到当前分支：git merge &lt;name&gt; eg:git merge dev删除分支：git branch -d &lt;name&gt; eg:git branch -d dev #正文在Git里，master分支叫主分支。一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长： 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(7) git之自定义]]></title>
    <url>%2Fgit%2Fgit%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[实际上，Git还有很多可配置项。 ##让Git显示颜色，会让命令输出看起来更醒目： 1$ git config --global color.ui true 这样，Git会适当地显示不同的颜色，比如git status命令： 文件名就会标上颜色。 ##忽略特殊文件某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件等，每次git status都会显示Untracked files ... 在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 不需要从头写.gitignore文件，GitHub已经准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 举个例子： 假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件： 1234# Windows:Thumbs.dbehthumbs.dbDesktop.ini 然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录： 1234567# Python:*.py[cod]*.so*.egg*.egg-infodistbuild 加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下： 12345678910111213141516# Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa 最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。 使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。 有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了： 1234$ git add App.classThe following paths are ignored by one of your .gitignore files:App.classUse -f if you really want to add them. 如果你确实想添加该文件，可以用-f强制添加到Git： 1$ git add -f App.class 或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查： 12$ git check-ignore -v App.class.gitignore:3:*.class App.class Git会告诉我们，.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。 小结 忽略某些文件时，需要编写.gitignore； .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ #配置别名 比如敲git st就表示git status1$ git config --global alias.st status 当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch：123$ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch 以后提交就可以简写成： 1$ git ci -m &quot;bala bala bala...&quot; --global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。 命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：1$ git config --global alias.unstage &apos;reset HEAD&apos; 当你敲入命令：1$ git unstage test.py 实际上Git执行的是：1$ git reset HEAD test.py 配置一个git last，让其显示最后一次提交信息： 1$ git config --global alias.last &apos;log -1&apos; 这样，用git last就能显示最近一次的提交： 1234567$ git lastcommit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2Merge: bd6ae48 291bea8Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Thu Aug 22 22:49:22 2013 +0800 merge &amp; fix hello.py 甚至还有人丧心病狂地把lg配置成了：1git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; 来看看git lg的效果：为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！ 配置文件配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。 配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中： 12345678910111213141516$ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote &quot;origin&quot;] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master[alias] last = log -1 别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中： 123456789$ cat .gitconfig[alias] co = checkout ci = commit br = branch st = status[user] name = Your Name email = your@email.com 配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。 小结给Git配置好别名，就可以输入命令时偷个懒。]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(6) git之使用github]]></title>
    <url>%2Fgit%2Fgit%E4%B9%8B%E4%BD%BF%E7%94%A8github%2F</url>
    <content type="text"><![CDATA[#小结 在GitHub上，可以任意Fork开源仓库； 自己拥有Fork后的仓库的读写权限； 可以推送pull request给官方仓库来贡献代码。 正文参与一个开源项目 比如bootstrap项目，这是一个非常强大的CSS框架，访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：1git clone git@github.com:itswl/bootstrap.git 从自己账号下clone才可以推送，从原作者仓库地址clone会因为权限问题，不能推送修改。你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(2) git中的工作区与暂存区]]></title>
    <url>%2Fgit%2Fgit%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%B8%8E%E6%9A%82%E5%AD%98%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[#小结 工作区（Working Directory)就是电脑里能看到的目录。 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 git add实际上就是把文件修改添加到暂存区，git commit`实际上就是把暂存区的所有内容提交到当前分支。 git checkout -- file丢弃工作区的修改。 git reset HEAD &lt;file&gt;把暂存区的修改撤销掉（unstage），重新放回工作区。 从版本库中删除该文件，那就用命令git rm删掉，并且git commit 把误删的文件恢复到版本库的版本git checkout 工作区（Working Directory）就是电脑里能看到的目录，比如git文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 分支和HEAD的概念我们以后再讲。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： 123Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. 然后，在工作区新增一个LICENSE文本文件（内容随便写）。 先用git status查看一下状态： 1234567891011121314$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) LICENSEno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： 1234567$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: LICENSE modified: readme.txt 现在，暂存区的状态就变成这样了： 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 1234$ git commit -m &quot;understand how stage works&quot;[master e43a48b] understand how stage works 2 files changed, 2 insertions(+) create mode 100644 LICENSE 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： 123$ git statusOn branch masternothing to commit, working tree clean 现在版本库变成了这样，暂存区就没有任何内容了： Git跟踪并管理的是修改，而非文件。每次修改，如果不用git add到暂存区，那就不会加入到commit中第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit,只会管理到第一次修改。可以多次git add后一并git commit:第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt;git commitgit checkout -- file可以丢弃工作区的修改:git checkout -- readme.md，就是让这个文件回到最近一次git commit或git add时的状态。如果已经git add,但没有git commit,可以通过命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区。例如git reset HEAD readme.mdgit reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 已经提交了不合适的修改到版本库时，想要撤销本次提交，可以版本回退，不过前提是没有推送到远程库 ###文件删除新建一个test.txt文件到Git并提交，git add test.txt,git commit -m &quot;add test.txt&quot;。本地删除后，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 现在你有两个选择:1. 确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：1234567$ git rm test.txtrm &apos;test.txt&apos;$ git commit -m &quot;remove test.txt&quot;[master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 2. 删错了，版本库里还有，所以可以很轻松地把误删的文件恢复到版本库的版本：1$ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(4.4) git分支管理-Bug分支]]></title>
    <url>%2Fgit%2Fgit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-Bug%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[#小结 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 #正文当前正在dev上进行的工作还没有提交,但要先建立一个issue-101分支来修复BUG：Git提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： 现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： 现在，接着回到dev分支干活。 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：3&gt;工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了： 再用git stash list查看，就看不到任何stash内容了： **可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：git stash apply stash@{0}]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(4.5) git分支管理-feature分支]]></title>
    <url>%2Fgit%2Fgit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-feature%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[添加一个新功能时，不想把主分支搞乱。所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 eg:现在，加一个Vulcan的新功能，该功能计划用于下一代星际飞船。先添加feature-vulcan分支 12$ git checkout -b feature-vulcanSwitched to a new branch &apos;feature-vulcan&apos; 开发完毕： 123456789101112131415$ git add vulcan.py$ git statusOn branch feature-vulcanChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: hello.py new file: vulcan.pyChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.md 切回dev，准备合并：1$ git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 但是！ 就在此时，接到上级命令，因经费不足，新功能必须取消！ 虽然白干了，但是这个包含机密资料的分支还是必须就地销毁： 123$ git branch -d feature-vulcanerror: The branch &apos;feature-vulcan&apos; is not fully merged.If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。 现在我们强行删除： 12$ git branch -D feature-vulcanDeleted branch feature-vulcan (was 287773e). 终于删除成功！ 小结开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(4.7) git分支管理-rebase]]></title>
    <url>%2Fgit%2Fgit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-rebase%2F</url>
    <content type="text"><![CDATA[多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。 每次合并再push后，分支变成了这样： 12345678910111213141516171819$ git log --graph --pretty=oneline --abbrev-commit* d1be385 (HEAD -&gt; master, origin/master) init hello* e5e69f1 Merge branch &apos;dev&apos;|\ | * 57c53ab (origin/dev, dev) fix env conflict| |\ | | * 7a5e5dd add env| * | 7bd91f1 add new env| |/ * | 12a631b merged bug fix 101|\ \ | * | 4c805e2 fix bug 101|/ / * | e1e9c68 merge with no-ff|\ \ | |/ | * f52c633 add merge|/ * cf810e4 conflict fixed 总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？ 其实是可以做到的！ Git有一种称为rebase的操作，有人把它翻译成“变基”。 先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。 在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看： 1234567891011$ git log --graph --pretty=oneline --abbrev-commit* 582d922 (HEAD -&gt; master) add author* 8875536 add comment* d1be385 (origin/master) init hello* e5e69f1 Merge branch &apos;dev&apos;|\ | * 57c53ab (origin/dev, dev) fix env conflict| |\ | | * 7a5e5dd add env| * | 7bd91f1 add new env... 注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。 现在我们尝试推送本地分支： 123456789$ git push origin masterTo github.com:michaelliao/learngit.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &apos;git@github.com:michaelliao/learngit.git&apos;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下： 123456789101112$ git pullremote: Counting objects: 3, done.remote: Compressing objects: 100% (1/1), done.remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:michaelliao/learngit d1be385..f005ed4 master -&gt; origin/master * [new tag] v1.0 -&gt; v1.0Auto-merging hello.pyMerge made by the &apos;recursive&apos; strategy. hello.py | 1 + 1 file changed, 1 insertion(+) 再用git status看看状态： 123456$ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 3 commits. (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree clean 加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。 用git log看看： 123456789$ git log --graph --pretty=oneline --abbrev-commit* e0ea545 (HEAD -&gt; master) Merge branch &apos;master&apos; of github.com:michaelliao/learngit|\ | * f005ed4 (origin/master) set exit=1* | 582d922 add author* | 8875536 add comment|/ * d1be385 init hello... 对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？ 有！ 什么问题？ 不好看！ 有没有解决方法？ 有！ 这个时候，rebase就派上了用场。我们输入命令git rebase试试： 123456789101112$ git rebaseFirst, rewinding head to replay your work on top of it...Applying: add commentUsing index info to reconstruct a base tree...M hello.pyFalling back to patching base and 3-way merge...Auto-merging hello.pyApplying: add authorUsing index info to reconstruct a base tree...M hello.pyFalling back to patching base and 3-way merge...Auto-merging hello.py 输出了一大堆操作，到底是啥效果？再用git log看看： 123456$ git log --graph --pretty=oneline --abbrev-commit* 7e61ed4 (HEAD -&gt; master) add author* 3611cfe add comment* f005ed4 (origin/master) set exit=1* d1be385 init hello... 原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。 这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。 最后，通过push操作把本地分支推送到远程： 123456789Mac:~/learngit michael$ git push origin masterCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.Total 6 (delta 2), reused 0 (delta 0)remote: Resolving deltas: 100% (2/2), completed with 1 local object.To github.com:michaelliao/learngit.git f005ed4..7e61ed4 master -&gt; master 再用git log看看效果： 123456$ git log --graph --pretty=oneline --abbrev-commit* 7e61ed4 (HEAD -&gt; master, origin/master) add author* 3611cfe add comment* f005ed4 set exit=1* d1be385 init hello... 远程分支的提交历史也是一条直线。 小结 rebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(4.3) git分支管理-分支管理政策]]></title>
    <url>%2Fgit%2Fgit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E6%94%BF%E7%AD%96%2F</url>
    <content type="text"><![CDATA[小结 Git分支十分强大，在团队开发中应该充分应用。 2.合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 ###正文通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 首先，仍然创建并切换dev分支：修改readme.txt文件，并提交一个新的commit：然后切换回master：合并dev分支，请注意–no-ff参数，表示禁用Fast forward。因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去合并后，我们用git log看看分支历史：可以看到，不使用Fast forward模式，merge后就像这样： 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样：]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(1) git初识]]></title>
    <url>%2Fgit%2Fgit%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[#小结 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；使用命令git commit -m &lt;message&gt;，完成。 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 参照廖雪峰的git教程学习，感谢廖雪峰老师的教程。教程地址：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 git是分布式版本控制系统之一，直接在官网上下载安装 进入目录 比如d/WeiLai/Onedrive/study/git,然后git bash here,输入pwd显示当前目录。 输入 git init命令把这个目录变成Git可以管理的仓库提示Initialized empty Git repository in D:/WeiLai/OneDrive/study/git/.git/当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的这个目录默认是隐藏的，用ls -ah命令就可以看见 目录中新建一个文件 readme.md ,内容如下: Git is a version control system.Git is free software. git add readme.md 用git add把文件添加到仓库git commit -m &quot;wrote a readme file&quot;用命令git commit把文件提交到仓库(“wrote a readme file”本次提交的说明） 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： git add file1.txtgit add file2.txt file3.txtgit commit -m &quot;add 3 files.&quot; 对readme.md进行修改如下: Git is a distributed version control system.Git is free software. 修改readme.md后，输入git status命令可以让我们时刻掌握仓库当前的状态。(可以查看到readme.md被修改但未提交。) 使用 git diff命令查看具体修改内容，git diff readme.md 查看完后（同前面），可通过git add(添加) ,git status(查看当前状态),git committ(提交)。 再次对readme.md进行如下修改: Git is a distributed version control system.Git is free software distributed under the GPL. 然后尝试提交：1234$ git add readme.md$ git commit -m &quot;append GPL&quot;[master 1094adb] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) #####readme.md文件一共有3个版本被提交到Git仓库里了： 版本1：wrote a readme file Git is a version control system.Git is free software. 版本2：add distributed Git is a distributed version control system.Git is free software. 版本3：append GPL Git is a distributed version control system.Git is free software distributed under the GPL. 也用git log命令查看历史记录(git log命令显示从最近到最远的提交日志)12345678910111213141516171819imwl@DESKTOP-V2KTJSJ MINGW64 /d/WeiLai/Onedrive/study/git (master)$ git logcommit d730a1998de2ac8a90b24482563756eb9b400b88 (HEAD -&gt; master)Author: itswl &lt;imwl@live.com&gt;Date: Mon Nov 5 19:14:32 2018 +0800 append GPLcommit 8fd1e66ce9631da4fea19205b4f737abcb81f059Author: itswl &lt;imwl@live.com&gt;Date: Mon Nov 5 18:47:48 2018 +0800 add distributedcommit 123e3165aafcea2a49c050beba5f9d2b0099a2eaAuthor: itswl &lt;imwl@live.com&gt;Date: Mon Nov 5 18:29:10 2018 +0800 wrote a readme file 使用git log –pretty=oneline只显示commit id 和提交说明12345imwl@DESKTOP-V2KTJSJ MINGW64 /d/WeiLai/Onedrive/study/git (master)$ git log --pretty=onelined730a1998de2ac8a90b24482563756eb9b400b88 (HEAD -&gt; master) append GPL8fd1e66ce9631da4fea19205b4f737abcb81f059 add distributed123e3165aafcea2a49c050beba5f9d2b0099a2ea wrote a readme file 在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD\^，上上一个版本就是HEAD\^\^，往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 当前版本append GPL回退到上一个版本add distributed，可以使用git reset命令：12$ git reset --hard HEAD^HEAD is now at 8fd1e66 add distributed readme.md已被还原成第2个版本123$ cat readme.mdGit is a distributed version control system.Git is free software. git log再看看现在版本库的状态1234567891011commit 8fd1e66ce9631da4fea19205b4f737abcb81f059 (HEAD -&gt; master)Author: itswl &lt;imwl@live.com&gt;Date: Mon Nov 5 18:47:48 2018 +0800 add distributedcommit 123e3165aafcea2a49c050beba5f9d2b0099a2eaAuthor: itswl &lt;imwl@live.com&gt;Date: Mon Nov 5 18:29:10 2018 +0800 wrote a readme file 第3个版本已经没有了，找到那个append GPL的commit id是d730a…，于是就可以指定回到未来的某个版本：12$ git reset --hard d730aHEAD is now at d730a19 append GPL 版本号不用写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 再查看readme.md的内容：123$ cat readme.mdGit is a distributed version control system.Git is free software distributed under the GPL Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL： 改为指向add distributed： 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 当你用git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：1234567imwl@DESKTOP-V2KTJSJ MINGW64 /d/WeiLai/Onedrive/study/git (master)$ git reflogd730a19 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to d730a8fd1e66 HEAD@&#123;1&#125;: reset: moving to HEAD^d730a19 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL8fd1e66 HEAD@&#123;3&#125;: commit: add distributed123e316 HEAD@&#123;4&#125;: commit (initial): wrote a readme file]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(5) git标签管理]]></title>
    <url>%2Fgit%2Fgit%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[#小结1 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； 命令git tag可以查看所有标签。 #小结2 命令git push origin &lt;tagname&gt;可以推送一个本地标签；2 .命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 #正文Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针。tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 ###创造标签在Git中打标签非常简单，首先，切换到需要打标签的分支上：12345$ git branch* dev master$ git checkout masterSwitched to branch &apos;master&apos; 然后，敲命令git tag &lt;name&gt;就可以打一个新标签：可以用命令git tag查看所有标签：1234$ git tag v1.0$ git tagv1.0 默认标签是打在最新提交的commit上的。应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了：12345678910111213141516$ git log --pretty=oneline --abbrev-commit12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 1014c805e2 fix bug 101e1e9c68 merge with no-fff52c633 add mergecf810e4 conflict fixed5dc6824 &amp; simple14096d0 AND simpleb17d20e branch testd46f35e remove test.txtb84166e add test.txt519219b git tracks changese43a48b understand how stage works1094adb append GPLe475afc add distributedeaadf4e wrote a readme file 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：git tag v0.9 f52c633再用命令git tag查看标签：123$ git tagv0.9v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt;tagname&gt;查看标签信息：123456789$ git show v0.9commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:56:54 2018 +0800 add mergediff --git a/readme.txt b/readme.txt... 可以看到，v0.9确实打在add merge这次提交上。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：1$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb 用命令git show &lt;tagname&gt;可以看到说明文字：123456789101112131415$ git show v0.1tag v0.1Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 22:48:43 2018 +0800version 0.1 releasedcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLdiff --git a/readme.txt b/readme.txt... 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 ###操作标签如果标签打错了，也可以删除：12$ git tag -d v0.1Deleted tag &apos;v0.1&apos; (was f15b0dd) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。推送某个标签到远程，使用命令git push origin ：1234$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag] v1.0 -&gt; v1.0 或者，一次性推送全部尚未推送到远程的本地标签：1234$ git push origin --tagsTotal 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag] v0.9 -&gt; v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：12$ git tag -d v0.9Deleted tag &apos;v0.9&apos; (was f52c633) 然后，从远程删除。删除命令也是push，但是格式如下：123$ git push origin :refs/tags/v0.9To github.com:michaelliao/learngit.git - [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(4.2) git分支管理-解决冲突.md]]></title>
    <url>%2Fgit%2Fgit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[#小结 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log –graph命令可以看到分支合并图。 #正文 有两个分支，master 和 feature1分别有新的提交：Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突：readme.md文件存在冲突，必须手动解决冲突后再提交。git status也可以冲突显示文件：查看readme.md文件：Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容修改然后提交 现在，master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： 1234567891011$ git log --graph --pretty=oneline --abbrev-commit* 8306d83 (HEAD -&gt; master) conflict fixed|\| * 6595182 (feature1) branch test* | f239080 &amp; simple|/* b1f5a38 branch test* 4046b17 (origin/master, origin/HEAD) add test.txt* d730a19 append GPL* 8fd1e66 add distributed* 123e316 wrote a readme file 最后，删除feature1分支： 12$ git branch -d feature1Deleted branch feature1 (was 14096d0). 工作完成。]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(3) git远程仓库]]></title>
    <url>%2Fgit%2Fgit%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。一般找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。也可使用github远程仓库Git仓库和GitHub仓库之间的传输是通过SSH加密的，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1$ ssh-keygen -t rsa -C &quot;imwl@live.com&quot; 把邮件地址换成自己的邮件地址，然后一路回车，使用默认值即可。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 点“Add Key”，你就应该看到已经添加的Key：]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VPS搭建SSR过程]]></title>
    <url>%2Fvps%2FVPS%E6%90%AD%E5%BB%BASSR%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[首先我们得先有一个VPS。我用的vultr，已经用了快两年了吧，能用支付宝和微信支付，也挺便宜的，我选的3.5美元一月的。这是我的邀请地址https://www.vultr.com/?ref=7349334。点地址进去注册好像都有奖励啥!的，不过从来没有人点我的邀请地址，我之前给别人介绍的时候也是直接让他们去官网上直接注册，感觉亏大了😄。 这个billing是支付首先可以先建一个VPS 先在网页中那个加+号，然后选择VPS所在地址，我自己选的Los,感觉应该日本新加坡的延迟会低一点吧0.0，但我现在用的挺好的，也没去换。就只是换了一个便宜的资费，以前并没有3.5刀一月的。 我选的就是图中的，debian 9 然后3.5刀的，我需求较少，自用足够了了。 然后通过SSH，登录到VPS上搭建ssr。我个人用的是brook,brook自带PAC模式，并且还很精准。我ssh使用的是MobaXterm_Portable。下载地址https://mobaxterm.mobatek.net/download-home-edition.html。以root的方式登录，然后输入密码，就会出现以下界面。然后刷入SSR一键代码来自秋水逸冰的博客 把下面这三段代码分三次复制粘贴到putty或者终端并按回车运行： 第一段（此段较长，请全部复制粘贴到putty，然后按回车键运行，点击右键即可粘贴） wget –no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh#从github上下载shadowsocks-all.sh第二段（同样复制粘贴然后运行） chmod +x shadowsocks-all.sh#给shadowsocks-all.sh 执行权限第三段 ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log\运行并记录 下面就是安装过程 我选的是2，shadowsocksR,后面的过程可以默认，一直点回车，也可以更改配置。最后安装成功后也会提示所安装的信息。也可以通过vi /etc/shadowsocks-r/config.json 修改配置提速现在自带bbr提速，所以不用更改。。一些常用相关命令修改SSR密码或者协议 vi /etc/shadowsocks-r/config.json（改了密码后需要重启SS）SSR重启 /etc/init.d/shadowsocks-r restart查看SSR状态 /etc/init.d/shadowsocks-r status卸载SSR ./shadowsocks-all.sh uninstall 做到以上服务器端SSR就搭建完成了，然后就是配置客户端了。路由器有些路由器自带SSR，把配置信息填进去就可以用了。我用的裴讯K2P刷了一个openwrt固件，然后可用SSR。路由器好处是，手机电脑可以不用下载客户端，连上网就可以使用SSR带来的功能😊手机端ios可用shaodowrocket,potatso 2等，当然国区不行0.0Android可用SSR，SSRR等https://github.com/shadowsocksrr/shadowsocksr-android/releases电脑端可用SSR等Brook配置过程参考https://doub.io/brook-jc1/使用一键脚本系统要求：CentOS 6+ / Debian 6+ / Ubuntu 14.04 +安装步骤执行下面的代码下载并运行脚本。 wget -N –no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/brook.sh &amp;&amp; chmod +x brook.sh &amp;&amp; bash brook.sh运行脚本后会出现脚本操作菜单，选择并输入 1 就会开始安装。进入下载脚本的目录并运行脚本：12345678910111213141516171819202122232425262728293031323334353637383940./brook.sh然后选择你要执行的选项即可。 Brook 一键管理脚本 [vx.x.x] ---- Toyo | doub.io/brook-jc3 ---- 0. 升级脚本———————————— 1. 安装 Brook 2. 升级 Brook 3. 卸载 Brook———————————— 4. 启动 Brook 5. 停止 Brook 6. 重启 Brook———————————— 7. 设置 账号配置 8. 查看 账号信息 9. 查看 日志信息10. 查看 链接信息———————————— 当前状态: 已安装 并 已启动 请输入数字 [0-10]:其他操作启动：/etc/init.d/brook start停止：/etc/init.d/brook stop重启：/etc/init.d/brook restart查看状态：/etc/init.d/brook status安装目录：/usr/local/brook配置文件：/usr/local/brook/brook.conf日志文件：/usr/local/brook/brook.log（注意正常情况下，日志是不会记录使用信息的，只会记录报错） brook客户端ios： app store 上目前还有，只是没怎么更新。其他客户端：https://github.com/txthinking/brook/releases]]></content>
      <categories>
        <category>VPS</category>
      </categories>
  </entry>
</search>
