<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[有关于@property]]></title>
    <url>%2Fpython%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F%E6%9C%89%E5%85%B3%E4%BA%8E%40property%2F</url>
    <content type="text"><![CDATA[有关于@property1. 将方法改为属性这种类型的attributes并不会被实际的存储，而是在需要的时候计算出来 1234567891011121314151617181920import mathclass Circle: def __init__(self, radius): self.radius = radius def area(self): return math.pi * self.radius ** 2 @property def diameter(self): return self.radius * 2 @property def perimeter(self): return 2 * math.pi * self.radiusc = Circle(3)print(c.area()) # 方法调用print(c.diameter) # 属性访问print(c.perimeter) 2. 做限定参考前文 3.]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[上下文管理器]]></title>
    <url>%2Fpython%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[上下文管理器让对象支持上下文管理器对象需要定义 __enter__ 和 __exit__1234567891011121314151617181920212223242526272829303132333435from socket import socket, AF_INET, SOCK_STREAMclass LazyConnection: def __init__(self, address, family=AF_INET, type=SOCK_STREAM): self.address = address self.family = family self.type = type self.sock = None def __enter__(self): if self.sock is not None: raise RuntimeError(&apos;Already connected&apos;) self.sock = socket(self.family, self.type) self.sock.connect(self.address) return self.sock def __exit__(self, exc_ty, exc_val, tb): # 异常类型，异常值和异常的trackback self.sock.close() self.sock = None #return True 如果这里返回True 则代表不处理with中的异常if __name__ == &apos;__main__&apos;: from functools import partial conn = LazyConnection((&apos;www.python.org&apos;, 80)) # Connection closed with conn as s: # conn.__enter__() executes: connection open s.send(b&apos;GET /index.html HTTP/1.0\r\n&apos;) s.send(b&apos;Host: www.python.org\r\n&apos;) s.send(b&apos;\r\n&apos;) resp = b&apos;&apos;.join(iter(partial(s.recv, 8192), b&apos;&apos;)) print(resp) # conn.__exit__() executes: connection closed 线程安全修改版12345678910111213141516171819202122232425262728293031323334353637383940from socket import socket, AF_INET, SOCK_STREAMimport threadingclass LazyConnection: def __init__(self, address, family=AF_INET, type=SOCK_STREAM): self.address = address self.family = AF_INET self.type = SOCK_STREAM self.local = threading.local() def __enter__(self): if hasattr(self.local, &apos;sock&apos;): raise RuntimeError(&apos;Already connected&apos;) self.local.sock = socket(self.family, self.type) self.local.sock.connect(self.address) return self.local.sock def __exit__(self, exc_ty, exc_val, tb): self.local.sock.close() del self.local.sockfrom functools import partialdef test(conn): with conn as s: s.send(b&apos;GET /index.html HTTP/1.0\r\n&apos;) s.send(b&apos;Host: www.huawei.com\r\n&apos;) s.send(b&apos;\r\n&apos;) resp = b&apos;&apos;.join(iter(partial(s.recv, 8192), b&apos;&apos;)) print(&apos;Got &#123;&#125; bytes&apos;.format(len(resp)))if __name__ == &apos;__main__&apos;: conn = LazyConnection((&apos;www.huawei.com&apos;, 80)) t1 = threading.Thread(target=test, args=(conn,)) t2 = threading.Thread(target=test, args=(conn,)) t1.start() t2.start() t1.join() t2.join() 使用 contexlib 模块中的 @contextmanager装饰器实现一个新的上下文管理器的最简单的方法 yield 之前的代码会在上下文管理器中作为 __enter__() 方法执行，所有在 yield 之后的代码会作为 __exit__() 方法执行 先执行print(&#39;《&#39;, end=&#39;&#39;)，遇到yeild ,执行 print(&#39;挪威的森林&#39;,end=&#39;&#39;) , 最后执行 print(&#39;》&#39;, end=&#39;&#39;)123456789101112from contextlib import contextmanager@contextmanagerdef book_mark(): print(&apos;《&apos;, end=&apos;&apos;) yield print(&apos;》&apos;, end=&apos;&apos;)with book_mark(): print(&apos;挪威的森林&apos;,end=&apos;&apos;) # 《挪威的森林》 123456789101112131415161718import timeclass timethis: def __init__(self, label): self.label = label def __enter__(self): self.start = time.time() print(f&apos;start = &#123;self.start&#125;&apos;) def __exit__(self, exc_ty, exc_val, exc_tb): end = time.time() print(f&apos;&#123;end = &#125;&apos;) print(&apos;&#123;&#125;: &#123;&#125;&apos;.format(self.label, end - self.start)) with timethis(&apos;counting&apos;): n = 10000000 while n &gt; 0: n -= 1 使用from contextlib import contextmanager12345678910111213141516171819import timefrom contextlib import contextmanager@contextmanagerdef timethis(label): start = time.time() print(f&apos;&#123;start = &#125;&apos;) try: yield finally: end = time.time() print(f&apos;&#123;end = &#125;&apos;) print(f&apos;&#123;label&#125; : &#123;end - start&#125;&apos;)# Example usewith timethis(&apos;counting&apos;): n = 10000000 while n &gt; 0: n -= 1 任何对列表的修改只有当所有代码运行完成并且不出现异常的情况下才会生效123456789101112131415161718192021222324 from contextlib import contextmanager@contextmanagerdef list_transaction(orig_list): working = list(orig_list) yield working orig_list[:] = working # 任何对列表的修改只有当所有代码运行完成并且不出现异常的情况下才会生效items = [1,2,3]with list_transaction(items) as working: working.append(4) working.append(5)print(items) # [1,2,3,4,5]with list_transaction(items) as working: working.append(6) working.append(7) working是[1,2,3,4,5,6,7] raise RuntimeError(&apos;oops&apos;) 执行不了orig_list[:] = workingprint(items) ## 还是 [1,2,3,4,5]]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2Fpython%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[待解决dataclass + __solts__的问题 __solts__ 使用slots一个不好的地方就是我们不能再给实例添加新的属性了，只能使用在 __slots__ 中定义的那些属性名 使用__solts__,python实例通过一个很小的固定大小的数组来构建，而不是为每个实例定义一个字典，这跟元组或列表很类似.Python的很多特性都依赖于普通的基于字典的实现。另外，定义了slots后的类不再支持一些普通类特性了，比如多继承。 尽量不要使用 __solts__ github上相关问题 多加一个装饰器 基础1234567891011121314151617181920212223class Color(): r = 200 def __init__(self,r=250): self.r = r self.g = self.get_g() self.b = self.get_b def get_g(self): g = 223 return g @property def get_b(self): b = 222 return b def __str__(self): return f&apos;&#123;self.__class__.__name__&#125;(class_r = &#123;self.__class__.r&#125;, r = &#123;self.r&#125;, g = &#123;self.g&#125;, b = &#123;self.b&#125;)&apos;color = Color(255)color1 = Color()print(color) # Color(class_r = 200, r = 255, g = 223, b = 222)print(color1) # Color(class_r = 200, r = 250, g = 223, b = 222) 1234567891011121314151617181920class Color(): r = 200 def __init__(self): self.g = self.get_g() self.b = self.get_b def get_g(self): g = 223 return g @property def get_b(self): b = 222 return b def __str__(self): return f&apos;&#123;self.__class__.__name__&#125;(class_r = &#123;self.__class__.r&#125;, r = &#123;self.r&#125;, g = &#123;self.g&#125;, b = &#123;self.b&#125;)&apos;color = Color()print(color) # Color(class_r = 200, r = 255, g = 223, b = 222) 使用第三方插件修改一下1234567891011121314151617from attr import attrs, attrib # dataclass 内置库可替代&apos;&apos;&apos;attrs 修饰符，可以自动实现__init__,__repr__,__eq__,__ne__,__it__,__le__,__gt__,__ge__,__hash__,这几个方法&apos;&apos;&apos;@attrsclass Color(): r = attrib(type=int, default=100) g = attrib(type=int, default=200) b = attrib(type=int, default=222)color = Color(255,254,253)color1 = Color()print(color) # Color(class_r = 200, r = 255, g = 223, b = 222)print(color1) # Color(class_r = 200, r = 250, g = 223, b = 222) 声明和比较123456789101112131415from attr import attrs, attrib # dataclass内置库可替代&apos;&apos;&apos;attrs 修饰符，可以自动实现__init__,__repr__,__eq__,__ne__,__it__,__le__,__gt__,__ge__,__hash__,这几个方法&apos;&apos;&apos;@attrsclass Point(): x = attrib() y = attrib()p1 = Point(1,2)p2 = Point(y=3,x=4)print(p1,p2) # Point(x=1, y=2) Point(x=4, y=3) 使用python3.7 的内置库12345678910from dataclasses import dataclass@dataclassclass Point(): x:int = 0 y:int = 0p1 = Point(1,2)p2 = Point(y=3,x=4)print(p1,p2) # Point(x=1, y=2) Point(x=4, y=3) 1234567891011# 默认init,repr,eq 为True， 其余为False@dataclass(init=1,repr=1,eq=1,order=1,unsafe_hash=0,frozen=0)class Point(): x:int = 0 y:int = 0p1 = Point(1,2)p2 = Point(y=3,x=4)p3 = Point(x=1,y=2)print(p1&gt;p2) # fasleprint(p1==p3) # True 1234567891011from dataclasses import dataclass@dataclass(frozen=1)class Point(): x:int = 0 y:int = 0p1 = Point(1,2)print(p1) # 当实例化一个frozen 对象时，任何企图修改对象属性的行为都会引发 FrozenInstanceError#p1.x = 10 # dataclasses.FrozenInstanceError: cannot assign to field &apos;x&apos; 1234567891011121314from dataclasses import dataclass@dataclass()class Point(): x:int = 0 y:int = 0 def x_add_1(self): self.x += 1p1 = Point(1,2)print(p1) # Point(x=1, y=2)p1.x_add_1()print(p1) # Point(x=2, y=2) __init__方法在返回前会调用__post_init__123456789101112from dataclasses import dataclass@dataclass()class Point(): x:int = 0 y:int = 0 def __post_init__(self): self.x += 1 p1 = Point(1,2)print(p1) # Point(x=2, y=2) 有关继承12345678910111213141516from dataclasses import dataclass@dataclassclass Point: x:int = 0 y:int = 0 def __post_init__(self): self.x += 1@dataclassclass ThirdPonit(Point): z:int =0ppp = ThirdPonit(1,3,4)print(ppp) # ThirdPonit(x=2, y=3, z=4) super1234567891011121314151617181920from dataclasses import dataclass@dataclassclass Point: x:int = 0 y:int = 0 def __post_init__(self): self.x += 1@dataclassclass ThirdPonit(Point): z:int =0 def __post_init__(self): super().__post_init__() # 调用 父类的__post_init__() self.x += 10ppp = ThirdPonit(1,3,4)print(ppp) # ThirdPonit(x=12, y=3, z=4) 复合初始化12345678910111213141516import randomfrom dataclasses import dataclassdef get_random_marks(): return [random.randint(1,10) for _ in range(5)]@dataclassclass Student: marks:list = list def __post_init__(self): # 额外的工作 self.marks = get_random_marks()a = Student()print(a) # Student(marks=[2, 9, 8, 8, 2])print(a.marks) # [2, 9, 8, 8, 2] 修改123456789101112131415161718192021import randomfrom dataclasses import dataclass, fielddef get_random_marks(): return [random.randint(1,10) for _ in range(5)]@dataclassclass Student: marks:int = field(default_factory= get_random_marks) # int 不建议，建议使用数据类型 # default_factory ：如果在创建对象时没赋值，则使用该方法初始化该字段 （必须是可以调用的无参数方法） # 使用 get_random_marks 方法 初始化 marks a = Student()print(a) # Student(marks=[7, 2, 4, 7, 4])print(a.marks) # [7, 2, 4, 7, 4]print(type(a.marks)) # &lt;class &apos;list&apos;&gt;b = Student(&apos;b&apos;) # 传参则不影响print(b) # Student(marks=&apos;b&apos;)print(b.marks) # bprint(type(b.marks)) # &lt;class &apos;str&apos;&gt; filed 更多操作123456789101112131415from dataclasses import dataclass, field@dataclass(order=1)class Number: number:int = field(compare= False,repr= False) # number 不进行比较,不打印 val:int verified:1 = field(default=0,init=0) # 默认为 1，不进行初始化a = Number(3,4)b = Number(4,3)print(a &lt; b) # Falseprint(a) # Number(val=4, verified=0)print(b) # Number(val=3, verified=0)b.verified = 1print(b) # Number(val=3, verified=1)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多进程]]></title>
    <url>%2Fpython%2F%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多进程多进程 Multiprocessing 和多线程 threading 类似，用来弥补 threading 的一些劣势（例如GIL）， Python 出了一个 multiprocessing 多进程与多线程使用方法几乎一致1234567891011121314151617import multiprocessingimport threadingdef job_t(a,d): print(&apos;tttt&apos;)def job_p(a,d): print(&apos;pppp&apos;)t1 = threading.Thread(target=job_t,args=(1,2))p1 = multiprocessing.Process(target=job_p,args=(1,2))t1.start()p1.start()t1.join()p1.join() 进程结果 Queue()123456789101112131415161718192021import multiprocessing as mpdef job(q): res=0 for i in range(1000): res+=i+i**2+i**3 q.put(res) #queueif __name__==&apos;__main__&apos;: q = mp.Queue() p1 = mp.Process(target=job,args=(q,)) p2 = mp.Process(target=job,args=(q,)) p1.start() p2.start() p1.join() p2.join() res1 = q.get() print(res1) res2 = q.get() print(res2) print(res1+res2) 效率对比1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import timeimport multiprocessing import threadingdef _cost_time(func): def warpper(*args,**kw): start_time = time.time() func(*args,**kw) end_time = time.time() print(&apos;cost time :&apos;,end_time - start_time) return warpper def job(q): res = 0 for i in range(1000000): res += i + i**2 + i**3 q.put(res) # queue@_cost_timedef normal(): res = 0 for _ in range(2): for i in range(1000000): res += i + i**2 + i**3 print(&apos;normal:&apos;, res) @_cost_timedef multithread(): q = multiprocessing.Queue() t1 = threading.Thread(target=job, args=(q,)) t2 = threading.Thread(target=job, args=(q,)) t1.start() t2.start() t1.join() t2.join() res1 = q.get() res2 = q.get() print(&apos;multithread:&apos;, res1 + res2)@_cost_timedef multicore(): q = multiprocessing.Queue() p1 = multiprocessing .Process(target=job, args=(q,)) p2 = multiprocessing .Process(target=job, args=(q,)) p1.start() p2.start() p1.join() p2.join() res1 = q.get() res2 = q.get() print(&apos;multicore:&apos;,res1 + res2)normal()multithread()multicore() 打印结果123456(&apos;normal:&apos;, 499999666667166666000000L)(&apos;cost time :&apos;, 0.8630490303039551)(&apos;multithread:&apos;, 499999666667166666000000L)(&apos;cost time :&apos;, 1.8854999542236328)(&apos;multicore:&apos;, 499999666667166666000000L)(&apos;cost time :&apos;, 0.47038793563842773) 耗时 多进程 &lt; 普通 &lt; 多线程 。 多线程不适合计算密集型]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[格式化字符串]]></title>
    <url>%2Fpython%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[实例的字符串显示1234567891011121314class Pair: def __init__(self, x, y): self.x = x self.y = y def __repr__(self): return f&apos;(&#123;self.x&#125;, &#123;self.y&#125;)&apos; def __str__(self): return f&apos;Pair(&#123;self.x=&#125;, &#123;self.y=&#125;)&apos;p = Pair(3, 4)print(p) 12345678from dataclasses import dataclass@dataclassclass Pair: x:int y:int = 0 # y 默认值为0p = Pair(3, 4)print(p) 对象自定义格式化12345678910111213141516171819202122232425_formats = &#123; &apos;ymd&apos;: &apos;&#123;d.year&#125;-&#123;d.month&#125;-&#123;d.day&#125;&apos;, &apos;mdy&apos;: &apos;&#123;d.month&#125;/&#123;d.day&#125;/&#123;d.year&#125;&apos;, &apos;dmy&apos;: &apos;&#123;d.day&#125;/&#123;d.month&#125;/&#123;d.year&#125;&apos;&#125;class Date: def __init__(self, year, month, day): self.year = year self.month = month self.day = day def __format__(self, code): if code == &apos;&apos;: code = &apos;ymd&apos; fmt = _formats[code] return fmt.format(d=self)d = Date(2012, 12, 21)print(d)print(format(d, &apos;mdy&apos;))print(&apos;The date is &#123;:ymd&#125;&apos;.format(d))print(&apos;The date is &#123;:mdy&#125;&apos;.format(d)) 修改后12345678910111213141516171819202122232425from dataclasses import dataclass_formats = &#123; &apos;ymd&apos;: &apos;&#123;d.year&#125;-&#123;d.month&#125;-&#123;d.day&#125;&apos;, &apos;mdy&apos;: &apos;&#123;d.month&#125;/&#123;d.day&#125;/&#123;d.year&#125;&apos;, &apos;dmy&apos;: &apos;&#123;d.day&#125;/&#123;d.month&#125;/&#123;d.year&#125;&apos;&#125;@dataclassclass Date: year:int month:int day:int def __format__(self, code): if code == &apos;&apos;: code = &apos;ymd&apos; fmt = _formats[code] return fmt.format(d=self)a = Date(2012, 12, 21)print(a)print(format(a, &apos;mdy&apos;))print(&apos;The date is &#123;:ymd&#125;&apos;.format(a))print(&apos;The date is &#123;:mdy&#125;&apos;.format(a))]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[调用父类方法]]></title>
    <url>%2Fpython%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[调用父类方法super() 为了调用父类(超类)的一个方法，可以使用 super() 函数 12345678910111213141516class A: def spam(self): print(&apos;A.spam&apos;)class B(A): def spam(self): print(&apos;B.spam&apos;) super().spam() # Call parent spam()b = B()b.spam()&apos;&apos;&apos; 输出结果B.spam 先调用 B 的 spamA.spam 然后再调用 A 的 spam&apos;&apos;&apos; super() 函数的一个常见用法是在 __init__() 方法中确保父类被正确的初始化了1234567891011class A: def __init__(self): self.x = 0class B(A): def __init__(self): super().__init__() self.y = 1b = B()print(b.x,b.y) # 0,1 使用dataclasses改写123456789101112from dataclasses import dataclass@dataclassclass A: x:int = 0@dataclassclass B(A): y:int = 1b = B()print(b) # B(x=0, y=1) 123456789101112131415161718192021222324class Father: def __init__(self, name): self.name = name print(&quot;init Father&apos;s name&quot;)class Mather: def __init__(self, age): self.age = age print(&quot;init Mather&apos;s age&quot;)class Son(Father, Mather): def __init__(self, name, age, sex): super().__init__(name) # 先继承 Father 的 name super(Father, self).__init__(age) # 继承后 再继承 Mother 的age self.sex = sex # 最后 实例化自己的 sex print(&quot;init Son&apos;s sex&quot;)if __name__ == &quot;__main__&quot;: son = Son(&quot;Tom&quot;, 5, &quot;Male&quot;) print(Son.__mro__) # (&lt;class &apos;__main__.Son&apos;&gt;, &lt;class &apos;__main__.Father&apos;&gt;, &lt;class &apos;__main__.Mather&apos;&gt;, &lt;class &apos;object&apos;&gt;) print(son.name, son.age, son.sex) 12345678910111213141516171819202122from dataclasses import dataclass@dataclassclass Father: name:str print(&quot;init Father&apos;s name&quot;)@dataclassclass Mather: age:int print(&quot;init Mather&apos;s age&quot;)@dataclassclass Son(Father, Mather): sex:str print(&quot;init Son&apos;s sex&quot;)if __name__ == &quot;__main__&quot;: son = Son(name=&quot;Tom&quot;, age=5, sex=&quot;Male&quot;) # 这个会先实例化age,再name,再sex print(Son.__mro__) # (&lt;class &apos;__main__.Son&apos;&gt;, &lt;class &apos;__main__.Father&apos;&gt;, &lt;class &apos;__main__.Mather&apos;&gt;, &lt;class &apos;object&apos;&gt;) print(son) MRO列表Python会在MRO列表上继续搜索下一个类。只要每个重定义的方法统一使用 super() 并只调用它一次，那么控制流最终会遍历完整个MRO列表，每个方法也只会被调用一次super()有个令人吃惊的地方是它并不一定去查找某个类在MRO中下一个直接父类，你甚至可以在一个没有直接父类的类中使用它 123456789101112131415161718class A: def spam(self): print(&apos;A.spam&apos;) super().spam()class B: def spam(self): print(&apos;B.spam&apos;)class C(A,B): passc = C()print(C.__mro__) # (&lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;object&apos;&gt;)c.spam() &apos;&apos;&apos;A.spamB.spam&apos;&apos;&apos; 12345678910class C(B,A): passc = C()print(C.__mro__) # (&lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;object&apos;&gt;)c.spam() &apos;&apos;&apos;B.spam&apos;&apos;&apos;# 不会报错，只会执行 B下面的 关于super()由于 super() 可能会调用不是你想要的方法，你应该遵循一些通用原则。首先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)。这样可以确保 super() 调用一个非直接父类方法时不会出错。其次，最好确保最顶层的类提供了这个方法的实现，这样的话在MRO上面的查找链肯定可以找到某个确定的方法。 在Python社区中对于 super() 的使用有时候会引来一些争议。尽管如此，如果一切顺利的话，你应该在你最新代码中使用它。Raymond Hettinger为此写了一篇非常好的文章Python’s super() Considered Super通过大量的例子向我们解释了为什么 super() 是极好的。]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2Fpython%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[添加线程1234567891011121314151617import threadingdef main1(): print(threading.active_count()) # 获取已激活的线程数 print(threading.enumerate()) # 查看所有线程信息 print(threading.current_thread()) # 查看现在正在运行的线程def thread_job(): print(&apos;This is a thread of %s&apos; % threading.current_thread())def main(): thread = threading.Thread(target=thread_job,) # 定义线程 thread.start() # 让线程开始工作 if __name__ == &apos;__main__&apos;: main1() main() join功能使用join()主线程一直等待全部的子线程结束之后，主线程自身才结束( print(&#39;all done\n&#39;))，程序退出123456789101112131415161718192021222324import threadingimport timedef T1_job(): print(&apos;T1 start\n&apos;) for i in range(10): time.sleep(0.1) print(&apos;T1 finish\n&apos;)def T2_job(): print(&apos;T2 start\n&apos;) print(&apos;T2 finish\n&apos;)def main(): T1_thread = threading.Thread(target=T1_job, name=&apos;T1&apos;) T2_thread = threading.Thread(target=T2_job, name=&apos;T2&apos;) T1_thread.start() T2_thread.start() T1_thread.join() T2_thread.join() print(&apos;all done\n&apos;) if __name__ == &apos;__main__&apos;: main() 线程锁不使用线程锁1234567891011121314151617181920212223import threadingdef job1(): global A for i in range(10): A+=1 print(&apos;job1&apos;,A)def job2(): global A for i in range(10): A+=10 print(&apos;job2&apos;,A)if __name__== &apos;__main__&apos;: lock=threading.Lock() A=0 t1=threading.Thread(target=job1) t2=threading.Thread(target=job2) t1.start() t2.start() t1.join() t2.join() 打印结果,很杂乱12345678910111213141516171819job1 job2111job1 job21222job1job2 3323job2job1 4344job2job1 5554job2job1 6566job2job1 7677job2job1 8788job2job1 9899job2job1 110109 使用线程锁lock在不同线程使用同一共享内存时，能够确保线程之间互不影响123456789101112131415161718192021222324252627import threadingdef job1(): global A,lock lock.acquire() # 在每个线程执行运算修改共享内存之前，执行lock.acquire()将共享内存上锁， 确保当前线程执行时，内存不会被其他线程访问 for i in range(10): A+=1 print(&apos;job1&apos;,A) lock.release() # 执行运算完毕后，使用lock.release()将锁打开， 保证其他的线程可以使用该共享内存def job2(): global A,lock lock.acquire() for i in range(10): A+=10 print(&apos;job2&apos;,A) lock.release()if __name__== &apos;__main__&apos;: lock=threading.Lock() A=0 t1=threading.Thread(target=job1) t2=threading.Thread(target=job2) t1.start() t2.start() t1.join() t2.join() 打印结果1234567891011121314151617181920job1 1job1 2job1 3job1 4job1 5job1 6job1 7job1 8job1 9job1 10job2 20job2 30job2 40job2 50job2 60job2 70job2 80job2 90job2 100job2 110 储存进程结果 Queue123456789101112131415161718192021222324252627282930313233import threadingimport timefrom queue import Queuedef job(l,q): &apos;&apos;&apos; 对列表的每个元素进行平方计算，将结果保存在队列中 &apos;&apos;&apos; for i in range (len(l)): l[i] = l[i]**2 q.put(l) # 多线程调用的函数不能用return返回值def multithreading(): q = Queue() # q 中存放返回值，代替return的返回值 data = [[1,2,3],[3,4,5],[4,4,4],[5,5,5]] threads = [] for i in range(4): t = threading.Thread(target=job,args=(data[i],q)) # 被调用的job函数没有括号，只是一个索引，参数在后面 t.start() # 开始线程 threads.append(t) # 把每个线程append到线程列表中 for thread in threads: thread.join() # 分别join四个线程到主线程 results = [] # 定义一个空的列表results，将四个线运行后保存在队列中的结果返回给空列表results for _ in range(4): results.append(q.get()) print(results)if __name___==&apos;__main__&apos;: multithreading()]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[staticmethod和classmethod]]></title>
    <url>%2Fpython%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F%40staticmethod%E5%92%8C%40classmethod%2F</url>
    <content type="text"><![CDATA[一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。 而使用 @staticmethod或 @classmethod，就可以不需要实例化，直接类名.方法名()来调用。 123456789101112131415161718class A: bar = 1 def foo(self): print &apos;foo&apos; @staticmethod def static_foo(): print &apos;static_foo&apos; print A.bar @classmethod def class_foo(cls): print &apos;class_foo&apos; print cls.bar cls().foo() A.static_foo()A.class_foo() 如果在@staticmethod中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名。 而@classmethod因为持有cls参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码 这两个方法的用法是类似的，大多数情况下，classmethod也可以通过staticmethod代替，在通过类调用时，这两者对于调用者来说是不可区分的。 这两者的区别在于，classmethod增加了一个对实际调用类的引用，这带来了很多方便的地方： 方法可以判断出自己是通过基类被调用，还是通过某个子类被调用 通过子类调用时，方法可以返回子类的实例而非基类的实例 通过子类调用时，方法可以调用子类的其他classmethod]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python判断是否json格式]]></title>
    <url>%2Fpython%2Fis_json%2F</url>
    <content type="text"><![CDATA[is_json.py1234567891011121314151617181920212223242526272829#!/usr/bin/env python#-*-coding:utf-8-*-import jsonimport sysimport osimport globscript_path = os.path.split(os.path.realpath(__file__))[0]def is_json(json_file): try: with open(json_file,&apos;r&apos;) as f: load_dict = json.load(f) print(json_file + &apos; True&apos;) except Exception as e: print(json_file + &apos; ERROR&apos;) print(e)def json_list(): try: json_name = sys.argv[1] json_list = [] for json_name in sys.argv[1:]: json_list.append(json_name) except: json_list = glob.glob(os.path.join(script_path,&apos;*.json&apos;)) return json_list[is_json(json_file) for json_file in json_list()]]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python里的一些函数]]></title>
    <url>%2Fpython%2Fpython%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[参考 1. lambda 函数 （匿名函数）没有函数名的函数12x = lambda a,b : a*bprint(x(2,3)) 2. Map 函数Map() 是 python 里的内置函数，它可以将 函数应用于各种数据结构中的元素123x = map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10,11])print(x) # &lt;map object at 0x00000255474D24A8&gt; 迭代器print(list(x)) # [3, 7, 11, 15, 19] 3. filter 函数与 map()类似，但只返回True的元素1234567891011numbers = [1, 2, 3, 4, 5, 6, 7, 8]def filter_odd_numbers(num): if num % 2 == 0: return True else: return False filtered_numbers = filter(filter_odd_numbers, numbers)print(filtered_numbers) # &lt;filter object at 0x00000237EFD62438&gt; print(list(filtered_numbers)) # [2, 4, 6, 8] 4. any(),all()123x = [0, 2, 1]print(all(x)) # Falseprint(any(x)) # True 5. zip()zip() 函数 用于将可迭代对象作为参数，将对象中对应的元素打包成一个个元组，然后返回这些元组组成的列表12345678910keys = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]values = [1, 2, 3, 3]zipped = dict(zip(keys, values))print(zipped) # &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3, &apos;d&apos;: 3&#125;d = &#123;k:v for k,v in zip(zipped.values(),zipped.keys())&#125;print(d) # &#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;d&apos;&#125;# 根据字典值的大小，对字典的项从大到小排序print(dict(sorted(d.items(),key=lambda x:x[1],reverse=True))) # &#123;3: &apos;d&apos;, 2: &apos;b&apos;, 1: &apos;a&apos;&#125;]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python里的特殊方法]]></title>
    <url>%2Fpython%2Fpython%E9%87%8C%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[特殊方法是什么是一种具有特殊魅力的正常方法，python通过这些方法可以赋予你的class魔力。 这些魔法方法 都是以双下划线__作为 前缀和后缀。 初始化__new__()创造实例， __init__()初始化实例。 __init__() 是一个类 (class) 的第一个方法，也叫构造函数。 是第一个被创建，但不是第一个被执行的。 __new__() 才是最早被调用的方法 __new__() : 先读取参数( 如类名称,args,和kwargs）, 然后 new() 方法把这些参数传递给 __init__() , __new__(class_name, args, kwargs) __init__() : 类的初始化方法或构造方法, 几乎用于 全局的初始化目的。 __init__(slef, args, kwargs) __del__() : 类的析构函数，定义一个对象被垃圾回收的行为。 __del__(self) 12345678910111213141516171819202122232425262728293031323334353637class SimpleInit: def __new__(cls): print(&quot;__new__ is called&quot;) return super(SimpleInit, cls).__new__(cls) # 不过与python3.7后的dataclass 不兼容，dataclass 机制得好好看一下 def __init__(self, value=10): print(&apos;__init__ is called&apos;) print(&quot;self is: &quot;, self) self._list = [value] def __del__(self): print(self._list) del self._list print(self._list)a = SimpleInit()a.__del__()&apos;&apos;&apos;输出如下：__new__ is called # __new__()创造实例， __init__()初始化实例__init__ is calledself is: &lt;__main__.SimpleInit object at 0x0000017E8A132470&gt;[10]---------------------------------------------------------------------------AttributeError Traceback (most recent call last)&lt;ipython-input-22-3666a9307d4d&gt; in &lt;module&gt;----&gt; 1 a.__del__()&lt;ipython-input-21-cb926d3eed30&gt; in __del__(self) 12 print(self._list) 13 del self._list---&gt; 14 print(self._list) 15 16 a = SimpleInit()AttributeError: &apos;SimpleInit&apos; object has no attribute &apos;_list&apos;&apos;&apos;&apos; 算术运算,增量赋值 __add__(self.other) + __iadd__(self.other) += __sub__(self.other) - __isub__(self.other) -= __mul__(self.other) * __imul__(self.other) *= __floordiv__(self.other) // __ifloordiv__(self.other) //= __div__(self.other) / __idiv__(self.other) /= __mod__(self.other) % __imod__(self.other) %= __and__(self.other) &amp; __iand__(self.other) &amp;= __or__(self.other) | __ior__(self.other) |= __xor__(self.other) ^ __ixor__(self.other) ^= __pow__(self.other) ** __ipow__(self.other) **= __lshift__(self.other) &lt;&lt; __ilshift__(self.other) &lt;&lt;= __rshift__(self.other) &gt;&gt; __irshift__(self.other) &gt;&gt;=1234567891011121314from dataclasses import dataclass, field@dataclassclass Simpleadder: _elements:list = list def __add__(self, other): return self._elements + other._elementsa = Simpleadder([1,2,3,4,5])b = Simpleadder([4,5,6,7,8])print(a, b) # Simpleadder(_elements=[1, 2, 3, 4, 5]) Simpleadder(_elements=[4, 5, 6, 7, 8])print(a + b) # [1, 2, 3, 4, 5, 4, 5, 6, 7, 8] 比较运算python3.7 可使用dataclass __eq__(self.other) == __ne__(self.other) != __lt__(self.other) &lt; __gt__(self.other) &gt; __le__(self.other) &lt;= __ge__(self.other) &gt;= 类型转换 __int__(self) int __long__(self) long __float__(self) float __complex__(self) complex __oct__(self) octal (八进制) __hex__(self) (十六进制) __index__(self) 转为int, 当对象被用于切片表达式 最常用 __str__(self) __repr__(self) 类似__str__() str()主要用于人类可读, repr() 机器可读 __hash__(self) 定义了行为调用hash() __len__(self) 返回容器长度 __getitem__(self) setitem(self) __delitem__(self) 定义一个删除一个项目的行为 __iter__(self) 返回一个迭代容器 __call__(self) 使实例能够像函数一样被调用，同时不影响实例本身的生命周期 __call__()不影响一个实例的构造和析构。但是__call__()可以用来改变实例的内部成员的值123456789101112131415from dataclasses import dataclass@dataclass()class X: a:int b:int range:int def __call__(self): print(&apos;__call__ with （&#123;&#125;, &#123;&#125;）&apos;.format(self.a, self.b))x = X(1,2,3)print(x)x() # 把实例直接当函数调用]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[装饰器]]></title>
    <url>%2Fpython%2F%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[绝大多数装饰器都是基于函数和 闭包 实现的，但这并非制造装饰器的唯一方式. Python 对某个对象是否能通过装饰器（@decorator）形式使用只有一个要求：decorator 必须是一个“可被调用（callable）的对象123def foo(): passtype(foo) # functioncallable(foo) # True 只要自定义类的 __call__ 魔法方法即可让任意类变成可被调用123456789101112131415161718from dataclasses import dataclass@dataclass()class X: a:int b:int range:int def __call__(self): # 定义类的 `__call__` 方法 print(&apos;__call__ with （&#123;&#125;, &#123;&#125;）&apos;.format(self.a, self.b)) def __del__(self): del self.a del self.b del self.rangex = X(1,2,3)x() # 像函数一样调用 1234567891011121314151617181920212223242526272829303132333435363738import timeimport randomimport functoolsdef timer(wrapped): &quot;&quot;&quot;装饰器：记录并打印函数耗时&quot;&quot;&quot; @functools.wraps(wrapped) # 可以使函数保持原有签名 def decorated(*args, **kwargs): st = time.time() ret = wrapped(*args, **kwargs) print(&apos;execution take: &#123;&#125; seconds&apos;.format(time.time() - st)) return ret return decorateddef counter(func): &quot;&quot;&quot;装饰器：记录并打印调用次数&quot;&quot;&quot; count = 0 @functools.wraps(func) def decorated(*args, **kwargs): # 次数累加 nonlocal count count += 1 print(f&quot;Count: &#123;count&#125;&quot;) return func(*args, **kwargs) return decorated@counter@timerdef random_sleep(): &apos;德玛西亚&apos; time.sleep(random.random())random_sleep()random_sleep()print(random_sleep.__name__)print(random_sleep.__doc__) 1234567891011121314151617181920def provide_number(min_num, max_num): &quot;&quot;&quot;装饰器：随机生成一个在 [min_num, max_num] 范围的整数，追加为函数的第一个位置参数 &quot;&quot;&quot; def wrapper(func): def decorated(*args, **kwargs): num = random.randint(min_num, max_num) # 将 num 作为第一个参数追加后调用函数 return func(num, *args, **kwargs) return decorated return wrapper@provide_number(1, 100)def print_random_number(num): print(num) wrapt 模块是一个专门帮助编写装饰器的工具库。可以非常方便的改造 provide_number 装饰器，完美解决“嵌套层级深”和“无法通用”两个问题123456789101112131415161718192021222324252627282930import wraptimport randomdef provide_number(min_num, max_num): @wrapt.decorator def wrapper(wrapped, instance, args, kwargs): # 参数含义： # # - wrapped：被装饰的函数或类方法 # - instance： # - 如果被装饰者为普通类方法，该值为类实例 # - 如果被装饰者为 classmethod 类方法，该值为类 # - 如果被装饰者为类/函数/静态方法，该值为 None # # - args：调用时的位置参数（注意没有 * 符号） # - kwargs：调用时的关键字参数（注意没有 ** 符号） # num = random.randint(min_num, max_num) # 无需关注 wrapped 是类方法或普通函数，直接在头部追加参数 args = (num,) + args return wrapped(*args, **kwargs) return wrapper@provide_number(1,100)def number(num): print(num)number() 1234567891011121314151617181920212223242526272829303132333435import timeimport functoolsclass DelayFunc: def __init__(self, duration, func): self.duration = duration self.func = func def __call__(self, *args, **kwargs): print(f&apos;Wait for &#123;self.duration&#125; seconds...&apos;) time.sleep(self.duration) return self.func(*args, **kwargs) def eager_call(self, *args, **kwargs): print(&apos;Call without delay&apos;) return self.func(*args, **kwargs)def delay(duration): &quot;&quot;&quot;装饰器：推迟某个函数的执行。同时提供 .eager_call 方法立即执行 &quot;&quot;&quot; # 此处为了避免定义额外函数，直接使用 functools.partial 帮助构造 # DelayFunc 实例 return functools.partial(DelayFunc, duration)@delay(duration=2)def add(a, b): return a + b# 这次调用将会延迟 2 秒print(add(1, 2))# 这次调用将会立即执行print(add.eager_call(1, 2)) # 还是进入了类，duration=2， 但调用类里面的eager_call()方法直接返回函数 123456def add(a, b): return a + bimport functoolsadd_3 = functools.partial(add, 3)print(add_3(1))]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python拾遗_函数]]></title>
    <url>%2Fpython%2Fpython%E6%8B%BE%E9%81%97_%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数 函数有机会给一组语句命名 函数可以减少重复代码 一长段程序可以拆分为多个函数，组合起来使用 一次书写, 多次调用。 在函数内部 实参会赋值给形参的变量 12345def print_twice(x): print(x) print(x)a = print_twice(&apos;haha&apos;)a == None # True # 没有return,返回None 只会实现函数作用 增量开发每次只增加和测试一小部分代码，来避免长时间的调试过程 eg: 圆心坐标(x1,y1)例如(0,0),圆上一点的坐标(x2,y2)例如(2,2), 计算圆的面积。 圆的面积 12345import mathdef area(radius): return math.pi * radius **2a = area(2) # a 等于return的值print(area(2),a) 圆的半径 123456789def distance(x1, y1, x2, y2): &apos;&apos;&apos; 计算两点之间的距离 文档字符串，一般用来简明的解释函数是用来做什么的 &apos;&apos;&apos; dx = x2 -x1 dy = y2 -y1 # 临时变量，在计算中可以用来保存中间计算值 dsquared = dx ** 2 + dy ** 2 result = math.sqrt(dsquared) # 脚手架代码，构建时有用，最终可以删除 return result 计算结果 12radius = distance(x1, y1, x2, y2)result = area(radius) 封装成一个函数1234def circle_area(x1, y1, x2, y2): radius = distance(x1, y1, x2, y2) result = area(radius) return result 简化123def circle_area(x1, y1, x2, y2): return area(distance(x1, y1, x2, y2))circle_area(0, 0, 2, 2) # 25.132741228718352 递归调用自己的函数称为 递归的函数，执行过程称为递归 无限递归,会在递归深度到上限时报错123def recurse(): recurse()recurse() # RecursionError: maximum recursion depth exceeded 123456def print_n(s, n): if n &lt;= 0: retrun print(s) print_n(s,n-1)print_n(&apos;haha&apos;, 5) 12345678910def countdown(n): if n &gt; 100000: # 守卫,保护后面代码，避免出现错误 print(&apos;over limit&apos;) return elif n &lt;= 0: print(&apos;haha&apos;) else: print(n) countdown(n-1)countdown(10000000000000) while 循环123456789def countdown(n): if n &gt; 100000: # 守卫,保护后面代码，避免出现错误 print(&apos;over limit&apos;) return while n &gt; 0: print(n) n -= 1 print(&apos;haha&apos;)countdown(10000000000000) 12345while 1: line = input(&apos;&gt;&apos;) if line == &apos;done&apos;: break # 使用 break 退出循环 print(line)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java基础语法]]></title>
    <url>%2Fjava%2Fjava%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[hello worldHelloWorld.java (源文件名必须和类名相同)12345678public class HelloWorld &#123; /* 第一个Java程序. * 它将打印字符串 Hello World */ public static void main(String []args) &#123; // 主方法入口：所有的Java 程序由public static void main(String args[])方法开始执行 System.out.println(&quot;Hello World&quot;); // 打印 Hello World &#125;&#125; （cmd在java文件的同一路径下） 编译 javac -encoding utf-8 HelloWorld.java (含中文最好使用 -encoding utf-8编译，以免出现错误) 运行 java HelloWorld 打印 HelloWorld 类和对象123456789101112131415161718192021222324252627public class Puppy&#123; // Puppy 类 一个源文件中只能有一个public类 int puppyAge; public Puppy(String name)&#123; // 这个构造器仅有一个参数：name System.out.println(&quot;Passed Name is :&quot; + name ); &#125; public void setAge( int age )&#123; puppyAge = age; &#125; public int getAge( )&#123; System.out.println(&quot;Puppy&apos;s age is :&quot; + puppyAge ); return puppyAge; &#125; public static void main(String []args)&#123; /* 创建对象 */ Puppy myPuppy = new Puppy( &quot;tommy&quot; ); // 声明：声明一个对象，包括对象名称和对象类型 实例化：使用关键字new来创建一个对象 初始化：使用new创建对象时，会调用构造方法初始化对象 /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println(&quot;Variable Value :&quot; + myPuppy.puppyAge ); &#125;&#125; importEmployee.java1234567891011import java.io.*; //下面的命令行将会命令编译器载入java_installation/java/io路径下的所有类public class Employee&#123; //salary是静态的私有变量 private static double salary; // DEPARTMENT是一个常量 public static final String DEPARTMENT = &quot;Development &quot;; public static void main(String args[])&#123; salary = 1000; System.out.println(DEPARTMENT+&quot;average salary:&quot;+salary); &#125;&#125; EmployeeTest.java1234567891011121314151617181920import java.io.*;public class EmployeeTest&#123; public static void main(String args[])&#123; /* 使用构造器创建两个对象 */ Employee empOne = new Employee(&quot;James Smith&quot;); Employee empTwo = new Employee(&quot;Mary Anne&quot;); // 调用这两个对象的成员方法 empOne.empAge(26); empOne.empDesignation(&quot;Senior Software Engineer&quot;); empOne.empSalary(1000); empOne.printEmployee(); empTwo.empAge(21); empTwo.empDesignation(&quot;Software Engineer&quot;); empTwo.empSalary(500); empTwo.printEmployee(); &#125;&#125; 编译后，执行EmployeeTest就可以得到结果]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java简介]]></title>
    <url>%2Fjava%2Freadme%2F</url>
    <content type="text"><![CDATA[java简介Java分为三个体系： JavaSE(J2SE)(Java2 Platform Standard Edition，java平台标准版) JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版) JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版) 开发环境配置(windows下)java下载 下载后安装，配置系统环境变量 此电脑 &gt; 右键属性 &gt; 高级 &gt; 环境变量12345678变量名：JAVA_HOME变量值：C:\Program Files (x86)\Java\jdk1.8.0_91 // 要根据自己的实际路径配置变量名：CLASSPATH变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; //记得前面有个&quot;.&quot;变量名：Path变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;windows10 变量值已有的上面点开，然后新建加到下方，以免破坏原有的环境变量 重启后生效 测试JDK是否安装成功 “开始”-&gt;”运行”，键入”cmd”； 键入命令: java -version、java、javac 几个命令]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java修饰符]]></title>
    <url>%2Fjava%2F%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Java修饰符主要分为以下两类： 访问修饰符 非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端 123456789public class className &#123; // ...&#125;private boolean myFlag;static final double weeks = 9.5;protected static final int BOXWIDTH = 42;public static void main(String[] arguments) &#123; // 方法体&#125; 访问控制修饰符默认访问修饰符-不使用任何关键字使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为public static final,而接口里的方法默认情况下访问权限为public。1234String version = &quot;1.5.1&quot;;boolean processOrder() &#123; return true;&#125; 私有访问修饰符-private私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。 声明为私有访问类型的变量只能通过类中公共的getter方法被外部类访问。 Private访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。123456789public class Logger &#123; private String format; public String getFormat() &#123; return this.format; &#125; public void setFormat(String format) &#123; this.format = format; &#125;&#125; 公有访问修饰符-public被声明为public的类、方法、构造方法和接口能够被任何其他类访问。 如果几个相互访问的public类分布在不同的包中，则需要导入相应public类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。123public static void main(String[] arguments) &#123; // ...&#125; 受保护的访问修饰符-protected被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。 Protected访问修饰符不能修饰类和接口，方法和成员变量能够声明为protected，但是接口的成员变量和成员方法不能声明为protected。 子类能访问Protected修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。 下面的父类使用了protected访问修饰符，子类重载了父类的openSpeaker()方法 1234567891011class AudioPlayer &#123; protected boolean openSpeaker(Speaker sp) &#123; // 实现细节 &#125;&#125;class StreamingAudioPlayer &#123; boolean openSpeaker(Speaker sp) &#123; // 实现细节 &#125;&#125; 如果把openSpeaker()方法声明为private，那么除了AudioPlayer之外的类将不能访问该方法。如果把openSpeaker()声明为public，那么所有的类都能够访问该方法。如果我们只想让该方法对其所在类的子类可见，则将该方法声明为protected。 访问控制和继承请注意以下方法继承的规则： 父类中声明为public的方法在子类中也必须为public。 父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。 父类中声明为private的方法，不能够被继承。非访问修饰符 static : 用来创建类方法和类变量。 final : 用来修饰类、方法和变量，final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract : 用来创建抽象类和抽象方法。 synchronized和volatile : 主要用于线程的编程。 static修饰符 静态变量 ： 也被称为类变量。用来声明独立于对象的静态变量,局部变量不能被声明为static变量 静态方法 ： 来声明独立于对象的静态方法12345678910111213141516171819202122public class InstanceCounter &#123; private static int numInstances = 0; protected static int getCount() &#123; return numInstances; &#125; private static void addInstance() &#123; numInstances++; &#125; InstanceCounter() &#123; InstanceCounter.addInstance(); &#125; public static void main(String[] arguments) &#123; System.out.println(&quot;Starting with &quot; + InstanceCounter.getCount() + &quot; instances&quot;); for (int i = 0; i &lt; 500; ++i)&#123; new InstanceCounter(); &#125; System.out.println(&quot;Created &quot; + InstanceCounter.getCount() + &quot; instances&quot;); &#125; &#125; final修饰符final变量:12345678910public class Test&#123; final int value = 10; // 下面是声明常量的实例 public static final int BOXWIDTH = 6; static final String TITLE = &quot;Manager&quot;; public void changeValue()&#123; value = 12; //将输出一个错误 &#125;&#125; final方法:类中的Final方法可以被子类继承，但是不能被子类修改。 声明final方法的主要目的是防止该方法的内容被修改12345public class Test&#123; public final void changeName()&#123; // 方法体 &#125;&#125; final类： 不能被继承123public final class Test &#123; // 类体&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java分支结构]]></title>
    <url>%2Fjava%2F%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[if elseIfElse.java12345678910111213141516171819public class Test &#123; public static void main(String args[])&#123; int x = 30; if( x == 10 )&#123; System.out.print(&quot;Value of X is 10&quot;); &#125; else if( x == 20 )&#123; System.out.print(&quot;Value of X is 20&quot;); &#125; else if( x == 30 )&#123; System.out.print(&quot;Value of X is 30&quot;); &#125; else&#123; System.out.print(&quot;这是 else 语句&quot;); &#125; &#125;&#125; 嵌套的if…else语句12345678910111213public class Test &#123; public static void main(String args[])&#123; int x = 30; int y = 10; if( x == 30 )&#123; if( y == 10 )&#123; System.out.print(&quot;X = 30 and Y = 10&quot;); &#125; &#125; &#125;&#125; switch语句1234567891011121314151617181920212223242526public class Test &#123; public static void main(String args[])&#123; //char grade = args[0].charAt(0); char grade = &apos;C&apos;; switch(grade) &#123; case &apos;A&apos; : System.out.println(&quot;优秀&quot;); break; case &apos;B&apos; : case &apos;C&apos; : System.out.println(&quot;良好&quot;); break; case &apos;D&apos; : System.out.println(&quot;及格&quot;); case &apos;F&apos; : System.out.println(&quot;你需要继续努力&quot;); break; default : System.out.println(&quot;无效等级&quot;); &#125; System.out.println(&quot;你的等级是 &quot; + grade); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java基本数据类型]]></title>
    <url>%2Fjava%2F%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本数据类型两大数据类型： 内置数据类型 引用数据类型 内置数据类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class PrimitiveTypeTest &#123; public static void main(String[] args) &#123; // byte System.out.println(&quot;基本类型：byte 二进制位数：&quot; + Byte.SIZE); System.out.println(&quot;包装类：java.lang.Byte&quot;); System.out.println(&quot;最小值：Byte.MIN_VALUE=&quot; + Byte.MIN_VALUE); System.out.println(&quot;最大值：Byte.MAX_VALUE=&quot; + Byte.MAX_VALUE); System.out.println(); // short System.out.println(&quot;基本类型：short 二进制位数：&quot; + Short.SIZE); System.out.println(&quot;包装类：java.lang.Short&quot;); System.out.println(&quot;最小值：Short.MIN_VALUE=&quot; + Short.MIN_VALUE); System.out.println(&quot;最大值：Short.MAX_VALUE=&quot; + Short.MAX_VALUE); System.out.println(); // int System.out.println(&quot;基本类型：int 二进制位数：&quot; + Integer.SIZE); System.out.println(&quot;包装类：java.lang.Integer&quot;); System.out.println(&quot;最小值：Integer.MIN_VALUE=&quot; + Integer.MIN_VALUE); System.out.println(&quot;最大值：Integer.MAX_VALUE=&quot; + Integer.MAX_VALUE); System.out.println(); // long System.out.println(&quot;基本类型：long 二进制位数：&quot; + Long.SIZE); System.out.println(&quot;包装类：java.lang.Long&quot;); System.out.println(&quot;最小值：Long.MIN_VALUE=&quot; + Long.MIN_VALUE); System.out.println(&quot;最大值：Long.MAX_VALUE=&quot; + Long.MAX_VALUE); System.out.println(); // float System.out.println(&quot;基本类型：float 二进制位数：&quot; + Float.SIZE); System.out.println(&quot;包装类：java.lang.Float&quot;); System.out.println(&quot;最小值：Float.MIN_VALUE=&quot; + Float.MIN_VALUE); System.out.println(&quot;最大值：Float.MAX_VALUE=&quot; + Float.MAX_VALUE); System.out.println(); // double System.out.println(&quot;基本类型：double 二进制位数：&quot; + Double.SIZE); System.out.println(&quot;包装类：java.lang.Double&quot;); System.out.println(&quot;最小值：Double.MIN_VALUE=&quot; + Double.MIN_VALUE); System.out.println(&quot;最大值：Double.MAX_VALUE=&quot; + Double.MAX_VALUE); System.out.println(); // char System.out.println(&quot;基本类型：char 二进制位数：&quot; + Character.SIZE); System.out.println(&quot;包装类：java.lang.Character&quot;); // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台 System.out.println(&quot;最小值：Character.MIN_VALUE=&quot; + (int) Character.MIN_VALUE); // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台 System.out.println(&quot;最大值：Character.MAX_VALUE=&quot; + (int) Character.MAX_VALUE);&#125;&#125; 引用数据类型 引用类型变量由类的构造函数创建，可以使用它们访问所引用的对象。这些变量在声明时被指定为一个特定的类型，比如Employee、Pubby等。变量一旦声明后，类型就不能被改变了。 对象、数组都是引用数据类型。 所有引用类型的默认值都是null。 一个引用变量可以用来引用与任何与之兼容的类型。 例子：Animal animal = new Animal(“giraffe”） 常量1final double PI = 3.1415927; //常量指不能改变的量,用final标志,通常用大写标识 123int decimal = 100; // 十进值int octal = 0144; // 8进值int hexa = 0x64; // 16进值 字符串双引号 123&quot;Hello World&quot;&quot;two\nlines&quot;&quot;\&quot;This is in quotes\&quot;&quot; 12char a = &apos;\u0001&apos;; // 变量a 的值为 &apos;\u0001&apos;String a = &quot;\u0001&quot;;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java变量类型]]></title>
    <url>%2Fjava%2F%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[变量类型在Java语言中 局部变量 实例变量 类变量 所有的变量在使用前必须声明。声明变量的基本格式如下： type identifier [ = value][, identifier [= value] ...] ; 12345int a, b, c; // 声明三个int型整数：a、b、c。int d = 3, e, f = 5; // 声明三个整数并赋予初值。byte z = 22; // 声明并初始化z。double pi = 3.14159; // 声明了pi。char x = &apos;x&apos;; // 变量x的值是字符&apos;x&apos;。 局部变量123456789101112public class Test&#123; public void pupAge()&#123; int age = 0; // age是一个局部变量。定义在pupAge()方法中，它的作用域就限制在这个方法中 age = age + 7; System.out.println(&quot;Puppy age is : &quot; + age); &#125; public static void main(String args[])&#123; Test test = new Test(); test.pupAge(); &#125;&#125; 实例变量1234567891011121314151617181920212223242526import java.io.*;public class Employee&#123; // 这个成员变量对子类可见 public String name; // 私有变量，仅在该类可见 private double salary; //在构造器中对name赋值 public Employee (String empName)&#123; name = empName; &#125; //设定salary的值 public void setSalary(double empSal)&#123; salary = empSal; &#125; // 打印信息 public void printEmp()&#123; System.out.println(&quot;name : &quot; + name ); System.out.println(&quot;salary :&quot; + salary); &#125; public static void main(String args[])&#123; Employee empOne = new Employee(&quot;Ransika&quot;); empOne.setSalary(1000); empOne.printEmp(); &#125;&#125; 类变量12345678910111213import java.io.*;public class Employee&#123; //salary是静态的私有变量 private static double salary; // DEPARTMENT是一个常量 public static final String DEPARTMENT = &quot;Development &quot;; public static void main(String args[])&#123; salary = 1000; System.out.println(DEPARTMENT+&quot;average salary:&quot;+salary); &#125;&#125;// 如果其他类想要访问该变量，可以这样访问：Employee.DEPARTMENT]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java运算符]]></title>
    <url>%2Fjava%2F%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Java 运算符主要分为一下几种 算术运算符 关系运算符 位运算符 逻辑运算符 赋值运算符 其他运算符 算术运算符ArithmeticOperator.java1234567891011121314151617181920public class ArithmeticOperator &#123; public static void main(String args[]) &#123; int a = 10; int b = 20; int c = 25; int d = 25; System.out.println(&quot;a + b = &quot; + (a + b) ); System.out.println(&quot;a - b = &quot; + (a - b) ); System.out.println(&quot;a * b = &quot; + (a * b) ); System.out.println(&quot;b / a = &quot; + (b / a) ); System.out.println(&quot;b % a = &quot; + (b % a) ); System.out.println(&quot;c % a = &quot; + (c % a) ); System.out.println(&quot;a++ = &quot; + (a++) ); System.out.println(&quot;a-- = &quot; + (a--) ); // 查看 d++ 与 ++d 的不同 System.out.println(&quot;d++ = &quot; + (d++) ); // 当前语句后 +1 System.out.println(&quot;++d = &quot; + (++d) ); // 当前语句前 +1 &#125; &#125; 关系运算符RelationalOperator.java12345678910111213public class RelationalOperator &#123; public static void main(String args[]) &#123; int a = 10; int b = 20; System.out.println(&quot;a == b = &quot; + (a == b) ); System.out.println(&quot;a != b = &quot; + (a != b) ); System.out.println(&quot;a &gt; b = &quot; + (a &gt; b) ); System.out.println(&quot;a &lt; b = &quot; + (a &lt; b) ); System.out.println(&quot;b &gt;= a = &quot; + (b &gt;= a) ); System.out.println(&quot;b &lt;= a = &quot; + (b &lt;= a) ); &#125; &#125; 逻辑运算符LogicalOperators.java123456789public class LogicalOperators &#123; public static void main(String args[]) &#123; boolean a = true; boolean b = false; System.out.println(&quot;a &amp;&amp; b = &quot; + (a&amp;&amp;b)); System.out.println(&quot;a || b = &quot; + (a||b) ); System.out.println(&quot;!(a &amp;&amp; b) = &quot; + !(a &amp;&amp; b)); &#125; &#125; 赋值运算符AssignmentOperator.java123456789101112131415161718public class AssignmentOperator &#123; public static void main(String args[]) &#123; int a = 10; int b = 20; int c; c = a + b; System.out.println(&quot;c = a + b is &quot; + (a + b)); System.out.println(&quot;c += a is &quot; + (c+=a) ); System.out.println(&quot;c -= a is &quot; + (c -=a)); System.out.println(&quot;c *= a is &quot; + (c *= a)); a = 10; c = 15; System.out.println(&quot;c /= a is &quot; + (c/=a) ); a = 10; c = 15; System.out.println(&quot;c %= a is &quot; + (c %= a)); &#125; &#125; 条件运算符ConditionalOperator.java12345678910public class ConditionalOperator &#123; public static void main(String args[])&#123; int a , b; a = 10; b = (a == 1) ? 20: 30; // 不成立 System.out.println( &quot;Value of b is : &quot; + b ); // 30 b = (a == 10) ? 20: 30; // 成立 System.out.println( &quot;Value of b is : &quot; + b ); // 20 &#125;&#125; instanceOf 运算符Car.java123456789class Vehicle &#123;&#125;public class Car extends Vehicle &#123; // Car 继承了Vehicle所有属性和方法 public static void main(String args[])&#123; Vehicle a = new Car(); boolean result = a instanceof Car; // 被比较的对象兼容于右侧类型,该运算符仍然返回true System.out.println( result); // true &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安装Chrome浏览器和ChromeDriver]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F%E5%AE%89%E8%A3%85Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8CChromeDriver%2F</url>
    <content type="text"><![CDATA[一、 安装Chrome浏览器1、安装依赖 sudo apt-get install libxss1 libappindicator1 libindicator7 2、下载Chrome安装包 (最新稳定版) wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 3、安装 12sudo dpkg -i google-chrome*.debsudo apt-get install -f 二、安装ChromeDriver1、安装xvfb以便我们可以无头奔跑地运行Chrome sudo apt-get install xvfb 2、安装依赖 sudo apt-get install unzip 3、下载安装包 wget -N http://chromedriver.storage.googleapis.com/2.26/chromedriver_linux64.zip 要下载对应版本 http://chromedriver.storage.googleapis.com/index.html 4、解压缩+添加执行权限 unzip chromedriver_linux64.zip 5、移动 sudo mv -f chromedriver /usr/local/share/chromedriver 6、建立软连接 sudo ln -s /usr/local/share/chromedriver /usr/local/bin/chromedriversudo ln -s /usr/local/share/chromedriver /usr/bin/chromedriver 三、无头运行Chrome1、安装Python依赖 pip3 install selenium pip3 install pyvirtualdisplay]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[部分命令]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2Flearn_linux%2F%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[service nginx reload 反向代理，负载均衡 硬件资源信息1234free -hdf -hw/topcat /proc/cpuinfo 防火墙保护服务器，设置防火墙规则，开闭端口1234yum install firewalldservice firewalld startservice firewalld statusservice firewalld stop/disable 服务1234crontabNtpdateLogrotatesupervisor]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于 vi]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2Flearn_linux%2Fvim%2Freadme%2F</url>
    <content type="text"><![CDATA[vivi的使用 一般模式 编辑模式 （i,I，o,O,a,A,r,R）(Ii aA 插入)（oO 插入一行）(Rr 替换) 命令行模式 (: / ?)123dos2unix filenamedos2unix和unix2dos，dos2unix把&quot;\r\n&quot;转化成&quot;\n&quot;，unixtodos把&quot;\n&quot;转化成&quot;\r\n]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go的package与import]]></title>
    <url>%2Fgolang%2Fpackage%E4%B8%8Eimport%2F</url>
    <content type="text"><![CDATA[package package 是最基本的分发单位 和 工程管理中依赖关系的体现 每个 GO 语言源代码文件开头 都拥有一个 package 声明，表示源代码所属的代码包 要生成 GO 语言可执行程序，必须要有main 的 package包，且必须在该包下 有 main()函数 同一个路径下(文件夹) 只能存在 一个 package, 一个package 可以拆分为多个源文件组成 import 原理此处需要插图 import 导入包的几种方式：点，别名与下划线在写Go代码的时候经常用到import这个命令用来导入包文件，看到的方式参考如下：123import( &quot;fmt&quot;) 然后在代码里面可以通过如下的方式调用fmt.Println(&quot;hello world&quot;) 上面这个fmt是Go语言的标准库，他其实是去GOROOT下去加载该模块，当然Go的import还支持如下两种方式来加载自己写的模块： 相对路径 import &quot;./model&quot; // 当前文件同一目录的model目录，但是不建议这种方式import 绝对路径 import &quot;shorturl/model&quot; // 加载GOPATH/src/shorturl/model模块 三种导入包的使用方法。 点操作import( . &quot;fmt&quot; )可以省略前缀的包名，fmt.Println(&quot;hello world&quot;) 可以省略的写成Println(“hello world”) 别名操作import( f &quot;fmt&quot; ) 调用包函数时前缀变成了重命名的前缀，即f.Println(“hello world”) _ 操作import ( &quot;database/sql&quot; _ &quot;github.com/ziutek/mymysql/godrv&quot; ) _操作其实只是引入该包。即使用_操作引用包是无法通过包名来调用包中的导出函数，而是只是为了简单的调用其init函数()]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go基础语法]]></title>
    <url>%2Fgolang%2F%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一般结构12345678910111213141516171819202122232425// 当前程序的包名package main// 导入其他包import . &quot;fmt&quot;// 常量定义const PI = 3.14// 全局变量的声明和赋值var name = &quot;gopher&quot;// 一般类型声明type newType int// 结构的声明type gopher struct&#123;&#125;// 接口的声明type golang interface&#123;&#125;// 由main函数作为程序入口点启动func main() &#123; Println(&quot;Hello World!&quot;)&#125; 变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport &quot;fmt&quot;var x1, y1 intvar ( // 这种因式分解关键字的写法一般用于声明全局变量 a1 int b1 bool)var c1, d1 int = 1, 2var e1, f1 = 123, &quot;hello&quot;var h1 int // 全局变量 允许声明但不使用// e1 := &quot;weilai&quot; // 只能被用在函数体内，而不可以用于全局变量的声明与赋值func main() &#123; /* 多行注释 */ // 一行注释 var a string = &quot;weilai&quot; // 声明一个变量并初始化 var b, c int = 1, 2 // 一次声明多个变量： var d int // 声明变量，不初始化，一般情况下，值类型默认为 0, 布尔类型默认值为 false ,string 默认值为空字符串 &apos;&apos; var z bool // bool 0值 false fmt.Println(z) fmt.Println(a) // 打印 a 换行 fmt.Print(b, c) // 不会换行 fmt.Println(d) fmt.Println(&quot;hello&quot;) // 会换行 fmt.Println(&quot;world&quot; ) fmt.Print(&quot;hello&quot;) fmt.Print(&quot;world&quot;) // var e int 这行存在 下行就会报错就会报错 no new variables on left side of := e := &quot;weilai&quot; // 等同于 var e string = &quot;weilai&quot; // 使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明 f, g := 20, 30 f, g = g, f // 如果你想要交换两个变量的值，，两个变量的类型必须是相同。 // h := 40 // 声明但未使用 局部变量 会报错 fmt.Println(&quot;e=&quot;, e , &quot;,f=&quot; , f , &quot;,g=&quot; , g) fmt.Printf(&quot;e=%s,f=%d,g=%d&quot; , e , f , g) // Printf 是格式化输出 var vname1, vname2, vname3 = &quot;v1&quot;, &quot;v2&quot;, &quot;v3&quot; fmt.Printf(vname1, vname2, vname3) println(x1, y1, a1, b1, c1, d1, e1, f1) _,numb,strs := numbers() //只获取函数返回值的后两个 fmt.Println(numb,strs)&#125;//一个可以返回多个值的函数func numbers()(int,int,string)&#123; a , b , c := 1 , 2 , &quot;str&quot; return a,b,c&#125;/*falseweilai1 20helloworldhelloworlde= weilai ,f= 30 ,g= 20e=weilai,f=30,g=20v1%!(EXTRA string=v2, string=v3)0 0 0 false 1 2 123 hello2 str*/]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[docker安装redis]]></title>
    <url>%2Fredis%2Fdocker%E5%AE%89%E8%A3%85redis%2F</url>
    <content type="text"><![CDATA[docker search redis 查询镜像 docker pull redis 拉取官方镜像 docker images 查看一下是否成功 启动镜像 4.1. 下载并凭需求修改redis.conf，配置文件放在/opt/data/redis/目录下4.2 docker启动redis 12$ mkdir -p /opt/data/redis$ docker run -p 6379:6379 --name myredis -v /opt/data/redis/redis.conf:/etc/redis/redis.conf -v /opt/data/redis:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes --requirepass &quot;passwd&quot; 命令解释说明：-p 6379:6379 ##端口映射，:前表示主机部分，:后表示容器部分。–name myredis ##指定容器名称，查看和进行操作都比较方便。 -v /opt/data/redis:/data ##将主机中/opt/data/redis目录下的redis挂载到容器的/data-v /opt/data/redis/redis.conf:/etc/redis/redis.conf ##将主机中redis.conf配置文件挂载到容器的/etc/redis/redis.conf文件中 -d redis 表示后台启动redisredis-server /etc/redis/redis.conf 以配置文件启动redis，加载容器内的conf文件，最终找到的是挂载的目录/opt/data/redis/redis.conf–appendonly yes 开启redis 持久化 –requirepass “passwd” 需要密码 docker ps 查看容器启动情况 连接redis的几种方式 1234567docker exec -ti myredis redis-cli # 或者用iddocker exec -ti myredis redis-cli -a &quot;passwd&quot;docker exec -ti myredis redis-cli -h localhost -p 6379 docker exec -ti myredis redis-cli -h 127.0.0.1 -p 6379 docker exec -ti myredis redis-cli -h 172.17.0.3 -p 6379 docker-compose.yml文件内容：123456789redis: image: redis container_name: test-redis restart: always ports: - 6379:6379 volumes: - /opt/data/redis:/data command: redis-server --appendonly yes --requirepass &quot;redis&quot; 客户端连接docker run --name myredis-cli -it redis:latest redis-cli -h 服务器 -p 6379ctrl + p + q后台运行再次进入docker exec -ti myredis-cli redis-cli -h 服务器 -p 6379]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker安装redis集群]]></title>
    <url>%2Fredis%2Fdocker%E5%AE%89%E8%A3%85redis%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[在 /home 目录下创建redis-cluster-test 文件夹12➜ mkdir -p /home/redis-cluster-test➜ cd /home/redis-cluster-test 把下列信息写入redis-cluster.tmpl文件中123456789port $&#123;PORT&#125;protected-mode nocluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 192.168.1.157cluster-announce-port $&#123;PORT&#125;cluster-announce-bus-port 1$&#123;PORT&#125;appendonly yes 当前目录下生成conf和data目标，并生成配置信息 共生成6个文件夹，从7001到7006，每个文件夹下包含data和conf文件夹，同时conf里面有redis.conf配置文件 123456 #for port in `seq 7001 7006`; do \ # 7001 ~7006 mkdir -p ./$&#123;port&#125;/conf \ &amp;&amp; PORT=$&#123;port&#125; envsubst &lt; ./redis-cluster.tmpl &gt; ./$&#123;port&#125;/conf/redis.conf \ &amp;&amp; mkdir -p ./$&#123;port&#125;/data; \done 创建6个redis容器1234567for port in `seq 7001 7006`; do \ docker run -d -ti \ -v `pwd`/$&#123;port&#125;/conf/redis.conf:/usr/local/etc/redis/redis.conf \ -v `pwd`/$&#123;port&#125;/data:/data \ --restart always --name redis-$&#123;port&#125; --net host \ --sysctl net.core.somaxconn=1024 redis:latest redis-server /usr/local/etc/redis/redis.conf; \done 进入任一容器1docker exec -it redis-7001 bash]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python操作redis]]></title>
    <url>%2Fredis%2Fpython%E6%93%8D%E4%BD%9Credis%2F</url>
    <content type="text"><![CDATA[1. 准备工作 安装好 redis 和 RedisPy库 RedisDump 可以用来做数据导入或导出2. RedisPy库RedisPy库 提供两个类 redis 和 StrictRedis 来实现 Redis 的命令操作。 StrictRedis 实现了绝大部分官方命令，参数也一一对应。 redis 是 StrictRedis 的子类，主要功能是用于向后兼容旧版本库里的几个方法。 推荐使用 StrictRedis 连接 Redis12345from redis import StrictRedis# localhost port=6379 默认数据库 password=passwordredis = StrictRedis(host=&apos;localhost&apos;, port=6379, db=0, password=&apos;password&apos;) redis.set(&apos;name&apos;, &apos;weilai&apos;)print(redis.get(&apos;name&apos;)) 使用ConnectionPool 连接 1234567from redis import StrictRedis, ConnectionPoolpool = ConnectionPool(host=&apos;localhost&apos;, port=6379, db=0, password=password)# localhost port=6379 默认数据库 password=passwordredis = StrictRedis(connection_pool=pool) #redis.set(&apos;name&apos;, &apos;weilai&apos;)print(redis.get(&apos;name&apos;)) ConnectionPool 还支持通过 url 来构建 123redis://[:password]@host:port/db # tcprediss://[:password]@host:port/db # tcp +ssl unix://[:password]@/path/to/socket.sock?db=db # UNIX socket 连接 eg:1234url = &apos;redis://:password@localhost:6379/0&apos;pool = ConnectionPool.from_url(url)redis = StrictRedis(connection_pool=pool) print(redis.get(&apos;name&apos;)) 类 改写1234567891011121314151617181920212223242526272829303132333435363738394041import redisclass TestString: def __init__(self): self.r = redis.StrictRedis(host=&apos;localhost&apos;, port=6379, db=0) def test_set(self): result = self.r.set(&apos;name2&apos;,&apos;weilai2&apos;) print(result) return result def test_get(self): result = self.r.get(&apos;name2&apos;) print(result) return result def test_mset(self): d = &#123; &apos;name3&apos; : &apos;user3&apos;, &apos;name4&apos; : &apos;user4&apos; &#125; result = self.r.mset(d) print(result) return result def test_mget(self): l = [&apos;name3&apos;, &apos;name4&apos;] result = self.r.mget(l) print(result) return resultdef main(): str_obj = TestString() str_obj.test_set() str_obj.test_get() str_obj.test_mset() str_obj.test_mget()if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis简介]]></title>
    <url>%2Fredis%2Freadme%2F</url>
    <content type="text"><![CDATA[简介Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份 高可用，分布式 功能丰富，发布订阅，事物，pipeline,lua脚本 不依赖外部库，单线程模型 高可用 redis-sentinel ,分布式 redis-cluster Redis运行在内存中但是可以持久化到磁盘(性能极高)(aof或)，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存. 主要用途 ： 数据库，缓存和消息中间件,计数器，排行榜，消息队列，社交网络，实时系统 执行文件redis-check-aof aof文件检查工具redis-check-dump rdb文件检查工具redis-sentinel sentinel服务器redis-server redis服务器redis-cli redis命令行客户端redis-benchmark redis性能测试工具 安装1234567891011121314151617181920212223242526wget http://download.redis.io/releases/redis-5.0.5.tar.gztar xzf redis-5.0.5.tar.gzln -s redis-5.0.5 rediscd redismake ./redis-server # 启动redis服务./redis-server redis.conf # 依据配置，启动redis服务./redis-cli # 使用测试客户端程序redis-cli和redis服务交互# eg:$ ./redis-cliredis&gt; pingPONG # 以上操作代表 redis已经安装完成。# 在远程服务器上执行命令redis-cli -h host -p port -a passwordeg:$redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;redis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; PINGPONG 配置 redis.conf可以通过修改 redis.conf 文件或使用 CONFIG set 命令(CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE)来修改配置 eg：123456redis 127.0.0.1:6379&gt; CONFIG SET loglevel &quot;notice&quot;OKredis 127.0.0.1:6379&gt; CONFIG GET loglevel1) &quot;loglevel&quot;2) &quot;notice&quot; 具体配置信息参考文档]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全性能测试客户端连接管道技术]]></title>
    <url>%2Fredis%2F%E5%AE%89%E5%85%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[安全查看是否设置密码12345127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;&quot;# 默认没有设置 设置密码12345127.0.0.1:6379&gt; CONFIG set requirepass &quot;mypassword&quot;OK127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;mypassword&quot; 设置密码后，客户端连接 redis 服务就需要密码验证，否则无法执行命令。 123456127.0.0.1:6379&gt; AUTH &quot;mypassword&quot;OK127.0.0.1:6379&gt; SET mykey &quot;Test value&quot;OK127.0.0.1:6379&gt; GET mykey&quot;Test value&quot; 性能测试Redis 性能测试是通过同时执行多个命令实现的redis-benchmark [option] [option value] 1234redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 100000 -qSET: 146198.83 requests per secondLPUSH: 145560.41 requests per second 客户端连接Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作： 首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。 然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法 然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送 1234config get maxclients1) &quot;maxclients&quot;2) &quot;10000&quot; 启动时设置最大连接数1redis-server --maxclients 100000 管道技术Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤： 客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。服务端处理命令，并将结果返回给客户端。 Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。12345678$(echo -en &quot;PING\r\n SET MYkey redis\r\nGET MYkey\r\nINCR visitor\r\nINCR visitor\r\nINCR visitor\r\n&quot;; sleep 10) | nc localhost 6379+PONG+OKredis:1:2:3]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis部分命令]]></title>
    <url>%2Fredis%2F%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[键123456redis 127.0.0.1:6379&gt; SET weilai redis -- 设置键OKredis 127.0.0.1:6379&gt; DEL weilai -- 删除键(integer) 1redis 127.0.0.1:6379&gt; DEL weilai -- 删除键(integer) 0 # 删除失败 keys * 遍历所有key – 一般不会使用 dbsize 计算 key 总数 – O（1） exists key 检查key 是否存在（0,1）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis备份]]></title>
    <url>%2Fredis%2F%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[备份Redis SAVE 命令用于创建当前数据库的备份12redis 127.0.0.1:6379&gt; SAVE OK 该命令将在 redis 安装目录中创建dump.rdb文件 BGSAVE后台执行123127.0.0.1:6379&gt; BGSAVEBackground saving started 恢复将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务123redis 127.0.0.1:6379&gt; CONFIG GET dir -- CONFIG 命令获取 redis目录1) &quot;dir&quot;2) &quot;/usr/local/redis/bin&quot;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis 数据类型]]></title>
    <url>%2Fredis%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[redis 数据类型Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。 stringstring类型是Redis最基本的数据类型，二进制安全的。redis的string可以包含任何数据，比如jpg图片或者序列化的对象，一个键最大能存储512MB1234567891011121314151617181920212223242526272829# SET 设置键值 GET 获取键值redis 127.0.0.1:6379&gt; SET name &quot;weilai&quot; OKredis 127.0.0.1:6379&gt; GET name &quot;weilai&quot;127.0.0.1:6379&gt; strlen name(integer) 6127.0.0.1:6379&gt; getset name newvalue&quot;weilai&quot;127.0.0.1:6379&gt; get name&quot;newvalue&quot;127.0.0.1:6379&gt; getrange name 1 3&quot;ewv&quot;127.0.0.1:6379&gt; SETRANGE name 1 a(integer) 8127.0.0.1:6379&gt; get name&quot;nawvalue&quot;127.0.0.1:6379&gt; setnx name 1 -- key存在时，不创建(integer) 0127.0.0.1:6379&gt; set name newname xx -- key存在时，才更新OK127.0.0.1:6379&gt; get name&quot;newname&quot;127.0.0.1:6379&gt; set name1 newname1 xx -- key不存在时，不更新(nil)127.0.0.1:6379&gt; get name1(nil)127.0.0.1:6379&gt; get name&quot;nawvalue&quot; mset 和 mget 设置（得到） 多个key的值1234567127.0.0.1:6379&gt; mset date &quot;2019.08.30&quot; time &quot;11:00 a.m.&quot; weather &quot;sunny&quot;OK127.0.0.1:6379&gt; mget date time name weather1) &quot;2019.08.30&quot;2) &quot;11:00 a.m.&quot;3) &quot;weilai&quot;4) &quot;sunny&quot; append 添加字符串1234127.0.0.1:6379&gt; append name &apos;1995&apos;(integer) 10127.0.0.1:6379&gt; GET name&quot;weilai1995&quot; del 删除1234127.0.0.1:6379&gt; del name(integer) 1127.0.0.1:6379&gt; get name(nil) incr/decr 增加/减少 112345678910111213141516127.0.0.1:6379&gt; decr num(integer) -1127.0.0.1:6379&gt; get num&quot;-1&quot;127.0.0.1:6379&gt; incr num(integer) 0127.0.0.1:6379&gt; get num&quot;0&quot;127.0.0.1:6379&gt; incrby num 3(integer) 3127.0.0.1:6379&gt; decrby num 2(integer) 1127.0.0.1:6379&gt; get num&quot;1&quot;127.0.0.1:6379&gt; incrbyfloat num 3.5&quot;4.5&quot; HashRedis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。HMSET, HGETALL 命令 user:1 为键值12345678910111213141516171819202122232425262728293031323334353637383940414243redis 127.0.0.1:6379&gt; hmset user:1 username weilai password handsome OK127.0.0.1:6379&gt; hmget user:1 username password1) &quot;weilai&quot;2) &quot;handsome&quot;redis 127.0.0.1:6379&gt; HGETALL user:11) &quot;username&quot;2) &quot;weilai&quot;3) &quot;password&quot;4) &quot;handsome&quot;127.0.0.1:6379&gt; hmget user:1 username password port1) &quot;weilai&quot;2) &quot;handsome&quot;3) &quot;22&quot;redis 127.0.0.1:6379&gt; hget user:1 username&quot;weilai&quot;127.0.0.1:6379&gt; HGET user:1 weilai(nil)127.0.0.1:6379&gt; hkeys user:1 # 获取 key1) &quot;username&quot;2) &quot;password&quot;3) &quot;port&quot;127.0.0.1:6379&gt; hvals user:1 #获取 value1) &quot;weilai&quot;2) &quot;handsome&quot;3) &quot;22&quot;127.0.0.1:6379&gt; hlen user:1(integer) 3127.0.0.1:6379&gt; hexists user:1 password # 是否存在 passw(integer) 1127.0.0.1:6379&gt; hexists user:1 passwd(integer) 0 hdel user:1 password port(integer) 2127.0.0.1:6379&gt; hgetall user:11) &quot;username&quot;2) &quot;weilai&quot;127.0.0.1:6379&gt; hsetnx user:1 username fisher # 存在username 不创建(integer) 0127.0.0.1:6379&gt; hgetall user:1 1) &quot;username&quot;2) &quot;weilai&quot;# 每个 hash 可以存储 232 - 1 键值对（40多亿） ListRedis 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素lpush到列表的头部（左边）或者rpush尾部（右边）lrange 获取指定长度 （从0 开始） lpushx/rpushx 只能是 key 存在，且仅能添加一个 lpop/rpop 移除最左/右 边 的一个元素 ltrim 截取一段长度 llen 列表元素个数 lrem weilai 0 python 删除所有的’python’123456789101112131415161718192021222324252627282930313233343536373839404142redis 127.0.0.1:6379&gt; lpush weilai redis(integer) 1redis 127.0.0.1:6379&gt; lpush weilai mongodb(integer) 2redis 127.0.0.1:6379&gt; rpush weilai rabitmq(integer) 3redis 127.0.0.1:6379&gt; lrange weilai 0 101) &quot;mongodb&quot;2) &quot;redis&quot;3) &quot;rabitmq&quot;&quot;127.0.0.1:6379&gt; lrange weilai 0 11) &quot;mongodb&quot;2) &quot;redis&quot;127.0.0.1:6379&gt; llen weilai(integer) 3127.0.0.1:6379&gt; lpush weilai python java c++ shell(integer) 8127.0.0.1:6379&gt; lrange weilai 0 10 1) &quot;shell&quot;2) &quot;c++&quot;3) &quot;java&quot;4) &quot;python&quot;5) &quot;mongodb&quot;6) &quot;redis&quot;7) &quot;rabitmq&quot;127.0.0.1:6379&gt; lrem weilai 0 python # 删除所有的python 元素(integer) 1127.0.0.1:6379&gt; lrange weilai 0 10 1) &quot;shell&quot;2) &quot;c++&quot;3) &quot;java&quot;4) &quot;mongodb&quot;5) &quot;redis&quot;6) &quot;rabitmq&quot;127.0.0.1:6379&gt; ltrim weilai 2 4OK127.0.0.1:6379&gt; lrange weilai 0 101) &quot;java&quot;2) &quot;mongodb&quot;3) &quot;redis&quot;# 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿) SetRedis的Set是string类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1) sadd/srem 添加/删除元素sismember 判断是否为set的一个元素smembers 返回该集合的所有成员sdiff 返回一个集合与其它集合的差异sinter 返回几个集合的交集sunion 返回几个集合的并集 12345678910111213141516171819202122232425262728293031323334353637127.0.0.1:6379&gt; sadd zoo cat dog(integer) 2127.0.0.1:6379&gt; sadd zoo cat dog fisher(integer) 1127.0.0.1:6379&gt; smembers zoo1) &quot;fisher&quot;2) &quot;dog&quot;3) &quot;cat&quot;127.0.0.1:6379&gt; srem zoo cat(integer) 1127.0.0.1:6379&gt; srem zoo cat(integer) 0127.0.0.1:6379&gt; sismember zoo cat(integer) 0127.0.0.1:6379&gt; sismember zoo fisher(integer) 1127.0.0.1:6379&gt; smembers zoo1) &quot;fisher&quot;2) &quot;dog&quot;127.0.0.1:6379&gt; sadd zoo1 dog cow(integer) 2127.0.0.1:6379&gt; smembers zoo11) &quot;cow&quot;2) &quot;dog&quot;127.0.0.1:6379&gt; sdiff zoo zoo11) &quot;fisher&quot;127.0.0.1:6379&gt; sdiff zoo1 zoo1) &quot;cow&quot;127.0.0.1:6379&gt; sinter zoo1 zoo1) &quot;dog&quot;127.0.0.1:6379&gt; sunion zoo1 zoo1) &quot;fisher&quot;2) &quot;dog&quot;3) &quot;cow&quot;# 添加一个string元素到,key对应的set集合中，成功返回1,如果元素以及在集合中返回0,key对应的set不存在返回错误。集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员) zset(sorted set：有序集合)Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 zset的成员是唯一的,但分数(score)却可以重复 12345678910111213redis 127.0.0.1:6379&gt; zadd weilai 0 redis(integer) 1redis 127.0.0.1:6379&gt; zadd weilai 0 mongodb(integer) 1redis 127.0.0.1:6379&gt; zadd weilai 0 rabitmq(integer) 1redis 127.0.0.1:6379&gt; zadd weilai 10 redis -- 添加元素到集合，元素在集合中存在则更新对应score(integer) 0redis 127.0.0.1:6379&gt; ZRANGEBYSCORE weilai 0 10001) &quot;redis&quot;2) &quot;mongodb&quot;3) &quot;rabitmq&quot;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter备份]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2Fbackup%2Fnginx%2Freadme%2F</url>
    <content type="text"><![CDATA[pip3 install jupyter vi /usr/share/vim/vim81/defaults.vim jupyter notebook –generate-config jupyter contrib nbextension install –user –skip-running-check vi /root/.jupyter/jupyter_notebook_config.py rm /etc/nginx/sites-enabled/default ln -s /root/flask_nginx.conf /etc/nginx/conf.d/ setsid uwsgi –ini /root/flask_uwsgi.ini &amp; nohup jupyter notebook –allow-root &gt; jupyter.log 2&gt;&amp;1 &amp; service nginx restart 12from notebook.auth import passwdpasswd() 1234567891011# 允许通过任意绑定服务器的ip访问c.NotebookApp.ip = &apos;*&apos;# 用于访问的端口c.NotebookApp.port = 8527# 不自动打开浏览器c.NotebookApp.open_browser = False# 设置登录密码c.NotebookApp.password = &apos;sha1:14855cd59712:1cf1063d38e08cd2703a07a52b66714281676b6d&apos;# 设置默认目录c.NotebookApp.notebook_dir = u&apos;/root/&apos;c.NotebookApp.base_url = &apos;/jupyter/&apos;]]></content>
      <categories>
        <category>jupyter</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb常用命令]]></title>
    <url>%2Fmongodb%2Fmongodb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.mongo连入本机数据库 2.mongo 10.66.66.126:27017连入ip地址为10.66.66.126的机器的数据库 3.db / db.getName()查看当前数据库(db就是Database) 4.use demo切换/创建数据库(demo为数据库名) 5.show dbs查看所有数据库show tables查看所有表集合 6.db.dropDatabase()删除当前操作的数据库 7.db.copyDatabase(“mydb”, “temp”, “127.0.0.1”)从指定的机器上复制指定数据库数据到某个数据库，将本机的mydb的数据复制到temp数据库中 8.db.repairDatabase()修复当前数据库 9.db.version()当前db版本 10.db.stats()显示当前db状态 11.db.getMongo()查看当前db的链接机器地址 12.数据库表 (Collection聚集集合 ) 1)创建一个表 db.createCollection(“collName”, {size: 20, capped: 5, max: 100}) 2)得到指定名称的表 db.getCollection(&quot;table&quot;) 3)查询当前db的所有表名的集合 db.getCollectionNames() 4)显示当前db所有表索引的状态 db.printCollectionStats() 13.查数据 1)查询某表中所有记录(如果数据太多分页查看输出 it 回车) db.table.find() 相当于：select * from table; db.table.find().pretty() 查看的数据格式化 db.table.find({}, {id: 0, “name”: 0}) 查询表中所有数据,id和name字段不返回 db.table.find({}, {id: 1, “name”: 1}) 查询表中所有数据,id和name字段返回(默认返回) 2)查询某张表中的某个字段的重复数据(会过滤掉name字段中相同的数据) db.table.distinct(&quot;name&quot;) 相当于: select distinct name from table; 3)查询某张表中&quot;name&quot;=&quot;Bill&quot;的数据 db.table.find({&quot;name&quot;=&quot;Bill&quot;}) 相当于：select * from table where name = Bill; 4)查询某张表中 id &gt; 1 的数据 ($gt &gt;, $lt &lt;，$gte &gt;=, $lte &lt;=, $ne !=) db.table.find({id: {$gt: 1}}) 相当于: select * from table where id &gt; 1; 5)查询某张表中 id &gt; 1 $$ id &lt;= 5的数据 db.table.find({id: {$gt: 1,$lte: 5}}) 相当于： select * from table where (id &gt; 1 and id &lt;= 5); 6)查询某张表中 name 中包含 li 的数据 db.table.find({name: /li/}) 相当于： select * from table where name like &apos;%li%&apos;; 7)查询某张表中 name 以 li 开头的数据 db.table.find({name: /^li/}) 相当于： select * from table where name like &apos;li%&apos;; 8)查询某张表中 name 以 li 结尾的数据 db.table.find({name: /li$/}) 相当于：select * from table where name like &apos;%li&apos;; 9)查询指定列 name 和 work 的数据 db.table.find({}, {name: 1, work: 1}) 相当于：select name, work from table; 10)查询 id &gt; 3 的指定列 name 和 work 的数据 db.table.find({id: {$gt: 3}}, {name: 1, work: 1}) 想当于： select name, work from table where id &gt; 3; 11)按照 number 大小 升序和降序查询 (1表示升序, -1表示降序) 升序: db.table.find().sort({number: 1}) 降序：db.table.find().sort({number: -1}) 12)查询前三条数据 db.table.find().limit(3) 相当于：select top 3 * from table; 13)查询前三条之后的数据 db.table.find().skip(3) 相当于：select * from table where id not in (select top 3 * from table); 14)查询前三条之后的5条数据 db.table.find().limit(5).skip(3) 15)查询 id=2 或者 id=5 的数据($or 或者, $in 包含, $nin 不包含) db.table.find({$or: [{id: 2}, {id: 5}]}) 相当于：select * from table where id = 2 or id = 5; 16)查询第一条数据 db.table.findOne() 相当于：select top 1 * from table; 17)查询 id &gt;= 5 的数据的个数 (count() 查询数量) db.table.find({id: {$gte: 5}}).count() 相当于：select count(*) from table where id &gt;= 5; 18)查询有 name字段 的数据的个数 db.table.find({name: {$exists: true}}).count() 相当于: select count(name) from table; 14.索引索引是为了快速查找数据用的,主要是用来降低CPU成本消耗的。索引相当于排序，但与排序不同的是，排序是将原数据重新排列，改变了原数据的排列顺序。而索引只是建立一个顺序表，由这个顺序表指出数据的顺序，所以索引不改变原数据的排列顺序。MongoDB支持的索引：_id索引(默认建立)、单键索引、多键索引、复合索引、过期索引、全文索引、地理位置索引此外，排序可能升序或降序排列，而索引只有升序一种方式。 1)创建索引 db.table.ensureIndex({name: 1}) db.table.ensureIndex({name: 1, ts: -1}) 2)查询当前聚集集合所有索引 db.table.getIndexes() 3)查看总索引记录大小 db.table.totalIndexSize() 4)读取当前集合的所有index信息 db.table.reIndex() 5)删除指定索引 db.table.dropIndex(&quot;name_1&quot;) 6)删除所有索引索引 db.table.dropIndexes() 15.添加数据 1)插入数据字段 db.table.insert({}) db.table.save({}) 2)导入数据表 mongoimport -d Lanyu -c shangpin --file D:\MongoDB\data\product.json --jsonArray -d: 数据库 -c: 表名 --file: 数据文件地址 --jsonArray: 导入json文件专用,否则导入失败, json文件格式：[{},{},{},{},{}] 16.修改数据 1)修改表中条件为 name : “baiqi” 的数据的 字段 number($set设置) db.table.update({name: “baiqi”}, {$set: {number: “111”}}, false, true) 第一个false表示不新增数据 相当于：update table set number = ‘111’ where name = “baiqi”; 2)修改表中条件为 name : &quot;mayun&quot; 的数据 让 number = number + 111, id = id + 2($inc自增) db.table.update({name: &quot;mayun&quot;}, {$inc: {number: 111, id: 2}}, false, true) 相当于：update table set number = number + 111, id = id + 2 where name = &quot;mayun&quot;; 3)综合上面两个修改 db.table.update({name: &apos;liuqiangdong&apos;}, {$inc: {id: 3}, $set: {number: 113}}, false, true) 相当于： update table set id = id + 3, number = 113 where name = &apos;liuqiangdong&apos;; 17.删除数据 db.table.remove({_id: ObjectId(“59a67e103cbae75d282fe46b”)}) 其他 1)查询之前的错误信息 db.getPrevError() 2)清除错误记录 db.resetError()]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python操作MongoDB]]></title>
    <url>%2Fmongodb%2Fpython%E6%93%8D%E4%BD%9CMongoDB%2F</url>
    <content type="text"><![CDATA[python操作MongoDB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from pymongo import MongoClientfrom dataclasses import dataclassfrom bson.objectid import ObjectId@dataclassclass Test_Mongo(): client:dict = MongoClient() db:dict = client[&apos;test&apos;] # 连接到 test 数据库 def add_one(self): post = &#123; &apos;name&apos;: &apos;justin&apos;, &apos;age&apos;: 18, &apos;sex&apos;: &apos;male&apos;, &apos;grade&apos;: 80 &#125; return self.db.students.insert_one(post) def add_many(self): return self.db.students.insert_many([&#123;&apos;name&apos;:i&#125; for i in range(0,10)]) def get_one(self): return self.db.students.find_one(&#123;&apos;name&apos;:&apos;justin&apos;&#125;) def get_more(self): return self.db.students.find(&#123;&apos;sex&apos;:&apos;male&apos;&#125;) def get_one_from_oid(self, oid): obj = ObjectId(oid) return self.db.students.find_one(&#123;&apos;_id&apos;: obj&#125;) def get_count(self): return self.db.students.estimated_document_count() def update_one(self): return self.db.students.update_one(&#123;&apos;name&apos;:&apos;justin&apos;&#125;,&#123;&apos;$inc&apos;:&#123;&apos;age&apos;:10&#125;&#125;) def update_many(self): return self.db.students.update_many(&#123;&#125;,&#123;&apos;$inc&apos;:&#123;&apos;age&apos;:5&#125;&#125;) def delete_one(self): return self.db.students.delete_one(&#123;&apos;name&apos;:&apos;justin&apos;&#125;) def delete_many(self): return self.db.students.delete_many(&#123;&apos;name&apos;:&apos;justin&apos;&#125;)def main(): obj = Test_Mongo() print(obj.add_one().inserted_id) print(obj.get_one()) print(obj.add_many().inserted_ids) print(obj.get_count()) for item in obj.get_more(): print(item[&apos;_id&apos;]) print(obj.get_one_from_oid(obj.add_one().inserted_id)) print(obj.update_one().matched_count) print(obj.update_one().matched_count) print(obj.update_many().matched_count) print(obj.update_many().matched_count) print(obj.delete_one().deleted_count) print(obj.delete_many().deleted_count)if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[odm]]></title>
    <url>%2Fmongodb%2Fodm%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728from mongoengine import connect, Document, StringField, IntField, \ FloatField, EmbeddedDocument, ListField, EmbeddedDocumentField, DynamicDocument # 可以在后面插入其他关键字connect(&apos;test&apos;) # 连接的数据库# connect(&apos;test&apos;, host = &apos;192.168.0.2&apos;, port=27017)# connect(&apos;test&apos;, host = &apos;mongodb://localhost/test&apos;) SEX_CHOICE = ( (&apos;male&apos;, &apos;男&apos;), (&apos;female&apos;, &apos;女&apos;))class Grade(EmbeddedDocument): &apos;&apos;&apos; 成绩信息 &apos;&apos;&apos; name = StringField(required=True) score = FloatField(required=True)class Student(DynamicDocument): # 可以在后面插入其他关键字 &apos;&apos;&apos; 学生信息 &apos;&apos;&apos; name = StringField(max_length=32, required=True) age = IntField(required=True) sex = StringField(choices=SEX_CHOICE, required=True) grade = FloatField() address = StringField() grades = ListField(EmbeddedDocumentField(Grade)) # 与 Grade 关联 meta = &#123; &apos;collection&apos;: &apos;students&apos; # 指定连接的集合 &#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb插入数据]]></title>
    <url>%2Fmongodb%2F%E5%85%A5%E9%97%A8%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[插入数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203&gt; use testswitched to db test&gt; db.students.insertMany(... [&#123;&quot;name&quot;: &quot;测试-0&quot;, &quot;age&quot;: 63, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 1&#125;,&#123;&quot;name&quot;: &quot;测试-1&quot;, &quot;age&quot;: 32, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 7&#125;,&#123;&quot;name&quot;: &quot;测试-2&quot;, &quot;age&quot;: 20, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 8&#125;,&#123;&quot;name&quot;: &quot;测试-3&quot;, &quot;age&quot;: 55, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 58&#125;,&#123;&quot;name&quot;: &quot;测试-4&quot;, &quot;age&quot;: 84, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 65&#125;,&#123;&quot;name&quot;: &quot;测试-5&quot;, &quot;age&quot;: 27, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 57&#125;,&#123;&quot;name&quot;: &quot;测试-6&quot;, &quot;age&quot;: 86, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 61&#125;,&#123;&quot;name&quot;: &quot;测试-7&quot;, &quot;age&quot;: 18, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 93&#125;,&#123;&quot;name&quot;: &quot;测试-8&quot;, &quot;age&quot;: 50, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 71&#125;,&#123;&quot;name&quot;: &quot;测试-9&quot;, &quot;age&quot;: 81, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 42&#125;,&#123;&quot;name&quot;: &quot;测试-10&quot;, &quot;age&quot;: 26, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 25&#125;,&#123;&quot;name&quot;: &quot;测试-11&quot;, &quot;age&quot;: 91, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 14&#125;,&#123;&quot;name&quot;: &quot;测试-12&quot;, &quot;age&quot;: 6, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 54&#125;,&#123;&quot;name&quot;: &quot;测试-13&quot;, &quot;age&quot;: 73, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 24&#125;,&#123;&quot;name&quot;: &quot;测试-14&quot;, &quot;age&quot;: 51, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 14&#125;,&#123;&quot;name&quot;: &quot;测试-15&quot;, &quot;age&quot;: 53, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 19&#125;,&#123;&quot;name&quot;: &quot;测试-16&quot;, &quot;age&quot;: 3, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 48&#125;,&#123;&quot;name&quot;: &quot;测试-17&quot;, &quot;age&quot;: 13, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 11&#125;,&#123;&quot;name&quot;: &quot;测试-18&quot;, &quot;age&quot;: 40, &quot;sex&quot;: &quot;female&quot;, &quot;grade&quot;: 97&#125;,&#123;&quot;name&quot;: &quot;测试-19&quot;, &quot;age&quot;: 97, &quot;sex&quot;: &quot;male&quot;, &quot;grade&quot;: 96&#125;])&#123; &quot;acknowledged&quot; : true, &quot;insertedIds&quot; : [ ObjectId(&quot;5de8b35c75deb540ecfc5332&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5333&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5334&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5335&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5336&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5337&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5338&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5339&quot;), ObjectId(&quot;5de8b35c75deb540ecfc533a&quot;), ObjectId(&quot;5de8b35c75deb540ecfc533b&quot;), ObjectId(&quot;5de8b35c75deb540ecfc533c&quot;), ObjectId(&quot;5de8b35c75deb540ecfc533d&quot;), ObjectId(&quot;5de8b35c75deb540ecfc533e&quot;), ObjectId(&quot;5de8b35c75deb540ecfc533f&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5340&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5341&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5342&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5343&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5344&quot;), ObjectId(&quot;5de8b35c75deb540ecfc5345&quot;) ]&#125;&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5332&quot;), &quot;name&quot; : &quot;测试-0&quot;, &quot;age&quot; : 63, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 1 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5333&quot;), &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 32, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 7 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5334&quot;), &quot;name&quot; : &quot;测试-2&quot;, &quot;age&quot; : 20, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 8 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5335&quot;), &quot;name&quot; : &quot;测试-3&quot;, &quot;age&quot; : 55, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 58 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5336&quot;), &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 84, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 65 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5337&quot;), &quot;name&quot; : &quot;测试-5&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 57 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5338&quot;), &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 86, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5339&quot;), &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533a&quot;), &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 50, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533b&quot;), &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 81, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 42 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533c&quot;), &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 26, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 25 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533d&quot;), &quot;name&quot; : &quot;测试-11&quot;, &quot;age&quot; : 91, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533e&quot;), &quot;name&quot; : &quot;测试-12&quot;, &quot;age&quot; : 6, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 54 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533f&quot;), &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 73, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 24 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5340&quot;), &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 51, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5341&quot;), &quot;name&quot; : &quot;测试-15&quot;, &quot;age&quot; : 53, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 19 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5342&quot;), &quot;name&quot; : &quot;测试-16&quot;, &quot;age&quot; : 3, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 48 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5343&quot;), &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 13, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 11 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5344&quot;), &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 40, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5345&quot;), &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 97, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 96 &#125;&gt; db.students.find(&#123;sex:&apos;male&apos;&#125;,&#123;age:1,name:1,_id:0&#125;) # sex 为 male false 不显示， true 显示&#123; &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 32 &#125;&#123; &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 84 &#125;&#123; &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 81 &#125;&#123; &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 26 &#125;&#123; &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 73 &#125;&#123; &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 51 &#125;&#123; &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 13 &#125;&#123; &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 97 &#125;&gt; db.students.find(&#123;grade:&#123;&apos;$gte&apos;:60&#125;&#125;,&#123;_id:0&#125;) # grade 大于等于 60 &#123; &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 84, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 65 &#125;&#123; &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 86, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61 &#125;&#123; &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93 &#125;&#123; &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 50, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71 &#125;&#123; &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 40, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97 &#125;&#123; &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 97, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 96 &#125;&gt; db.students.find(&#123;&apos;$or&apos;:[&#123;sex:&apos;female&apos;,age:18&#125;,&#123;sex:&apos;male&apos;,age:81&#125;]&#125;,&#123;_id:0&#125;) # age =18,sex = famale 或 age = 81,sex = male&#123; &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93 &#125;&#123; &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 81, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 42 &#125;&gt; db.students.find().sort(&#123;age:-1&#125;) # 按 age 倒序 &#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5345&quot;), &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 97, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 96 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533d&quot;), &quot;name&quot; : &quot;测试-11&quot;, &quot;age&quot; : 91, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5338&quot;), &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 86, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5336&quot;), &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 84, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 65 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533b&quot;), &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 81, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 42 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533f&quot;), &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 73, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 24 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5332&quot;), &quot;name&quot; : &quot;测试-0&quot;, &quot;age&quot; : 63, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 1 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5335&quot;), &quot;name&quot; : &quot;测试-3&quot;, &quot;age&quot; : 55, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 58 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5341&quot;), &quot;name&quot; : &quot;测试-15&quot;, &quot;age&quot; : 53, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 19 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5340&quot;), &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 51, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533a&quot;), &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 50, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5344&quot;), &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 40, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5333&quot;), &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 32, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 7 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5337&quot;), &quot;name&quot; : &quot;测试-5&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 57 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533c&quot;), &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 26, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 25 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5334&quot;), &quot;name&quot; : &quot;测试-2&quot;, &quot;age&quot; : 20, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 8 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5339&quot;), &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5343&quot;), &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 13, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 11 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc533e&quot;), &quot;name&quot; : &quot;测试-12&quot;, &quot;age&quot; : 6, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 54 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8b35c75deb540ecfc5342&quot;), &quot;name&quot; : &quot;测试-16&quot;, &quot;age&quot; : 3, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 48 &#125;&gt; db.students.find(&#123;&#125;,&#123;_id:0&#125;).sort(&#123;age:1&#125;) # 查询所有，不显示_id,按age 升序&#123; &quot;name&quot; : &quot;测试-16&quot;, &quot;age&quot; : 3, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 48 &#125;&#123; &quot;name&quot; : &quot;测试-12&quot;, &quot;age&quot; : 6, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 54 &#125;&#123; &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 13, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 11 &#125;&#123; &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93 &#125;&#123; &quot;name&quot; : &quot;测试-2&quot;, &quot;age&quot; : 20, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 8 &#125;&#123; &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 26, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 25 &#125;&#123; &quot;name&quot; : &quot;测试-5&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 57 &#125;&#123; &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 32, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 7 &#125;&#123; &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 40, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97 &#125;&#123; &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 50, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71 &#125;&#123; &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 51, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;name&quot; : &quot;测试-15&quot;, &quot;age&quot; : 53, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 19 &#125;&#123; &quot;name&quot; : &quot;测试-3&quot;, &quot;age&quot; : 55, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 58 &#125;&#123; &quot;name&quot; : &quot;测试-0&quot;, &quot;age&quot; : 63, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 1 &#125;&#123; &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 73, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 24 &#125;&#123; &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 81, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 42 &#125;&#123; &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 84, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 65 &#125;&#123; &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 86, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61 &#125;&#123; &quot;name&quot; : &quot;测试-11&quot;, &quot;age&quot; : 91, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 97, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 96 &#125;&gt; db.students.update(&#123;&#125;,&#123;&apos;$set&apos;:&#123;class:&apos;class 1&apos;&#125;&#125;) # 仅修改第一条数据WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)&gt; db.students.find(&#123;&#125;,&#123;_id:0&#125;)&#123; &quot;name&quot; : &quot;测试-0&quot;, &quot;age&quot; : 63, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 1, &quot;class&quot; : &quot;class 1&quot; &#125;&#123; &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 32, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 7 &#125;&#123; &quot;name&quot; : &quot;测试-2&quot;, &quot;age&quot; : 20, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 8 &#125;&#123; &quot;name&quot; : &quot;测试-3&quot;, &quot;age&quot; : 55, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 58 &#125;&#123; &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 84, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 65 &#125;&#123; &quot;name&quot; : &quot;测试-5&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 57 &#125;&#123; &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 86, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61 &#125;&#123; &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93 &#125;&#123; &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 50, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71 &#125;&#123; &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 81, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 42 &#125;&#123; &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 26, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 25 &#125;&#123; &quot;name&quot; : &quot;测试-11&quot;, &quot;age&quot; : 91, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;name&quot; : &quot;测试-12&quot;, &quot;age&quot; : 6, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 54 &#125;&#123; &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 73, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 24 &#125;&#123; &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 51, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 14 &#125;&#123; &quot;name&quot; : &quot;测试-15&quot;, &quot;age&quot; : 53, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 19 &#125;&#123; &quot;name&quot; : &quot;测试-16&quot;, &quot;age&quot; : 3, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 48 &#125;&#123; &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 13, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 11 &#125;&#123; &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 40, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97 &#125;&#123; &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 97, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 96 &#125;&gt; db.students.update(&#123;&#125;,&#123;&apos;$set&apos;:&#123;class:&apos;class 2&apos;&#125;&#125;,&#123;multi:true&#125;) # &#123;multi:true&#125; 多条属性WriteResult(&#123; &quot;nMatched&quot; : 20, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 19 &#125;)&gt; db.students.find(&#123;&#125;,&#123;_id:0&#125;)&#123; &quot;name&quot; : &quot;测试-0&quot;, &quot;age&quot; : 63, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 1, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 32, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 7, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-2&quot;, &quot;age&quot; : 20, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 8, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-3&quot;, &quot;age&quot; : 55, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 58, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 84, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 65, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-5&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 57, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 86, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 50, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 81, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 42, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 26, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 25, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-11&quot;, &quot;age&quot; : 91, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 14, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-12&quot;, &quot;age&quot; : 6, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 54, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 73, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 24, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 51, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 14, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-15&quot;, &quot;age&quot; : 53, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 19, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-16&quot;, &quot;age&quot; : 3, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 48, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 13, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 11, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 40, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 97, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 96, &quot;class&quot; : &quot;class 2&quot; &#125;&gt; db.students.update(&#123;&#125;,&#123;&apos;$inc&apos;:&#123;age:1&#125;&#125;,&#123;multi:true&#125;) # 所有人的age加1 WriteResult(&#123; &quot;nMatched&quot; : 20, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 20 &#125;)&gt; db.students.find(&#123;&#125;,&#123;_id:0&#125;) &#123; &quot;name&quot; : &quot;测试-0&quot;, &quot;age&quot; : 64, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 1, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 33, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 7, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-2&quot;, &quot;age&quot; : 21, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 8, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-3&quot;, &quot;age&quot; : 56, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 58, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 85, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 65, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-5&quot;, &quot;age&quot; : 28, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 57, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 87, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 19, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 51, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 82, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 42, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 25, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-11&quot;, &quot;age&quot; : 92, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 14, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-12&quot;, &quot;age&quot; : 7, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 54, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 74, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 24, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 52, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 14, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-15&quot;, &quot;age&quot; : 54, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 19, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-16&quot;, &quot;age&quot; : 4, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 48, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 14, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 11, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 41, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 98, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 96, &quot;class&quot; : &quot;class 2&quot; &#125;&gt; db.students.update(&#123;sex:&apos;male&apos;&#125;,&#123;&apos;$inc&apos;:&#123;grade:-1&#125;&#125;,&#123;multi:true&#125;) # sex:male 的grade 减1 WriteResult(&#123; &quot;nMatched&quot; : 8, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 8 &#125;)&gt; db.students.find(&#123;&#125;,&#123;_id:0&#125;)&#123; &quot;name&quot; : &quot;测试-0&quot;, &quot;age&quot; : 64, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 1, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-1&quot;, &quot;age&quot; : 33, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 6, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-2&quot;, &quot;age&quot; : 21, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 8, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-3&quot;, &quot;age&quot; : 56, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 58, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-4&quot;, &quot;age&quot; : 85, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 64, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-5&quot;, &quot;age&quot; : 28, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 57, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-6&quot;, &quot;age&quot; : 87, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 61, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-7&quot;, &quot;age&quot; : 19, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 93, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-8&quot;, &quot;age&quot; : 51, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 71, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-9&quot;, &quot;age&quot; : 82, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 41, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-10&quot;, &quot;age&quot; : 27, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 24, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-11&quot;, &quot;age&quot; : 92, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 14, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-12&quot;, &quot;age&quot; : 7, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 54, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-13&quot;, &quot;age&quot; : 74, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 23, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-14&quot;, &quot;age&quot; : 52, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 13, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-15&quot;, &quot;age&quot; : 54, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 19, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-16&quot;, &quot;age&quot; : 4, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 48, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-17&quot;, &quot;age&quot; : 14, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 10, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-18&quot;, &quot;age&quot; : 41, &quot;sex&quot; : &quot;female&quot;, &quot;grade&quot; : 97, &quot;class&quot; : &quot;class 2&quot; &#125;&#123; &quot;name&quot; : &quot;测试-19&quot;, &quot;age&quot; : 98, &quot;sex&quot; : &quot;male&quot;, &quot;grade&quot; : 95, &quot;class&quot; : &quot;class 2&quot; &#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test_odm]]></title>
    <url>%2Fmongodb%2Ftest_odm%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from odm import Grade, Studentclass TestMongoEngine: def add_one(self): math = Grade(name = &apos;数学&apos;, score = 90) English = Grade(name = &apos;英语&apos;, score = 89.5) stu_obj = Student( name = &apos;weilai&apos;, age = 22, sex = &apos;male&apos;, grades = [math, English] ) stu_obj.remake = &apos;remake&apos; # 动态插入 stu_obj.save() return stu_obj def get_one(self): return Student.objects.first() def get_more(self): return Student.objects.all() def get_from_oid(self, oid): return Student.objects.filter(pk=oid).first() # 根据id 得到一条数据 def update_more(self): return Student.objects.filter(sex=&apos;male&apos;,age__gt=20).update(inc__age=10) def update_one(self): return Student.objects.filter(sex=&apos;male&apos;,age__gt=20).update_one(inc__age=100) def delete_one(self): return Student.objects.filter(sex=&apos;male&apos;).first().delete() def delete_more(self): return Student.objects.filter(sex=&apos;male&apos;).delete()def main(): obj = TestMongoEngine() result = obj.add_one() print(result.pk) get_one = obj.get_one() print(get_one.id) print(get_one.name) print(obj.get_from_oid(get_one.id).id) rows = obj.get_more() for row in rows: print(row.sex) print(obj.update_more()) print(obj.update_one()) print(obj.delete_one()) print(obj.delete_more())if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb入门]]></title>
    <url>%2Fmongodb%2F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介文档 eg: {“foo”:3,”greeting”:”Hello world!”} 区分大小写 key唯一 文档可嵌套 键值对 有序 集合 集合就是一组文档 文档类似于 关系库里的 行 集合类似于 关系库里的表 集合中的文档无需固定的结构 集合命名规则： 数据库 多个文档组成集合，多个集合组成数据库 一个实例 可以承载多个数据库 （可以理解为一个mongodb可以有多个数据库） 每个数据库都有独立权限 保留的数据库名称（admin,local,config） 使用命令行操作数据库兼容js操作 1+23function add(r1,r2){… return r1 + r2;… }add(8,2)10 新增数据show dbs 查看所有数据库db.collection.insert()db.collection.insertOne()db.collection.insertMany()123&gt; show dbsadmin 0.078GBlocal 0.078GB use test 使用 test 数据库 （没有就会创建）12345678910&gt; use studentsswitched to db students&gt; db # 查看当前数据库students&gt; stu = &#123; name : &apos;weilai&apos;, age : 22 &#125;&#123; &quot;name&quot; : &quot;weilai&quot;, &quot;age&quot; : 22 &#125;&gt; db.students.insert(stu)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.students.insert(&#123; &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot;: &quot;male&quot; &#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;) 查询数据db.collection.find()123&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5de8a491ff626673ec5503c9&quot;), &quot;name&quot; : &quot;weilai&quot;, &quot;age&quot; : 22 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8a554ff626673ec5503ca&quot;), &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125; db.collection.findOne()123456&gt; db.students.findOne() # 查询第一条数据&#123; &quot;_id&quot; : ObjectId(&quot;5de8a491ff626673ec5503c9&quot;), &quot;name&quot; : &quot;weilai&quot;, &quot;age&quot; : 22&#125; 修改数据db.collection.update()1234567891011121314&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5de8a491ff626673ec5503c9&quot;), &quot;name&quot; : &quot;weilai&quot;, &quot;age&quot; : 22 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8a554ff626673ec5503ca&quot;), &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125;&gt; s = db.students.findOne()&#123; &quot;_id&quot; : ObjectId(&quot;5de8a491ff626673ec5503c9&quot;), &quot;name&quot; : &quot;weilai&quot;, &quot;age&quot; : 22&#125;&gt; db.students.update(&#123;name:&apos;weilai&apos;&#125;,&#123;name:&apos;cool&apos;&#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5de8a491ff626673ec5503c9&quot;), &quot;name&quot; : &quot;cool&quot; &#125; # 直接替换，并非仅修改 name 的值&#123; &quot;_id&quot; : ObjectId(&quot;5de8a554ff626673ec5503ca&quot;), &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125; 仅修改值1234567891011121314&gt; s_obj = db.students.findOne(&#123;&apos;name&apos;:&apos;weilai1&apos;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;5de8a554ff626673ec5503ca&quot;), &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot;&#125;&gt; s_obj.name = &apos;amy&apos;amy&gt; db.students.update(&#123;name:&apos;weilai1&apos;&#125;,s_obj)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5de8a491ff626673ec5503c9&quot;), &quot;name&quot; : &quot;cool&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8a554ff626673ec5503ca&quot;), &quot;name&quot; : &quot;amy&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125; 删除数据db.collection.remove({name:&#39;cool&#39;}) 删除 1条数据db.collection.remove({}) 删除所有数据123456789101112131415&gt; db.students.insert(&#123; &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot;: &quot;male&quot; &#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5de8a491ff626673ec5503c9&quot;), &quot;name&quot; : &quot;cool&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8a554ff626673ec5503ca&quot;), &quot;name&quot; : &quot;amy&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8ae63ff626673ec5503cb&quot;), &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125;&gt; db.students.remove(&#123;name:&apos;cool&apos;&#125;)WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)&gt; db.students.find()&#123; &quot;_id&quot; : ObjectId(&quot;5de8a554ff626673ec5503ca&quot;), &quot;name&quot; : &quot;amy&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5de8ae63ff626673ec5503cb&quot;), &quot;name&quot; : &quot;weilai1&quot;, &quot;age&quot; : 22, &quot;sex&quot; : &quot;male&quot; &#125;&gt; db.students.remove(&#123;&#125;)WriteResult(&#123; &quot;nRemoved&quot; : 2 &#125;)&gt; db.students.find()&gt;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb补充数据]]></title>
    <url>%2Fmongodb%2F%E5%85%A5%E9%97%A8%E8%A1%A5%E5%85%85%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021import randomimport jsona = &#123; &apos;name&apos; : &apos;weilai&apos;, &apos;age&apos; : 18, &apos;sex&apos;: &apos;male&apos;, &apos;grade&apos; : 45 &#125;list_json = []for i in range(0,20): a[&apos;name&apos;] = f&quot;测试-&#123;i&#125;&quot; a[&apos;age&apos;] = random.randint(0, 100) a[&apos;sex&apos;] = random.choice([&apos;male&apos;, &apos;female&apos;]) a[&apos;grade&apos;] = random.randint(0, 100) j = json.dumps(a, ensure_ascii=False) list_json.append(j)list_json = &apos;,&apos;.join(list_json)list_json = &apos;[&apos; + list_json +&apos;]&apos;print(list_json)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker推送备份]]></title>
    <url>%2Fdocker%2F%E6%8E%A8%E9%80%81%EF%BC%8C%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[提交运行的容器成为镜像1234docker run --name imwltest -h docker -dit -e TZ=Asia/Shanghai debian# docker commit -a=&apos;作者&apos; -m=&apos;备注&apos; 运行时容器ID 新镜像名称docker commit -a=&apos;imwl&apos; -m=&apos;Test&apos; imwltest imwl/test # 默认TAG: latestdocker commit -a=&apos;imwl&apos; -m=&apos;Test&apos; imwltest imwl/test:0.14 1234# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEimwl/test 0.14 69c1c6c58124 About a minute ago 114MBimwl/test latest ad65438d599f 7 minutes ago 114MB Docker Hub 账户 imwl12345678910111213141516docker logindocker push imwl/test:0.14docker push imwl/testdocker tag flasky:latest imwl/flask:latestdocker push imwl/flask:latestdocker run --name flasky -d -p 8000:5000 imwl/flask:latest # -d 后台运行容器，并返回容器ID -p 端口映射（8000宿主机，5000容器端口） # -P 随机端口映射# -e TZ=Asia/Shanghai 指定时区 备份与还原有些机密性，可以通过docker镜像备份和迁移实现12345678910111213141516171819202122232425262728# docker save -o 备份镜像的名称 源镜像名称:tag版本docker save -o imwltest.tar imwl/test:0.14# 当前目录下 会有 imwltest.tar文件# docker imagesREPOSITORY TAG IMAGE ID CREATEDimwl/test 0.14 69c1c6c58124 27 minutes agoimwl/test latest ad65438d599f 32 minutes ago# docker rmi imwl/test:0.14Untagged: imwl/test:0.14Untagged: imwl/test@sha256:97b496724012eee3df3421edb2ab6edcd6115e42b8060c24ba06b51da466e0ddDeleted: sha256:69c1c6c58124c56456a22c92a2e2125c9abc744f6acde379f5039779becbcc29# docker imagesREPOSITORY TAG IMAGE ID CREATEDimwl/test latest ad65438d599f 32 minutes ago## 恢复# docker load -i imwltest.tarLoaded image: imwl/test:0.14# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEimwl/test 0.14 69c1c6c58124 32 minutes ago 114MBimwl/test latest ad65438d599f 37 minutes ago 114MBdebian latest a8797652cfd9 2 weeks ago 114MB 私有仓库Docker私有仓库内部用来存放镜像的仓库，具有更高的保密安全级别 搭建12345678910111213141516171819202122# docker pull registry # 拉取私有仓库镜像# docker run -di --name=myRegistry --restart=always -p 5000:5000 registry # 启动私有仓库容器365d3d60c6741b95bd4c7c1ea7ab0d68f2f3ef62264b2beff3120d77f5c82a88# wget http://207.246.103.127:5000/v2/_catalog # 本机IP地址 207.246.103.127--2020-02-20 15:27:49-- http://207.246.103.127:5000/v2/_catalogConnecting to 207.246.103.127:5000... connected.HTTP request sent, awaiting response... 200 OKLength: 20 [application/json]Saving to: &apos;_catalog&apos;_catalog 100%[=============================================================&gt;] 20 --.-KB/s in 0s2020-02-20 15:27:49 (2.54 MB/s) - &apos;_catalog&apos; saved [20/20]# cat _catalog&#123;&quot;repositories&quot;:[]&#125;## 因为仓库里还没有镜像，所以就是空的；# cd /etc/docker# &quot;insecure-registries&quot;: [&quot;207.246.103.127:5000&quot;] 写入到 daemon.json文件 ## 信任私有仓库# systemctl restart docker # 重启docker 测试标记镜像为私有仓库的镜像docker tag imwl/test 207.246.103.127:5000/debiantest 上传镜像到私有仓库docker push 207.246.103.127:5000/debiantest]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[docker容器间的通信]]></title>
    <url>%2Fdocker%2F%E5%AE%B9%E5%99%A8%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/u013355826/article/details/84987233容器之间通信的主要方式 1.通过容器ip访问 容器重启后，ip会发生变化。通过容器ip访问不是一个好的方案。 2.通过宿主机的ip:port访问 通过宿主机的ip:port访问，只能依靠监听在暴露出的端口的进程来进行有限的通信。 3.通过link建立连接（官方不推荐使用） 运行容器时，指定参数link，使得源容器与被链接的容器可以进行相互通信，并且接受的容器可以获得源容器的一些数据，比如：环境变量。 源容器：mysqldocker run -itd –name test-mysql -e MYSQL_ROOT_PASSWORD=root mysql:5.7 #被链接容器 centosdocker run -itd –name test-centos –link test-mysql:mysql centos /bin/bash #进入test-centosdocker exec -it test-centos /bin/bash直接通过 link的名字或者link时候取的别名就能进入： 通过link建立连接的容器，被链接的容器能 ping 通源容器，反过来不行。 在被链接的容器上查看环境变量 被链接容器会继承源容器的环境变量信息。 与/etc/hosts中的主机条目不同，如果重新启动源容器，则不会自动更新存储在环境变量中的IP地址。我们建议使用主机条目 /etc/hosts来解析链接容器的IP地址。 除了环境变量之外，Docker还将源容器的主机条目添加到/etc/hosts文件中。 如果重新启动源容器，/etc/hosts链接容器上的文件将使用源容器的新IP地址自动更新，从而允许链接通信继续。 4.通过 User-defined networks（推荐） docker network来创建一个桥接网络，在docker run的时候将容器指定到新创建的桥接网络中，这样同一桥接网络中的容器就可以通过互相访问。 创建网络 docker network create test-network启动容器时，加入创建的网络 docker run -it –network test-network –network-alias mysql -e MYSQL_ROOT_PASSWORD=123 mysql:5.7启动被链接的容器 docker run -it –network test-network –network-alias centos centos /bin/bash]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[docker_windos10下]]></title>
    <url>%2Fdocker%2F%E5%9F%BA%E7%A1%80%E7%9F%A5windows10%2Bdocker%2Bwsl%2Bubuntu%2F</url>
    <content type="text"><![CDATA[准备工作安装wsl linux 开启Linux子系统，以管理员权限打开 PowerShell 1234# 启用虚拟机平台Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform# 开启Linux子系统Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 开启开发者模式，WIN + S 搜索 开发者设置，打开后选择 开发者模式 WIN + S 搜索 store， 打开 Microsoft Store（微软应用商店）,eg: 搜索 Ubuntu ，选择 Ubuntu 18.04 LST 进行安装 待安装完成后，从应用中打开 Ubuntu 18.04 LST优化 换源 打开自动切换到root用户 当前用户目录下 vi .bash_profile 添加以下内容12345678910111213141516#.bash_profile# Get the aliases and functionsif [ -f ~/.bashrc ]; then . ~/.bashrcfisudo su - rootPATH=$PATH:$HOME/binexport PATH 修改/etc/sudoers文件 12345678910su - rootchmod u+w /etc/sudoersvi /etc/sudoers # 编辑文件，在root ALL=(ALL)ALL行下添加xxx ALL=(ALL) NOPASSWD: ALL# XXX为用户名。chmod u－w /etc/sudoers # 回到文件的原权限！ 安装docker实际上是在Win10中安装Docker桌面服务，Linux子系统中安装客户端，连接Win10上的Docker服务，进行操作 在Ubuntu子系统中安装Docker123456789101112131415161718192021222324252627282930313233343536373839404142# 更新apt包管理列表sudo apt-get update -y# 安装依赖包sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ gnupg-agent \ software-properties-common# 加入Docker官方PGP公钥curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 确认指纹sudo apt-key fingerprint 0EBFCD88# 将stable（稳定版）Docker加入apt源中## If you want to live on the edge, you can change &quot;stable&quot; below to &quot;test&quot; or# &quot;nightly&quot;. I highly recommend sticking with stable!sudo add-apt-repository \ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable&quot;# 更新apt包管理列表sudo apt-get update -y# 安装Docker CE最新版本sudo apt-get install -y docker-ce# 允许当前用户访问Docker CLI，不必使用rootsudo usermod -aG docker $USER# 此时执行 docker version 会提示如下错误：# Cannot connect to the Docker daemon at unix:///var/run/docker.sock.# 配置Windows Docker服务地址 （Settings =&gt; General =&gt; Expose daemon on tcp://localhost:2375 without TLS）echo &quot;export DOCKER_HOST=localhost:2375&quot; &gt;&gt; ~/.bashrc # 使配置生效. ~/.bashrc powershell其他操作使用管理员模式，打开PowerShell12345启动停止 wsl 服务# 停止子系统服务net stop LxssManager# 启动子系统服务net start LxssManager 备份恢复，导出、导入子系统1234# d:\Ubuntu-18.04.tar 导出文件路径wsl --export Ubuntu-18.04 d:\Ubuntu-18.04.tar# d:\wsl\u18.04 子系统导入后的安装路径wsl --import Ubuntu-18.04 d:\wsl\u18.04 d:\Ubuntu-18.04.tar]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[docker简介]]></title>
    <url>%2Fdocker%2Freadme%2F</url>
    <content type="text"><![CDATA[dockerLinux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离 Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口 Docker 将应用程序与该程序的依赖，打包在一个文件(image)里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样. 容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版） docker 用途 简化环境搭建 简化运维工作量 微服务利器 docker 安装uname -r 内核版本大于 3.10 123456789curl https://get.docker.com &gt; /tmp/install.shchmod +x /tmp/install.sh/tmp/install.shsudo usermod -aG docker rootservice docker restartservice docker statussystemctl enable docker # 开机自启docker info # 获取docker信息docker --help # docker 帮助文档 快速确认docker version 换源vi /etc/docker 目录下找到在daemon.json文件（没有就新建），将下面内容写入(阿里云)123&#123; &quot;registry-mirrors&quot;: [&quot;https://xxxxxxx.mirror.aliyuncs.com&quot;]&#125; 重启daemonsystemctl daemon-reload 重启docker服务systemctl restart docker 第一个镜像1docker run debian echo &quot;hello world&quot; docker run : 启动容器 debian : 使用的镜像名称 （本地如果没有镜像，就在docker hub 进行搜素，并下载最新版） echo “hello world” : 执行的命令 12docker run -i -t debian /bin/bash docker run -i -t debian # 也可以不加 /bin/bash -i -t : 附有一个 tty 的交互会话 -i 支持stdin , -t 终端或伪终端 /bin/bash : 获得一个 bash shell 退出 shell, 容器就会停止, Ctrl+ P + Q 退出而不停止 123456789101112131415161718docker run --name weilai -h docker -it debian /bin/bash # -h 指定hostname --name 指定docker namedocker inspect weilai # 获取 weilai 容器的更多信息doker diff weilai # 查看 weilai 文件的更改docker logs weilai # weilai 容器日志记录docker ps # 正在运行的 docker 容器docker ps -a # 列出所有容器docker ps -n 2 # 显示最近创建的2个容器docker ps -f status=exited # 查看停止的容器docker start weilai # 启动已有容器 docker run 是启动一个新的实例 docker attach weilai # 切换到运行交互式容器docker cp weilai:/tmp /home # 拷贝容器下的/tmp文件夹 到宿主机下的 /home 目录下docker cp /home/test.sh weilai:/tmp/weuilai.sh # 宿主机下的 /home 目录的 tets.sh 到容器下的/tmp文件夹 并改名为weilai.shdocker exec weilai ls -l # 进入容器 执行 ls -l 并回到宿主机，显示结果docker start weilai # 查看容器进程docker stop weilai # 停止容器docker kill weilai # 强制停止（不建议）docker rm weilai # 删除容器docker rmi -f debian # 删除 debian -f 强制删除 docker run ：创建和启动一个新的容器实例，操作对象是镜像，选项较多，如果你要创建和启动一个容器，只能用run；docker exec: 在已运行的容器中，执行命令，操作对象是容器，如果你要进入已运行的容器，并且执行命令，用exec；docker attach: 同样操作的是已运行的容器，可以将本机标准输入（键盘输入）输到容器中，也可以将容器的输出显示在本机的屏幕上，如果你想查看容器运行过程中产生的标准输入输出，用attach； docker 镜像docker images : 列出本机所有镜像123docker images -qa # -a 显示所有镜像（含中间层） -q 只显示镜像iddocker images --digests # 显示镜像的摘要信息docker images --no-trunc # 显示完整的镜像信息 docker search redis : 搜索 redis 镜像docker pull redis:latest : 拉取 redis:latest 镜像 (TAG 默认为 latest 删除多个镜像：docker rmi -f 镜像名称1:[TAG] 镜像名称2:[TAG]中间空格隔开 删除全部镜像：docker rmi -f $(docker images -qa) 同样的 强制删除 docker rm -f 容器ID或name 删除多个容器docker rm -f 容器ID1 容器ID2 删除所有容器 docker rm -f $(docker ps -qa) 容器目录挂载创建容器的时候，将宿主机的目录与容器内的目录进行映射，实现宿主机和容器目录的双向数据自动同步； 相比前面的 cp 更加简单方便 语法docker run -it -v /宿主机目录:/容器目录 镜像名 多目录挂载docker run -it -v /宿主机目录:/容器目录 -v /宿主机目录2:/容器目录2 镜像名 挂载目录制度docker run -it -v /宿主机目录:/容器目录:ro 镜像名 例如安装redis12$ mkdir -p /opt/data/redis$ docker run -p 6379:6379 --name myredis -v /opt/data/redis/redis.conf:/etc/redis/redis.conf -v /opt/data/redis:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes --requirepass &quot;passwd&quot; 注意同步多级目录，可能会出现权限不足的提示；这是因为selinux把权限禁掉了，我们需要添加 –privileged=true 来解决挂载的目录没有权限的问题； docker 网络模式docker 默认使用的是 bridge桥接网络模式 12345# docker network lsNETWORK ID NAME DRIVER SCOPEd2a8ca970a9c bridge bridge locale379fa1c8774 host host local3dfff078ede1 none null local 自定义网络模式 12345678910111213141516171819202122# docker network create --subnet=172.20.0.0/16 extnetworka2c75e5e49ea2bf16380befd73ac19be54e271f4ad1e39549c47290d1b9fa7f3# ifconfigbr-a2c75e5e49ea: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 172.20.0.1 netmask 255.255.0.0 broadcast 172.20.255.255 ether 02:42:43:82:72:6e txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 inet6 fe80::42:d5ff:fe34:51d4 prefixlen 64 scopeid 0x20&lt;link&gt; ether 02:42:d5:34:51:d4 txqueuelen 0 (Ethernet) RX packets 10771 bytes 601704 (587.6 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 10230 bytes 51101359 (48.7 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0......... 创建容器并指定ip --net extnetwork --ip 172.20.0.2 extnetwork 上文指定172.20.0.1 是网关,所以从2 分配 12345678910# docker run -p 8066:8066 -it --net extnetwork --ip 172.20.0.2 debianroot@b4246dddf9f5:/#ip address1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever17: eth0@if18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:14:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.20.0.2/16 brd 172.20.255.255 scope global eth0 valid_lft forever preferred_lft forever 也可以用 docker inspect 容器id 查看信息 12345678910# docker inspect b4246dddf9f5.... &quot;NetworkID&quot;: &quot;a2c75e5e49ea2bf16380befd73ac19be54e271f4ad1e39549c47290d1b9fa7f3&quot;, &quot;EndpointID&quot;: &quot;efa3cd2ed24010ba37bcf7183fba6cce7bc89f9327375f1148db1a6888005d6f&quot;, &quot;Gateway&quot;: &quot;172.20.0.1&quot;, &quot;IPAddress&quot;: &quot;172.20.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;,.... 删除网络docker network rm extnetwork]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[go简介]]></title>
    <url>%2Fgolang%2Freadme%2F</url>
    <content type="text"><![CDATA[简介GO 语言特点 运行效率高，开发高效，部署简单 （可直接编译成机器码，不依赖其他库，glibc的版本有一定要求，部署就是扔一个文件上去就完成了） 语言层面支持并发，易于利用多核实现并发 （最大特点） 内置runtime（作用：性能监控，GC等），支持垃圾回收 丰富标准库，强大网络库 内置强大的工具（gofmt）,跨平台编译，内嵌C支持 GO 语言的应用 服务器编程，以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。 分布式系统，数据库代理器等 网络编程，这一块目前应用最广，包括Web应用、API应用、下载应用、 内存数据库，前一段时间google开发的groupcache，couchbase的部分组建 云平台，目前国外很多云平台在采用Go开发，CloudFoundy的部分组建，前VMare的技术总监自己出来搞的apcera云平台。 GO 语言命令行工具 go build 用于编译源码文件，代码包，依赖包; go run 可以编译并运行Go源码文件 go get 主要用来动态获取远程代码包]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针]]></title>
    <url>%2Fgolang%2F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[变量是一种使用方便的占位符，用于引用计算机内存地址。 Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址 123456789package mainimport &quot;fmt&quot;func main() &#123; var a int = 10 fmt.Printf(&quot;变量的地址: %x\n&quot;, &amp;a )&#125; 指针声明 : var var_name *var-type eg: var fp *float32 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; var a int= 20 /* 声明实际变量 */ var ip *int /* 声明指针变量 */ ip = &amp;a /* 指针变量的存储地址 */ fmt.Printf(&quot;a 变量的地址是: %x\n&quot;, &amp;a ) /* 指针变量的存储地址 */ fmt.Printf(&quot;ip 变量的存储地址: %x\n&quot;, ip ) /* 使用指针访问值 */ fmt.Printf(&quot;*ip 变量的值: %d\n&quot;, *ip )&#125; 空指针 :当一个指针被定义后没有分配到任何变量时，它的值为 nil123456789package mainimport &quot;fmt&quot;func main() &#123; var ptr *int var ptr1 * fmt.Printf(&quot;ptr 的值为 : %x\n&quot;, ptr ) /* 0 */&#125;]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[规范]]></title>
    <url>%2Fgolang%2F%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[变量声明，初始化，赋值 同一行声明多个变量并赋值： var a,b,c int =1,2,3 或者 d,e := 4,5 全局变量声明必须使用var关键字,局部变量可以省略（a,b,c int =1,2,3） 变量 _ 表示丢弃变量类型转换 类型转换必须是显示的，不存在隐式转换 只发生在兼容类型之间 &lt;变量名称&gt; [:]= &lt;目标类型&gt;(&lt;需要转换的变量&gt;)123456789101112131415package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)func main()&#123; var a float32 = 3.1 c := int(a) fmt.Println(c) fmt.Println(reflect.TypeOf(c)) &#125; 变量可见性规则 大写字母开头的变量可导出，其他包可以读取，是共有变量 小写字母开头的变量不可导出，是私有变量 常量常量定义形式常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型 显示 const identifier [type] = value 隐式 const identifier = value (通常叫做 无类型常量) 常量可以使用 内置表达式定义 eg: len(),unsafe.Size0f()等 特殊常量 iota iota 在 const 关键字出现时被重置为 0 const 中每新增一行常量声明 iota 就计数一次 iota 只能在常量中使用 iota 常见使用法： 跳值使用法 插队使用法 表达式隐式使用法 单行使用法]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[迭代对象，迭代器，生成器]]></title>
    <url>%2Fpython%2F%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%8C%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[容器容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用 in , not in 关键字判断元素是否包含在容器中 assert 如果为Fasle, 那么raise一个AssertionError123assert False, &apos;error&apos;assert True, &apos;error&apos;assert 1 in [1, 2, 3, 4],&apos;error&apos; 大多数容器提供了某种方式来获取其中每一个元素,（是可迭代对象赋予了容器这种能力） 可迭代对象 （iterable）凡是可以返回一个迭代器的对象都可以称之为可迭代对象 可迭代对象实现了 iter (返回可迭代对象本身) 和 next 方法，123456789101112x = [1, 2, 3]y = iter(x)z = iter(x) #两个不同的迭代器next(y) next(y)next(z)type(x) # list 可迭代对象type(y) # list_iterator 具体的迭代类型a = &apos;hahaha&apos;b = iter(a)type(b) # str_iterator 迭代器 (iterator)迭代器是一个带状态的对象，能在调用 next() 方法时返回容器的下一个值. 迭代器等有人需要的时候才生成值返回， 没调用的时候， 就处于休眠状态等待下一次调用。 生成器（generator）相比其他容器对象，它更能节省内存和cpu。 12sum(i for i in range(100_000_000)) # 生成器sum[i for i in range(100_000_000)] # 列表推导式 生成器是一种特殊的迭代器，只需要yield关键字。生成器一定是迭代器（反之不成立）。 12345def someting(): result = [] for x in ..: result.append(x) return result 都可以改写123def iter_something(): for x in ..: yield x 生成器表达式（generator expression）列表推导式的生成器版本，但他返回的是一个生成器对象，而不是列表对象1a = (x * x for x in range(10)) 生成器只能遍历一次]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP基本原理]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2FHTTP%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[0. HTTP 的特性HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80 (HTTPS: 443) HTTP 是无连接无状态的 无连接：服务器处理完客户的请求，并收到客户的应答后，即断开连接 （keep-alive :Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接 tcp连接） 无状态：对于事务处理没有记忆能力 (Cookie 客户端， Session 服务端) 1. URL 与 URIURI : 统一资源标识符 URL : 统一资源定位符 (URN : 统一资源名称 只命名资源 而不指定如何定位资源) URL 是 URI 的子集 2. 超文本Hypertext ,用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。 网页源代码 HTML 可以称之为超文本。 3. HTTP HTTPSHTTP : 超文本传输协议，用于从网络传输超文本数据到本地浏览器的传送协议 HTTPS ： 以安全为目标的 HTTP通道。 HTTP over TLS。 建立一个安全信息通道，来保证数据传输的安全。 确认网站的真实性。 4. HTTP 请求过程浏览器（客户端） 输入 URL ,向服务器发送一个 Request (请求), 服务器收到 Request 后，返回对应的一个 Response (响应), Response 中包含页面的源代码等内容，浏览器再进行解析，便将网页呈现出来。 5. RequestRequest 可分为四部分 Request Method (请求方式) Request URL （请求连接） Request Headers （请求头） Request Body （请求体） 5.1 Request Method请求方式，常见有 GET , POST GET 请求参数会直接包含在URL里， （eg:https://www.baidu.com/s?wd=Python wd 就是要搜寻的关键字） POST 一般用于表单提交发起，数据常以 Form Data 即表单形式传输，不会体现在 URL 中。（包含在 Request Body 中） GET 请求提交的数据最多只有1024字节。 其他请求方式 HEAD PUT DELETE CONNECT OPTIONS TRACE 5.2 Request URL请求的网址，即统一资源定位符，可以唯一确定我们想请求的资源 5.3 Request Headers请求头， 用来说明服务器要使用的附加信息，比较重要的有Cookie,Refer,User-Agent等 Accept : 请求报头域，用于指定客户端可接受的语言类型 Accept-Language : 指定客户端可接受的语言类型 Accept-Encoding : 指定客户端可接受的内容编码 HOST : 用于指定请求资源的主机和端口号 Cookie : 是网站为了辨别用户进行 Session 跟踪而储存在用户本地的数据。 Referer : 用来标识这个请求是从哪个页面发出来的 User-Agent : UA,特殊的字符串头，使得服务器能够识别客户使用的操作系统及版本、浏览器及版本等信息。（爬虫时可加次信息伪装成浏览器） Content-type : 互联网媒体类型，在 HTTP 协议消息中，使用它来表示具体请求中的媒体类型信息。（Application/josn ,image/gif, text/html等） 5.4 Request Body一般承载的内容为 POST 请求中的Form Data , 而对于 GET 请求 Request Body 则为空。 6. Response由服务端返回给客服端。Response可以分为三部分 Request Status Code (响应状态码) Response Headers （响应头） Response Body （响应体） 6.1 Request Status Code200 表示正常。 404 表示页面未找到。 500 表示服务器内部异常。 一般情况下 2开头 （请求成功）表示成功处理了请求的状态代码。 3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 6.2 Response Headers包含了服务器对请求的应答信息 部分信息 date : 标识 Response 产生的时间 Last-Modified : 指定资源的最后修改时间 Content-Encoding ：指定 Response 内容的编码 Server : 包含了服务器的信息 Content-type ： 同Request Set-Cookie : 设置Cookie, 即告诉浏览器需要将此内容放到Cookies中，下次请求携带Cookies请求。 Expires : 指定 Response 的过期时间，使用它可以控制代理服务器或浏览器将内容更新到缓存中，如再次访问，直接从缓存中加载，降低服务器荷载，缩短加载时间。 6.3 Response Body响应的正文数据都是在响应体中（爬虫请求网页后要解析的数据就是解析响应体） 在浏览器开发工具中点击Preview,就可以看到网页源代码、json数据等，然后从中做相应内容的提取]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python 浅拷贝与深拷贝]]></title>
    <url>%2Fpython%2FDesignPattern%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2Fpython%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[python 浅拷贝与深拷贝python的引用计数 int float str tuple 为不可变对象 list dict set 为可变对象 python 内不可变对象的内存管理方式是引用计数，python 不会对值相同的不可变对象，申请单独的内存空间。只会记录它的引用次数。12345678910import copya = &apos;weilai&apos;b = ac = copy.copy(a)if id(a) == id(b) == id(c): print(f&apos;all id is &#123;id(a)&#125;&apos;)else: print(f&apos;id(a) is &#123;id(a)&#125;&apos;) print(f&apos;id(b) is &#123;id(b)&#125;&apos;) print(f&apos;id(c) is &#123;id(c)&#125;&apos;) 浅拷贝浅拷贝会创建一个新的对象，对于对象中的元素，他依然会引用原来的物体123456789101112131415import copy a = [&apos;weilai&apos;, &apos;handsome&apos;]b = ac = copy.copy(a)if id(a) == id(b) == id(c): print(f&apos;all id is &#123;id(a)&#125;&apos;)else: print(f&apos;id(a) is &#123;id(a)&#125;&apos;) print(f&apos;id(b) is &#123;id(b)&#125;&apos;) print(f&apos;id(c) is &#123;id(c)&#125;&apos;) # c创建了一个新对象，指向原来的 aa.append(&apos;cool&apos;)print(a)print(b)print(c) # c 还是[&apos;weilai&apos;, &apos;handsome&apos;] 由于浅拷贝会使用原始元素的引用（内存地址），所以在操作对象内部的可变元素时，其结果是会影响到拷贝对象的 123456789import copy a = [[1, 2, 3], 3, 4]b = ac = copy.copy(a) # [[1, 2, 3], 3, 4]a[0][0] = &apos;a&apos; a[1] = &apos;b&apos;print(a) # [[&apos;a&apos;, 2, 3], &apos;b&apos;, 4]print(b) # [[&apos;a&apos;, 2, 3], &apos;b&apos;, 4]print(c) # [[&apos;a&apos;, 2, 3], 3, 4] 深拷贝**深拷贝遇到可变对象，则又会进行一层对象的创建，操作被考对象内部的可变对象，不影响拷贝对象内部的值。123456789import copy a = [[1, 2, 3], 3, 4]b = ac = copy.deepcopy(a) # [[1, 2, 3], 3, 4]a[0][0] = &apos;a&apos; a[1] = &apos;b&apos;print(a) # [[&apos;a&apos;, 2, 3], &apos;b&apos;, 4]print(b) # [[&apos;a&apos;, 2, 3], &apos;b&apos;, 4]print(c) # [[1, 2, 3], 3, 4] 总结python变量实际上是指向相关值在内存中存储位置的指针 。 深浅拷贝都是对源对象的复制，占用不同的内存空间 如果源对象只有一级目录的话，源对象做任何改动，不影响深浅拷贝对象 如果源对象不止一级目录的话，源对象做任何改动，都要影响浅拷贝，但不影响深拷贝 序列对象的切片其实是浅拷贝，即只拷贝顶级的对象]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2Fpython%2FDesignPattern%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2Freadme%2F</url>
    <content type="text"><![CDATA[在原型模式中，优先使用组合而非继承。组成的类使我们可以在运行时替换那些组成部分，从而彻底改善系统的可测试性和可维护性。 原型模式在一般情况下的样子声明一个抽象基类 prototype_1.py123456from abc import ABCMeta, abstractmethodclass Prototype(metaclass=ABCMeta): @abstractmethod def clone(self): pass 调用 concrete.py123456from prototype_1 import Prototypefrom copy import deepcopyclass Concrete(Prototype): def clone(self): return deepcopy(self) **扩展该抽象基类时，会强制实现clone方法。]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2Fpython%2FDesignPattern%2F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2Freadme%2F</url>
    <content type="text"><![CDATA[建造者模式，将复杂对象的构造从其表示形式中分离了出来，因此可用相同的构造过程来创建不同形式的表单。 其最大的缺点在于，我们要为希望创建的每一种产品类型创建ConcreteBuilder建造者 原始代码12345678910111213141516def generator_webform(text_field_list=[],checkbox_field_list=[]): generator_fields = &quot;\n&quot;.join(map(lambda x:&apos;&#123;0&#125;：&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;&#123;0&#125;&quot;&gt; &lt;br&gt;&apos;.format(x),text_field_list)) generator_fields += &quot;\n&quot;.join(map(lambda x:&apos;&lt;label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;&#123;0&#125;&quot; value=&#123;0&#125;&gt;&#123;0&#125; &lt;br&gt;&apos;.format(x),checkbox_field_list)) return &quot;&lt;form&gt;&#123;fields&#125;&lt;/form&gt;&quot;.format(fields=generator_fields)def build_html_form(text_field_list=[],checkbox_field_list=[]): with open(&apos;form_file.html&apos;,&apos;w&apos;) as f : f.write(&apos;&lt;html&gt;&lt;body&gt;&#123;&#125;&lt;/body&gt;&lt;/html&gt;&apos;.format(generator_webform(text_field_list=text_fields,checkbox_field_list=checkbox_fields)))if __name__ == &quot;__main__&quot;: text_fields = [&quot;name&quot;,&quot;age&quot;,&quot;email&quot;,&quot;telephone&quot;] checkbox_fields = [&apos;awesome&apos; , &apos;bad&apos;] print(generator_webform(text_field_list=text_fields,checkbox_field_list=checkbox_fields)) build_html_form(text_field_list=text_fields,checkbox_field_list=checkbox_fields) 改造后123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107from abc import ABCMeta, abstractmethodclass Director(object, metaclass=ABCMeta): def __init__(self): self._builder =None def set_build(self, builder): self._builder = builder @abstractmethod def construct(self, field_list): pass def get_constructed_object(self): return self._builder.constructed_objectclass AbstractFormBuilder(object,metaclass=ABCMeta): def __init__(self): self.constructed_object = None @abstractmethod # 定义一个抽象基类 def add_checkbox(self, checkbox_dict): pass @abstractmethod def add_text_field_dict(self,field_dict): pass @abstractmethod def add_button(self, button_dict): passclass HtmlForm(object): def __init__(self): self.field_list = [] def __repr__(self): return &apos;&lt;form&gt;&#123;&#125;&lt;/form&gt;&apos;.format(&apos;&apos;.join(self.field_list))class HtmlFormBuilder(AbstractFormBuilder): def __init__(self): self.constructed_object =HtmlForm() def add_text_field(self, field_dict): self.constructed_object.filed_list.append( &apos;&#123;0&#125;:&lt;br&gt;&lt;input type=&quot;text&quot; name=&quot;&#123;1&#125;&quot;&gt;&lt;br&gt;&apos;.format(field_dict[&apos;label&apos;], field_dict[&apos;field_name&apos;])) def add_checkbox(self, checkbox_dict): self.constructed_object.filed_list.append( &apos;&lt;label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;&#123;0&#125;&quot; value = &quot;&#123;1&#125;&quot;&gt; &#123;2&#125;&lt;br&gt;&apos;.format(&apos;field_id&apos;, checkbox_dict[&apos;value&apos;], checkbox_dict[&apos;label&apos;])) def add_button(self, button_dict): self.constructed_object.filed_list.append( &apos;&lt;button type=&quot;button&quot;&gt; &#123;&#125; &lt;/button&gt;&apos;.format(button_dict[&apos;text&apos;]))class FormDirector(Director): def __init__(self): Director.__init__(self) def construct(self, field_list): for field in field_list: if field[&quot;field_type&quot;] == &apos;text_field&apos;: self._builder.add_text_field(field) elif field[&quot;field_type&quot;] == &apos;checkbox&apos;: self._builder.add_check(field) elif field[&quot;field_type&quot;] == &apos;button&apos;: self._builder.add_button(field)if __name__ == &apos;__main__&apos;: director = FormDirector() html_form_builder = HtmlFormBuilder() director.set_build(html_form_builder) field_list = [ &#123; &apos;field_type&apos; : &apos;text_field&apos;, &apos;label&apos; : &apos;Best text you have ever writen&apos;, &apos;field_name&apos; : &apos;Field One&apos; &#125;, &#123; &apos;field_type&apos;: &apos;checkbox&apos;, &apos;field_id&apos; : &apos;check_it&apos;, &apos;label&apos;: &apos;check for on&apos;, &apos;value&apos;: &apos;1&apos; &#125;, &#123; &apos;field_type&apos;: &apos;text_field&apos;, &apos;label&apos;: &apos;another text you have ever writen&apos;, &apos;field_name&apos;: &apos;Field One&apos; &#125;, &#123; &apos;field_type&apos; : &apos;button&apos;, &apos;text&apos; : &apos;Done&apos; &#125; ] director.construct(field_list) with open(&apos;form_file.html&apos;, &apos;w&apos;) as f: f.write( &apos;&lt;html&gt;&lt;body&gt;&#123;0!r&#125;&lt;/body&gt;&lt;/html&gt;&apos;.format( director.get_constructed_object() ) )]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2Fpython%2FDesignPattern%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2Freadme%2F</url>
    <content type="text"><![CDATA[当希望通过一个通用接口来创建对象，而不是让创建代码分散在整个系统中 创建一个集中式的系统来进行对象创建的一种方式就是使用工厂模式 原型模式不需要子类化，不过需要一个初始化操作，而工厂模式需要子类化，但不需要初始化 工厂模式一个简单的实现原始代码123456789101112131415161718192021222324import pygamewindows_dimensions = 800,600screen = pygame.display.set_mode(windows_dimensions)x,y = 100, 100player_quits = Falsewhile not player_quits: for event in pygame.event.get(): if event.type == pygame.QUIT: player_quits = True pressed = pygame.key.get_pressed() if pressed[pygame.K_UP]: y -=4 if pressed[pygame.K_DOWN]: y += 4 if pressed[pygame.K_LEFT]: x -= 4 if pressed[pygame.K_RIGHT]: x += 4 screen.fill((0, 0, 0)) pygame.draw.rect(screen,(255, 255, 0 ), pygame.Rect(x, y, 20, 20)) pygame.display.flip() 改写，方便扩展 shape_factory.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import pygameimport time# pygame.init()class Shape(): def __init__(self,x ,y): self.x = x self.y = y def draw(self): raise NotImplementedError() def move(self, direction): if direction == &apos;up&apos;: self.y -= 4 if direction == &apos;down&apos;: self.y += 4 if direction == &apos;left&apos;: self.x -= 4 if direction == &apos;right&apos;: self.x += 4 @staticmethod def factory(type): # 工厂模式,可在这里加type类型 if type == &apos;Circle&apos;: return Circle(100, 100) if type == &apos;Square&apos;: return Square(100, 100) assert 0, &apos;Bad shape requested: &apos; + typeclass Square(Shape): def draw(self): pygame.draw.rect(screen,(255, 255, 0 ), pygame.Rect(self.x, self.y, 20, 20))class Circle(Shape): def draw(self): pygame.draw.circle(screen, (0, 255, 255), (self.x, self.y),10)if __name__ == &apos;__main__&apos;: windows_dimensions = 800,600 screen = pygame.display.set_mode(windows_dimensions) obj = Shape.factory(&apos;Circle&apos;) player_quits = False while not player_quits: for event in pygame.event.get(): if event.type == pygame.QUIT: player_quits = True pressed = pygame.key.get_pressed() if pressed[pygame.K_UP]: obj.move(&apos;up&apos;) if pressed[pygame.K_DOWN]: obj.move(&apos;down&apos;) if pressed[pygame.K_LEFT]: obj.move(&apos;left&apos;) if pressed[pygame.K_RIGHT]: obj.move(&apos;right&apos;) screen.fill((0, 0, 0)) obj.draw() pygame.display.flip() 抽象工厂当希望创建单个接口来访问整个工厂集合时，可以使用一个抽象工厂12345678910111213141516171819202122232425262728import abcclass AbstractFactory(): # 抽象工厂会定义这些具体工厂的结构，之后这些具体工厂会创建本例中的原型和正方形 __metaclass__ = abc.ABCMeta @abc.abstractmethod def make_object(self): returnclass CircleFactory(AbstractFactory): def make_object(self): # do something return Circle()class SquareFactory(AbstractFactory): def make_object(self): # do something return Square()def draw_function(factory): drawable = factory.make_object() drawable.draw()def prepare_client(): squareFactory = SquareFactory() draw_function(squareFactory) circleFactory = CircleFactory() draw_function(circleFactory)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2Fpython%2FDesignPattern%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2Freadme%2F</url>
    <content type="text"><![CDATA[适配器模式具有以下要素： 目标 –定义客户端所使用的特定于 领域的接口 客户端 – 使用遵从于 目标接口的对象 适配者类 –由于对象不遵从目标而必须修改的接口 适配器 – 将适配者类中所具有的接口 修改为我们想要在客户端中 使用的接口的代码 1.定义我们希望适应的组成部分是什么2.识别出客户端需要的接口3.设计和实现适配器以便将客户端所需的接口映射到适配者类所提供的接口 客户端从适配者类中解耦出来并且被耦合到接口，这样实现了可扩展性和可维护性 不要重复自己 面向接口 而非 面向现实进行编程 支持对象组合，而非继承 关注点分离将系统分割为 单独单元 并让每个单元尤其自己的关注点。单元彼此越独立，系统的维护和扩展也会变的越容易。 1234567class ObjectAdapter(object): def __init__(self, what_i_have, provided_function): self.what_i_have = what_i_have self.required_function = provided_function def __getattr__(self, attr): return getatrr(self.what_i_have, attr)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络请求]]></title>
    <url>%2Fpython%2F%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[url 与 ipip : Internet Protocol 如果 ‘域名-ip’ 已被记录，则直接访问目标ip浏览器缓存，系统缓存，路由缓存 没有被记录，则 依靠 DNSDNS : Domain Name System 是一个将域名和 IP 相互映射的分布式数据库。 网卡上，有 ‘DNS 服务器’ 配置项 DNS 劫持访问 A 结果 访问了 B DNS 投毒(污染)从客户端 向 DNS 服务器发出 查询IP 的请求，到响应 返回到客户端 的这段时间，被伪造返回来一个 错误的DNS应答，那么访问不到真正的资源 DNS 正常解析返回正常的 ip 地址]]></content>
      <categories>
        <category>flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多线程的鸡肋]]></title>
    <url>%2Fpython%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%B8%A1%E8%82%8B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536from contextlib import contextmanagerimport time## 因为GIL锁的原因，多线程并没有多少用## 不适合计算密集型@contextmanagerdef _cost_time(): start_time = time.time() print(&apos;start time : &apos; + time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())) yield end_time = time.time() seconds = end_time - start_time m, s = divmod(seconds, 60) h, m = divmod(m, 60) print(&apos;end time : &apos; + time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())) print(&apos;time cost %d:%02d:%02d &apos; % (h, m, s))def decrement(n): while n &gt; 0: n -= 1# Single threadwith _cost_time(): decrement(100000000)#import threadingwith _cost_time(): t1 = threading.Thread(target=decrement,args=[50000000]) t2 = threading.Thread(target=decrement,args=[50000000]) t1.start() t2.start() t1.join() t2.join() 修改一下123456789101112131415161718192021222324252627282930313233343536import time## 因为GIL锁的原因，多线程并没有多少用## 不适合计算密集型def _cost_time(func): def warpper(*args,**kw): start_time = time.time() print(&apos;start time : &apos; + time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())) func(*args,**kw) end_time = time.time() seconds = end_time - start_time m, s = divmod(seconds, 60) h, m = divmod(m, 60) print(&apos;end time : &apos; + time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())) print(&apos;time cost %d:%02d:%02d &apos; % (h, m, s)) return warpper@_cost_timedef decrement(n): while n &gt; 0: n -= 1# Single threaddecrement(100000000)# Multithreadingimport threadingt1 = threading.Thread(target=decrement,args=[50000000])t2 = threading.Thread(target=decrement,args=[50000000])t1.start()t2.start()t1.join()t2.join()]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[优雅的python写法]]></title>
    <url>%2Fpython%2F%E4%BC%98%E9%9B%85%E7%9A%84python%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[学习python cook book 有感1. 交换变量1a, b = b, a 2. 循环遍历区间1234for i in range(6): print (i)``` ## 3. 带有索引位置的集合遍历 for i, color in enumerate(colors): print (i ,colors[i])1## 4. 字符串拼接 print ‘. ‘ .join(names)‘’’join 方法全程只会产生一个字符串对象，而每执行一次 + 操作，就会在内存中生成一个新的字符串对象‘’’12现在已经可以直接使用加号，不会影响效率。（不要被落后的经验给拖累了）## 5. 打开/关闭文件 with open (‘xxx.xxx’,’r’) as f: data = f.read()1## 6. 列表推导式 [i for i in range(10)]1## 7. 善用装饰器 ‘’’装饰器可以吧与业务逻辑无关的代码抽离出来，让代码保持干净清爽，且能多次利用url 曾使用过直接从cache读出，没有的话存到saved中‘’’import urllib.request as urllib def cache(func): saved = {} def wrapper(url): if url in saved: return saved[url] else: page = func(url) saved[url] = page return page return wrapper @cachedef web_lookup(url): return urllib.urlopen(url).read()1## 8. 合理使用列表 ‘’’list是一个查询效率高于更新操作的数据结构,删除/插入 一个元素 执行的效率较低，因为还要对剩下的元素进行移动‘’’from collections import dequenames = deque([1, 2, 3, 4, ‘haha’])names.popleft()names.appendleft(‘mark’) ‘’’deque 是一个双向队列的数据结构，删除元素和插入元素会很快‘’’1## 9. 序列解包 p = ‘1’ , ‘2’ , ‘3’ , 4a, b, c, d, = p12## 10. 遍历字典的 key 和 value dict ={1:’haha’,2:’xixi’}for key, value in dict.items(): print(key ,’ + ‘, value)‘’’dict.items 返回迭代器对象，可节省更多的内存‘’’1## 11. 链式比较操作 age = 18if 18 &lt; age &lt; 60: print(‘young man’) False == True == True == True False1## 12. if/else text = ‘男’ if gender == ‘male’ else ‘女’1## 13. True/Fales 值判断 if a: do_someting()if b: do_someting()‘’’a,b 的值有就是True, 没有就是False‘’’1## 14. 字符串格式化 a,b = ‘haha’, [1,2,3]s = f’str is {a}, list is {b}’‘’’不支持python2‘’’1## 15. 列表切片 items = range(10)sub_items = items[1:4] # 取第1号到第4号元素odd_items = items[1::2] # 第1号到最后面，步长为2 （奇数）copy_items = items[::] # 或者 items[:]1## 16. 善用生成器 def fib(n): a, b = 0, 1 while a &lt; n: yeild a a ,b = b, a + b‘’’生成器的好处是无需一次性把所有元素加载到内存，只有迭代获取元素时才返回该元素，而列表是预先一次性把全部元素加载到内存中遇到 yield 会暂停执行另一个函数‘’’1# 17. 获取字典元素 d = {‘name’:’foo’}d.get(‘name’,’unknow’)d.get(‘age’,’unknow’)1# 18. 预设字典默认值 groups = {}for (key, value) in data: groups.setdefault(key, []).append(value) from collections import defaultdictgroups = defaultdict(list)for (key, value) in data: groups[key].append(value)12## 19 字典/列表/集合 推导式 numbers = [1, 2, 3, 4]my_dict = {number: number*2 for number in numbers}print(my_dict)12345## 20. for/else&apos;&apos;&apos;python 特有的语法格式，else中的代码在for 循环完所有元素成后执行&apos;&apos;&apos; flagfound = Falsemylist = [1, 2, 3, ‘theflag’, 4, 5, 6]for i in mylist: if i == ‘theflag’: flagfound = True break print(i)else: raisd ValueError(‘list argument missing terminal flag’)12## 21 一些特性### 给数字加\_分组并不影响实际 a = 11_22_33_44error = 0xbad_c0ffee1### 将类型注释添加到函数和方法中 def my_add(a:str,b:int) -&gt; str: return a + bmy_add(1,2)1### 直接操作数字 PI =3.141592653f’PI is {PI:.4f}’`]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python列表操作]]></title>
    <url>%2Fpython%2Fpython%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1、迭代列表，如何访问列表下标索引普通版：12345678items = [8, 23, 45]for index in range(len(items)): print(index, &quot;--&gt;&quot;, items[index])&gt;&gt;&gt;0 --&gt; 81 --&gt; 232 --&gt; 45 优雅版：1234567for index, item in enumerate(items): print(index, &quot;--&gt;&quot;, item)&gt;&gt;&gt;0 --&gt; 81 --&gt; 232 --&gt; 45 enumerate 还可以指定元素的第一个元素从几开始，默认是0，也可以指定从1开始：1234567for index, item in enumerate(items, start=1): print(index, &quot;--&gt;&quot;, item)&gt;&gt;&gt;1 --&gt; 82 --&gt; 233 --&gt; 45 2、append 与 extend 方法有什么区别append表示把某个数据当做新元素追加到列表的最后面，它的参数可以是任意对象1234567x = [1, 2, 3]y = [4, 5]x.append(y)print(x)&gt;&gt;&gt;[1, 2, 3, [4, 5]] extend 的参数必须是一个可迭代对象，表示把该对象里面的所有元素逐个地追加到列表的后面1234567891011x = [1, 2, 3]y = [4, 5]x.extend(y)print(x)&gt;&gt;&gt;[1, 2, 3, 4, 5]# 等价于：for i in y: x.append(i) 3、检查列表是否为空普通版：12if len(items) == 0: print(&quot;空列表&quot;) 或者12if items == []: print(&quot;空列表&quot;) 优雅版：12if not items: print(&quot;空列表&quot;) 4、如何理解切片切片用于获取列表中指定范围的子集，语法非常简单 items[start:end:step] 从 start 到 end-1 位置之间的元素。step 表示步长，默认为1，表示连续获取，如果 step为2 就表示每隔一个元素获取。12345678910111213141516a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; a[3:8] # 第3到第8位置之间的元素[4, 5, 6, 7, 8]&gt;&gt;&gt; a[3:8:2] # 第3到第8位置之间的元素，每隔一个元素获取[4, 6, 8]&gt;&gt;&gt; a[:5] # 省略start表示从第0个元素开始[1, 2, 3, 4, 5]&gt;&gt;&gt; a[3:] # 省略end表示到最后一个元素[4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; a[::] # 都省略相当于拷贝一个列表，这种拷贝属于浅拷贝[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 5、如何拷贝一个列表对象第一种方法：1new_list = old_list[:] 第二种方法：1new_list = list(old_list) 第三种方法：12345import copy# 浅拷贝new_list = copy.copy(old_list)# 深拷贝new_list = copy.deepcopy(old_list) 6、如何获取列表中的最后一个元素索引列表中的元素不仅支持正数还支持负数，正数表示从列表的左边开始索引，负数表示从列表的右边开始索引，获取最后一个元素有两种方法。12345&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; a[len(a)-1]10&gt;&gt;&gt; a[-1]10 7、如何对列表进行排序列表排序有两种方式，一种是列表自带的方法 list.sort()，一种是内建函数 sorted(list)。复杂的数据类型可通过指定 key参数进行排序。由字典构成的列表，根据字典元素中的age字段进行排序： 12345678910items = [&#123;&apos;name&apos;: &apos;Homer&apos;, &apos;age&apos;: 39&#125;, &#123;&apos;name&apos;: &apos;Bart&apos;, &apos;age&apos;: 10&#125;, &#123;&quot;name&quot;: &apos;cater&apos;, &apos;age&apos;: 20&#125;]items.sort(key=lambda item: item.get(&quot;age&quot;))print(items)&gt;&gt;&gt;[&#123;&apos;age&apos;: 10, &apos;name&apos;: &apos;Bart&apos;&#125;, &#123;&apos;age&apos;: 20, &apos;name&apos;: &apos;cater&apos;&#125;, &#123;&apos;age&apos;: 39, &apos;name&apos;: &apos;Homer&apos;&#125;] 列表有sort方法，用于对原列表进行重新排序，指定key 参数，key是匿名函数，item是列表中的字典元素，我们根据字典中的age进行排序，默认是按升序排列，指定reverse=True 按降序排列1234items.sort(key=lambda item: item.get(&quot;age&quot;), reverse=True)&gt;&gt;&gt;[&#123;&apos;name&apos;: &apos;Homer&apos;, &apos;age&apos;: 39&#125;, &#123;&apos;name&apos;: &apos;cater&apos;, &apos;age&apos;: 20&#125;, &#123;&apos;name&apos;: &apos;Bart&apos;, &apos;age&apos;: 10&#125;] 如果不希望改变原列表，而是生成一个新的有序列表对象，那么可以内置函数 sorted，该函数返回新列表12345678910111213items = [&#123;&apos;name&apos;: &apos;Homer&apos;, &apos;age&apos;: 39&#125;, &#123;&apos;name&apos;: &apos;Bart&apos;, &apos;age&apos;: 10&#125;, &#123;&quot;name&quot;: &apos;cater&apos;, &apos;age&apos;: 20&#125;]new_items = sorted(items, key=lambda item: item.get(&quot;age&quot;))print(items)&gt;&gt;&gt;[&#123;&apos;name&apos;: &apos;Homer&apos;, &apos;age&apos;: 39&#125;, &#123;&apos;name&apos;: &apos;Bart&apos;, &apos;age&apos;: 10&#125;, &#123;&apos;name&apos;: &apos;cater&apos;, &apos;age&apos;: 20&#125;]print(new_items)&gt;&gt;&gt;[&#123;&apos;name&apos;: &apos;Bart&apos;, &apos;age&apos;: 10&#125;, &#123;&apos;name&apos;: &apos;cater&apos;, &apos;age&apos;: 20&#125;, &#123;&apos;name&apos;: &apos;Homer&apos;, &apos;age&apos;: 39&#125;] 8、如何移除列表中的元素删除列表中的元素有三种方式 remove 移除某个元素，而且只能移除第一次出现的元素1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; a = [0, 2, 2, 3]&gt;&gt;&gt; a.remove(2)&gt;&gt;&gt; a[0, 2, 3]# 如果要移除的元素不在列表中，则抛出 ValueError 异常&gt;&gt;&gt; a.remove(7)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: list.remove(x): x not in list·del指令：根据指定的位置移除某元素&gt;&gt;&gt; a = [3, 2, 2, 1]# 移除第一个元素&gt;&gt;&gt; del a[1][3, 2, 1]# 当超出列表的下表索引时，抛出IndexError的异常&gt;&gt;&gt; del a[7]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list assignment index out of rangepop函数 与del 类似，但是 pop 函数可以返回移除的元素&gt;&gt;&gt; a = [4, 3, 5]&gt;&gt;&gt; a.pop(1)3&gt;&gt;&gt; a[4, 5]# 同样，当超出列表的下表索引时，抛出IndexError的异常&gt;&gt;&gt; a.pop(7)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: pop index out of range 9、如何连接两个列表12345678listone = [1, 2, 3]listtwo = [4, 5, 6]mergedlist = listone + listtwoprint(mergelist)&gt;&gt;&gt;[1, 2, 3, 4, 5, 6] 列表实现了 + 的运算符重载，使得 + 不仅支持数值相加，还支持两个列表相加，只要你实现了 对象的__add__操作，任何对象都可以实现 + 操作，例如：1234567891011121314151617181920class User(object): def __init__(self, age): self.age = age def __repr__(self): return &apos;User(%d)&apos; % self.age def __add__(self, other): age = self.age + other.age return User(age)user_a = User(10)user_b = User(20)c = user_a + user_bprint(c)&gt;&gt;&gt;User(30) 10、如何随机获取列表中的某个元素123456789import randomitems = [8, 23, 45, 12, 78]&gt;&gt;&gt; random.choice(items)78&gt;&gt;&gt; random.choice(items)45&gt;&gt;&gt; random.choice(items)12 转载]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python的日志模块]]></title>
    <url>%2Fpython%2Fpython%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[日志概述 日志会记录下操作，运行的一些相关内容 查看日志是获取信息，排查异常，发现问题的最好途径 日志可在控制台显示，也可以记录到文件中，或者同时输出 日志级别 一般指的是： DEBUG, INFO, WARNING, ERROR, CRITICAL 等严重等级进行划分 python 的 logging 提供了一组便利的日志函数，分别是： debug(), info(), warning(), error(), critical()。 12345DEBUG : 详细信息一般只在调试问题时使用INFO : 事情按预期进行WARNNING : 某些没有预料到的事件提示，或者将来可能出现问题的提示。ERROR : 更严重的问题，软件的一部分功能已不能被执行CRITICAL ： 严重错误，表明软件不能继续运行 logging 的四大组件123456日志器 Logger 提供了应用程序一直使用的接口处理器 Handler 将 logger 创建的日志记录发送到合适的目的输出过滤器 Filter 提供更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录格式器 Formatter 决定日志记录的最终输出格式logger 是入口，真正工作的是 handler, handler 还可以通过 filter 和 formatter 对要输出的日志内容做过滤和格式化处理 日志输出输出到控制台python 中日志的默认等级是 WARNING, DEBUG 和 INFO 级别的日志不会得到显示。12345import logginglogging.info(&apos;info message&apos;)logging.warning(&apos;warning message&apos;)logging.error(&apos;error message&apos;) logging 提供 basciConfig 让使用者可以适时调整默认日志级别1234567import logginglogging.basicConfig(level=logging.DEBUG)logging.info(&apos;info message&apos;)logging.warning(&apos;warning message&apos;)logging.error(&apos;error message&apos;) 输出到文件在 basciConfig 中填写 filename(日志名) ,filemode(写入方式)123456789import logginglogging.basicConfig(level=logging.DEBUG, filename=&apos;test.log&apos;, filemode=&apos;a&apos;)logging.info(&apos;info message&apos;)logging.warning(&apos;warning message&apos;)logging.error(&apos;error message&apos;) 同时输出到文件及控制器对比1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import osimport loggingimport uuidfrom logging import Handler, FileHandler, StreamHandlerclass PathFileHandler(FileHandler): def __init__(self, path, filename, mode = &apos;a&apos;, encoding = None, delay = False): filename = os.fspath(filename) if not os.path.exists(path): os.mkdir(path) self.baseFilename = os.path.join(path, filename) self.mode = mode self.encoding = encoding self.delay =delay if delay: Handler.__init__(self) self.stream = None else: StreamHandler.__init__(self, self._open())class Loggers(): level_relations = &#123; &apos;debug&apos; : logging.DEBUG, &apos;info&apos; : logging.INFO, &apos;warning&apos; : logging.WARNING, &apos;error&apos; : logging.ERROR, &apos;critical&apos; : logging.CRITICAL &#125; uid = uuid.uuid4() def __init__(self, filename = f&apos;&#123;uid&#125;.log&apos;, level = &apos;info&apos;, log_dir = &apos;log&apos;, fmt = &quot;[%(asctime)s] [%(levelname)8s] %(message)s&quot; ): self.logger =logging.getLogger(filename) abspath = os.path.dirname(os.path.abspath(__file__)) self.directory = os.path.join(abspath, log_dir) format_str = logging.Formatter(fmt) self.logger.setLevel(self.level_relations.get(level)) stream_handler = logging.StreamHandler() stream_handler.setFormatter(format_str) file_handler = PathFileHandler(path=self.directory, filename=filename, mode=&apos;a&apos;) file_handler.setFormatter(format_str) self.logger.addHandler(stream_handler) self.logger.addHandler(file_handler)if __name__ == &apos;__main__&apos;: text = &apos;hahaha&apos; log = Loggers(level=&apos;debug&apos;) log.logger.info(4) log.logger.info(5) log.logger.info(text)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[时间格式]]></title>
    <url>%2Fpython%2F%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[mysql 中的时间格式 TIME [3 bytes] : [HH:MM:SS] [-838:59:59 ~ + 838:59:59] DATE [3 bytes] : [YYYY-MM-DD] [1000-01-01 ~ 9999-12-31] DATETIME [8 bytes] : [YYYY-MM-DD HH:MM:SS] [1000-01-01 00:00:00 ~ 9999-12-31 23:59:59] TIMESTAMP [4 bytes] : [1970-01-01 00:00:01 ~ 2038-01-19 03:14:07] YEAR [1 bytes] : [YYYY] [1901 ~ 2155] 常用的是 DATE, DATETIME, 和时间戳 TIMESTAMP python中的 time 时间模块 time 基本时间日期模块 datetime 日历模块 Calendar (用的较少) 1234import time， datetimetimestamp = time.time()print(timestamp,type(timestamp)) # 1563432562.7813718 &lt;class &apos;float&apos;&gt; 获取当前时间戳，数据类型print(datetime.datetime.now()) # 2019-07-18 14:51:57.888187]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[鸭子类型]]></title>
    <url>%2Fpython%2F%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324class Duck: @classmethod def fly(cls): print(&quot;Duck flying&quot;) class Airplane: @staticmethod def fly(): print(&quot;Airplane flying&quot;) class Bird: def fly(self): print(&apos;Bird is flying&apos;) def lift_off(entity): entity.fly() if __name__ == &quot;__main__&quot;: lift_off(Duck) lift_off(Airplane) bird = Bird() lift_off(bird)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cookbook有感]]></title>
    <url>%2Fpython%2Fcookbook%2Frecord%2F</url>
    <content type="text"><![CDATA[解压可迭代对象赋值给多个变量12items = [1, 10, 7, 4, 5, (1,2,3)]head,*tail,(*_,end) =items 保留最后 N 个元素12345678910111213from collections import deque &gt;&gt;&gt; q = deque(maxlen=3) &gt;&gt;&gt; q.append(1) &gt;&gt;&gt; q.append(2) &gt;&gt;&gt; q.append(3) &gt;&gt;&gt; q deque([1, 2, 3], maxlen=3) &gt;&gt;&gt; q.append(4) &gt;&gt;&gt; q deque([2, 3, 4], maxlen=3) &gt;&gt;&gt; q.append(5) &gt;&gt;&gt; q deque([3, 4, 5], maxlen=3) 不指定，那么无限大小队列1234567891011121314151617&gt;&gt;&gt; q = deque()&gt;&gt;&gt; q.append(1)&gt;&gt;&gt; q.append(2)&gt;&gt;&gt; q.append(3)&gt;&gt;&gt; qdeque([1, 2, 3])&gt;&gt;&gt; q.appendleft(4)&gt;&gt;&gt; qdeque([4, 1, 2, 3])&gt;&gt;&gt; q.pop() # 取出队列中最后一个元素3&gt;&gt;&gt; qdeque([4, 1, 2])&gt;&gt;&gt; q.popleft()4&gt;&gt;&gt; qdeque([1, 2]) 在队列两端插入或删除元素时间复杂度都是 ``O(1)`` ，区别于列表，在列表的开头插入或删除元素的时间复杂度为 ``O(N)`` 从一个集合中获得最大或者最小的 N 个元素列表heapq 模块有两个函数：nlargest() 和 nsmallest() 可以完美解决这个问题。 12345678910111213141516import heapqnums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]print(heapq.nlargest(3, nums)) # Prints [42, 37, 23]print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2]portfolio = [ &#123;&apos;name&apos;: &apos;IBM&apos;, &apos;shares&apos;: 100, &apos;price&apos;: 91.1&#125;, &#123;&apos;name&apos;: &apos;AAPL&apos;, &apos;shares&apos;: 50, &apos;price&apos;: 543.22&#125;, &#123;&apos;name&apos;: &apos;FB&apos;, &apos;shares&apos;: 200, &apos;price&apos;: 21.09&#125;, &#123;&apos;name&apos;: &apos;HPQ&apos;, &apos;shares&apos;: 35, &apos;price&apos;: 31.75&#125;, &#123;&apos;name&apos;: &apos;YHOO&apos;, &apos;shares&apos;: 45, &apos;price&apos;: 16.35&#125;, &#123;&apos;name&apos;: &apos;ACME&apos;, &apos;shares&apos;: 75, &apos;price&apos;: 115.65&#125;]cheap = heapq.nsmallest(3, portfolio, key=lambda s: s[&apos;price&apos;])expensive = heapq.nlargest(3, portfolio, key=lambda s: s[&apos;price&apos;]) 对集合进行排序&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2] &gt;&gt;&gt; import heapq &gt;&gt;&gt; heap = list(nums) &gt;&gt;&gt; heapq.heapify(heap) # 从小到大排序 &gt;&gt;&gt; heap [-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8] &gt;&gt;&gt; &gt;&gt;&gt; heapq.heappop(heap) # 弹出最小元素 -4 &gt;&gt;&gt; heapq.heappop(heap) 1 &gt;&gt;&gt; heapq.heappop(heap) 2 #### 1234&gt;&gt;&gt; line = &apos;asdf fjdk; afed, fjek,asdf, foo&apos;&gt;&gt;&gt; import re&gt;&gt;&gt; re.split(r&apos;[;,\s]\s*&apos;, line)[&apos;asdf&apos;, &apos;fjdk&apos;, &apos;afed&apos;, &apos;fjek&apos;, &apos;asdf&apos;, &apos;foo&apos;] 按顺序插入字典123456789101112131415161718192021from collections import OrderedDictd = OrderedDict()d[&apos;foo&apos;] = 1d[&apos;bar&apos;] = 2d[&apos;spam&apos;] = 4d[&apos;grok&apos;] = 3for key in d: print(key, d[key]) &apos;&apos;&apos;foo 1bar 2spam 4grok 3import jsona = json.dumps(d)type(a) # str print(a) # &apos;&#123;&quot;foo&quot;: 1, &quot;bar&quot;: 2, &quot;spam&quot;: 4, &quot;grok&quot;: 3&#125;&apos; &apos;&apos;&apos; 在两个字典中寻找相同点（比如相同的键、相同的值等等） 123456789101112131415161718192021222324a = &#123; &apos;x&apos; : 1, &apos;y&apos; : 2, &apos;z&apos; : 3 &#125;b = &#123; &apos;w&apos; : 10, &apos;x&apos; : 11, &apos;y&apos; : 2 &#125; # Find keys in common# 类似于集合求合集差集等。a.keys() &amp; b.keys() # &#123; &apos;x&apos;, &apos;y&apos; &#125;# Find keys in a that are not in ba.keys() - b.keys() # &#123; &apos;z&apos; &#125;# Find (key,value) pairs in commona.items() &amp; b.items() # &#123; (&apos;y&apos;, 2) &#125;# 使用列表推导式 从字典a 中删除 键 &apos;z&apos;,&apos;w&apos; c = &#123;key:a[key] for key in a.keys() - &#123;&apos;z&apos;, &apos;w&apos;&#125;&#125; # 值非唯一，不建议用来进行 集合 操作 不打乱顺序去重123456789def dedupe(items): seen = set() for item in items: if item not in seen: yield item seen.add(item)a = [1, 5, 2, 1, 9, 1, 5, 10]list(add(a)) # [1, 5, 2, 9, 10] 可用slice() 优化切片操作123456789101112131415161718items = [0, 1, 2, 3, 4, 5, 6]a = slice(2, 4)items[a] # 等同于 items[2, 4] a = slice(2,10,2)items[a] # 等同于 items[2,10,2]a.start # 2a.stop # 10a.step # 2 &gt;&gt;&gt; s = &apos;HelloWorld&apos; &gt;&gt;&gt; a.indices(len(s)) (5, 10, 2) &gt;&gt;&gt; for i in range(*a.indices(len(s))): ... print(s[i]) ... W r d 看一下range函数 123456789101112 In [178]: a = (5,10,2)In [179]: range(a)In [180]: range(*a)Out[180]: range(5, 10, 2)* 就是将 a 中元素当 位置参数传进去** 就是当字典 def kw_dict(**kwargs): return kwargs print kw_dict(a=1,b=2,c=3) == &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3&#125;]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初探元编程]]></title>
    <url>%2Fpython%2F%E5%85%83%E7%BC%96%E7%A8%8B%2F%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[typetype 是python 内置元类，为改变 Python 中类的行为（比如，SomeClass 的行为），我们可以通过继承 type 元类，定义一个自定义元类。元类是在 Python 中进行元编程的一种方法1234class SomeClass: passsome_object = SomeClass()type(some_object) # __main__.SomeClass 1234567&gt;&gt;&gt; import inspect&gt;&gt;&gt;inspect.isclass(SomeClass)True&gt;&gt;&gt;inspect.isclass(some_object)False&gt;&gt;&gt;inspect.isclass(type(some_object))True 12345678&gt;&gt;&gt; type(type(SomeClass))&lt;type &apos;type&apos;&gt;&gt;&gt;&gt;inspect.isclass(type(type(SomeClass)))True&gt;&gt;&gt;type(type(type(SomeClass)))&lt;type &apos;type&apos;&gt;&gt;&gt;&gt;isclass(type(type(type(SomeClass))))True 除 type 之外，Python 中的一切都是对象，它们要么是类的实例，要么是元类的实例。1234567&gt;&gt;&gt; some_obj = SomeClass()&gt;&gt;&gt; isinstance(some_obj,SomeClass)True&gt;&gt;&gt; isinstance(SomeClass, type)True&gt;&gt;&gt; isinstance(some_obj,type)False 在 Python 中使用 type 来创建类通过一个参数调用 type 时，会生成现有类的 type 信息。通过三个参数调用 type 时，会创建一个新的类对象。调用 type 时，参数是类名、基类列表以及指定类的名称空间的字典（所有字段和方法） 1SomeClass = type(&apos;SomeClass&apos;, (), &#123;&#125;) 与下面等价1SomeClass = type(&apos;SomeClass&apos;, (), &#123;&#125;) 此外12345678def some_function(self): print(&quot;Hello&quot;) ParentClass = type(&apos;ParentClass&apos;, (), &#123;&#125;)SomeClass = type(&apos;SomeClass&apos;, (ParentClass,), &#123;&apos;some_function&apos;: some_function, &apos;some_var&apos;:5&#125;) 等价于1234567class ParentClass: pass class SomeClass(ParentClass): some_var = 5 def some_function(self): print(&quot;Hello!&quot;) 元类编写自定义元类分为两个步骤： 编写元类类型的子类。 使用元类挂钩将新元类插入到类创建流程中 元类的实际使用因为在子类中会继承元类，所以元类解决了代码冗余（不要重复自己 — DRY）这一实际问题。 通常情况下，在生成类对象的同时，通过执行额外操作或添加额外代码，元类也可以帮助提取有关类创建的复杂逻辑。元类的一些实际用例包括： 抽象基类 类的注册 在库和框架中创建 API 抽象基类抽象基类是只能被继承而不会被实例化的类1234567891011from abc import ABCMeta, abstractmethod class Vehicle(metaclass=ABCMeta): @abstractmethod def refill_tank(self, litres): pass @abstractmethod def move_ahead(self): pass 创建一个从 Vehicle 类继承的 Truck 类： 1234567891011class Truck(Vehicle): def __init__(self, company, color, wheels): self.company = company self.color = color self.wheels = wheels def refill_tank(self, litres): pass def move_ahead(self): pass 调用 1mini_truck = Truck(&quot;Tesla Roadster&quot;, &quot;Black&quot;, 4) (参考文档)[https://www.ibm.com/developerworks/cn/analytics/library/ba-metaprogramming-python/index.html]]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[psutil模块]]></title>
    <url>%2Fpython%2Fpsutil%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%88%A9%E7%94%A8%E7%8E%87%2F</url>
    <content type="text"><![CDATA[三大模块 System related function Processes Windows Service 安装方法pip install psutil pip install -user psutil 使用方法123456789101112131415161718192021222324252627import psutil&apos;&apos;&apos;待探索&apos;&apos;&apos;# cpu 节选psutil.cpu_times() # 将系统cpu时间作为命名元组返回psutil.cpu_percent(interval=None, percpu=None) # cpu 使用百分比psutil.cpu_percent(interval=3, percpu=True) # 3秒间隔中，cpu 的占用率psutil.cpu_count() # cpu 逻辑核心数psutil.cpu_count(logical=True) # cpu 物理核心数for i in range(10): psutil.cpu_percent(interval=3, percpu=True) # 3秒间隔中，cpu 的占用率# 内存节选psutil.virtual_memory() # 将系统内存使用情况作为命名元组返回# 当内存不足，发出提示dan = 300 * 1024 * 1024 # 单位为bif psutil.virtual_memory().available &lt;= dan: print(&apos;memory warning&apos;)# 进程信息psutil.pids()[p.info for p in psutil.process_iter(attrs=[&apos;pid&apos;, &apos;name&apos;]) if &apos;python&apos; in p.info[&apos;name&apos;]] 更多单个进程信息1234567891011121314151617181920p = psutil.Process(2423) p.name() #进程名p.exe() #进程的bin路径p.cwd() #进程的工作目录绝对路径p.status() #进程状态p.create_time() #进程创建时间p.uids() #进程uid信息p.gids() #进程的gid信息p.cpu_times() #进程的cpu时间信息,包括user,system两个cpu信息p.cpu_affinity() #get进程cpu亲和度,如果要设置cpu亲和度,将cpu号作为参考就好p.memory_percent() #进程内存利用率p.memory_info() #进程内存rss,vms信息p.io_counters() #进程的IO信息,包括读写IO数字及参数p.connectios() #返回进程列表p.num_threads() #进程开启的线程数听过psutil的Popen方法启动应用程序，可以跟踪程序的相关信息from subprocess import PIPEp = psutil.Popen([&quot;/usr/bin/python&quot;, &quot;-c&quot;, &quot;print(&apos;hello&apos;)&quot;],stdout=PIPE)p.name()p.username() 获取开机时间`psutil.boot_time() # 时间戳 datetime.datetime.fromtimestamp(psutil.boot_time ()).strftime(“%Y-%m-%d %H: %M: %S”) #转换成自然时间格式]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python的一些技巧]]></title>
    <url>%2Fpython%2Fpython%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[变量有关于变量` 定义 __str__ 方法的对象，可以使用 str() 函数 返回可读名称 定义 __next__ 和 __iter__ 方法的对象，就可以被循环迭代 定义 __bool 方法的对象，进行布尔值的判断时就会使用自定义的逻辑]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pathlib模块]]></title>
    <url>%2Fpython%2Fpathlib%E6%9C%89%E5%85%B3%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[面向对象的文件系统路径 pathlib 提供表示文件系统路径的类，适用于不同的操作系统 纯路径提供纯粹的计算操作，具体路径继承纯路径且可以进行 I/O 操作12345678910import pathlibprint(pathlib.PurePath(__file__)) # 文件路径print(pathlib.PurePath(__file__).match(&apos;*.py&apos;))print(pathlib.Path.cwd()) # 当前路径 （运行路径）print(pathlib.Path.cwd().parent) # 上一级print(pathlib.Path.cwd().parent.parent) # 上上级parts = [&apos;first&apos;, &apos;second&apos;, &apos;third&apos;]print(pathlib.Path.cwd().parent.joinpath(*parts)) # 在上一级开始拼接路径 更多123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pathlib import PathPath.iterdir() # 遍历目录的子目录或者文件Path.is_dir() # 判断是否是目录Path.glob() # 过滤目录(返回生成器)Path.resolve() # 返回绝对路径Path.exists() # 判断路径是否存在Path.open() # 打开文件(支持with)Path.unlink() # 删除文件或目录(目录非空触发异常)# 基本属性Path.parts # 分割路径 类似os.path.split(), 不过返回元组Path.drive # 返回驱动器名称Path.root # 返回路径的根目录Path.anchor # 自动判断返回drive或rootPath.parents # 返回所有上级目录的列表# 改变路径Path.with_name() # 更改路径名称, 更改最后一级路径名Path.with_suffix() # 更改路径后缀#拼接路径Path.joinpath() # 拼接路径Path.relative_to() # 计算相对路径# 测试路径Path.match() # 测试路径是否符合patternPath.is_dir() # 是否是文件Path.is_absolute() # 是否是绝对路径Path.is_reserved() # 是否是预留路径Path.exists() # 判断路径是否真实存在# 其他方法Path.cwd() # 返回当前目录的路径对象Path.home() # 返回当前用户的home路径对象Path.stat() # 返回路径信息, 同os.stat()Path.chmod() # 更改路径权限, 类似os.chmod()Path.expanduser() # 展开~返回完整路径对象Path.mkdir() # 创建目录Path.rename() # 重命名路径Path.rglob() # 递归遍历所有子目录的文件]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于import]]></title>
    <url>%2Fpython%2F%E5%85%B3%E4%BA%8Eimport%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[12345678import syssys.path.append(&quot;..&quot;) # 将上层目录加入路径.sys.path.append(&quot;/home&quot;) # 将/home 加入路径.## 一个模块只能被导入一次from imp import *reload(sys) # 重新导入某模块]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux使用者管理]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2Flearn_linux%2Flinux%E4%BD%BF%E7%94%A8%E8%80%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[新建用户1234567891011root 权限下：useradd testpasswd testuserdel -r test # 连同文件夹一起删掉addgrop friendsusermod -laddgrop -g/G 例行工作12atcron 程序管理与selinux初探 程序一般放在磁盘中，通过用户的执行来触发，触发后会加载到内存中成为一个个体，就是进程。 &amp; 后台运行 (关掉终端会停止) nohup + cmd + &amp; 或者setsid + cmd + &amp; fg %1 将job 1拿到前台来 vi 下 ctrl + z 可将vi 放到后台。 kill # kill -9 %1 bg 后台暂停的 让 后台运行 top -d 5 -p 12345 free -g uname -a uptime netstat -a SELinuxSecurity Enhanced Linux screen1234screen -dmS test # 创建 test 窗口screen -r test # 连接 test 窗口screen -d test 后 screen -r test # 如果连接不上，这样连接screen -S test -X quit # 删除 test 窗口 rsync 同步 rsync -arv ./ back/ rsync -arv ./ root@107.172.82.37:/root/back/]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[zabbix使用]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2Flearn_linux%2Fzabbix%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[原文链接]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[杂]]></title>
    <url>%2Fpython%2Freadme%2F</url>
    <content type="text"><![CDATA[python中变量名 指向的 是 对象的地址，不是对象的值]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基础]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2Flearn_linux%2Fbash_shell%2Freadme%2F</url>
    <content type="text"><![CDATA[基础 .bash_history 历史记录 Tab 补全 alias 命令别名， alias lm = ‘ls -al’ , unalias lm (临时) vi /root/.bashrc （永久） type cd 命令类型 \ 转义 变量 变量未设置时，默认为空 PATH=$PATH:/home/bin 变量累加 export PATH 使变量成为环境变量 一般默认 大写为系统变量 小写为自行设置变量 变量中 单引号’’（纯文本） 与 双引号 “” (保持原本特性) current_path=$(pwd) 接命令赋值给变量。 等同于 123456789101112current_path=`pwd`# 建议都用 $(pwd)``` 7. `unset current_path` 取消变量8. 子进程取消的变量 对 父进程无影响，子进程只继承父进程的环境变量与export。9. `work=/opt/software` 可以`cd $work` 。写入.bash_profile 全局生效。10. `env` 查看环境变量11. `set` 查看所有变量12. `echo $?` 只与上一个命令有关，上一个命令成功返回0## 变量读取，数组与声明 read -s -p “please input root password:” serverPwd # -p 提示 -s 不显示echo $serverPwdecho -e “\n” # -e 启用反斜杠转义 （换行）1**数组** var[1]=’small’var[2]=’big’echo “$var[1],$var[2]”1declare 和 typeset 一样声明变量类型 sum=100+1echo $sun # 100+1declare -i sum=100+1echo $sun # 101 1## $ $0 当前脚本的文件名$n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。$# 传递给脚本或函数的参数个数。$* 传递给脚本或函数的所有参数。 # 双引号内，会识别成一个整体$@ 传递给脚本或函数的所有参数。 # 双引号内，还是会识别成一个一个参数$? 上个命令的退出状态，或函数的返回值。一般情况下，大部分命令执行成功会返回 0，失败返回 1。$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID1234567891011121314151617## 与文件系统及程序的限制关系：ulimit## 数据流重定向st:standard1. stdin &lt; &lt;&lt; (代码0)2. stout &gt; &gt;&gt; (代码0)3. stderr 2&gt; 2&gt;&gt; (代码2)4. `&gt;/dev/null ,2&gt;/dev/null` 丢弃输出5. `&gt; list 2&gt;&amp;1 (都输出 list)或 &amp;&gt; list`## 命令执行判断依据1. cmd1,cmd2,cmd3 依次执行2. cmd1 &amp;&amp; cmd2 &amp;&amp; cmd3 前面成功，后面才执行（$# = 0）3. cmd1 || cmd2 || cmd3 前面成功，后面就不执行（$# = 0）## 管道命令（pipe）**将前一个命令的stout(不会处理stderr) 传到下一个命令的stdin中** yes|bash …sh(执行命令输入yes)echo $PATH |cut -d ‘:’ -f 4 # 以 : 分割$PATH ,取出第4个echo $PATH |cut -d ‘:’ -f 3,5 # 以 : 分割$PATH ,取出第3,5个export | cut -c 12- # 取出12到最后的字符last | grep -i root # 找出last中的含root行，忽略大小写last | grep -v root # 不含root行last | grep root|cut -d ‘ ‘ -f 1| sort | uniq -ic # i 忽略大小写 c 计数cat /etc/os-release | wc # 输出 行 字数 字符数wc -l(行) -w(英文单字) -m (多少字符)12## 双向重定向（tee）**将数据流同时输出到屏幕和文件中** last |tee -a last.list # -a 累加` shell脚本shell script 是利用shell的功能所写的一个纯文本文件，将一些shell的语法命令写在里面，搭配正则表达式，管道命令与数据流重定向等功能达到我们想要的目的。]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[进程与线程]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2Flearn_linux%2F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[CPU，它承担了所有的计算任务，进程是指程序的一次执行，线程是CPU的基本调度单位。 进程的内存空间是共享的，每个线程都可以使用这些共享内存, 一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存,”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域 “互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域 某些内存区域，只能供给固定数目的线程使用,”信号量”（Semaphore），用来保证多个线程不会互相冲突 概念进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。 一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[dockerfile]]></title>
    <url>%2Fdocker%2FDockerFile%2F</url>
    <content type="text"><![CDATA[简介Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于操作系统基础镜像并最终创建的一个新镜像； 常用命令FROM image:tag : 使用的基础镜像构建MAINTAINER user_info : 声明镜像维护者信息LABEL value : 镜像描述元信息 (可以多条)ENV key value : 设置环境变量 (可以多条)RUN command : 构建镜像时需要运行的命令 (可以多条)WORKDIR path_dir : 设置终端默认登录进来的工作目录EXPOSE port : 当前容器对外暴露出的端口ADD source_dir/file dest_dir/file : 宿主机内文件复制到容器，压缩文件会解压COPY source_dir/file dest_dir/file : 同 ADD，不过压缩文件不解压VOLUME : 创建一个 可以从本机或其他容器挂载的挂载点，一般用来存放数据库和需要保存的数据CMD : 指定容器启动时要运行的命令，多个CMD，最后一个生效 CMD 或CMD [““,”“,”“,…] CMD [““,”“,…]ENTRYPOINT : 指定容器启动时要运行的命令ONBUILD : 为子镜像服务1234567简单实例：父镜像Dockerfile:FROM centosONBUILD RUN yum -y install vimCMD /bin/bash 子镜像简单点：FROM parent Dockerfile1234567891011121314FROM centosMAINTAINER caofeng&lt;caofeng2012@126.com&gt; LABEL name=&quot;imwl CentOS Image&quot; \ build-date=&quot;20180916&quot; ENV WORKPATH /home/WORKDIR $WORKPATH RUN yum -y install net-toolsRUN yum -y install vim EXPOSE 80CMD /bin/bash]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用模块]]></title>
    <url>%2Fpython%2Fflask%2Freadme%2F</url>
    <content type="text"><![CDATA[常用模块 pipenv # 虚拟环境 flask # 主要 路由、调试、web服务器网关接口子系统由 Werkzeug 提供。模板系统 Jinja2提供。 flask-wtf # 对独立的WTForms包进行了封装，用于表单处理 flask-sqlalchemy # 数据库框架，简化flask应用中使用 SQLAlchemy 操作， ORM 也可用其他 flask-migrate # 数据库迁移框架 flask-mail # 电子邮件支持 flask-login # 用于管理用户身份验证系统中的验证状态，且不依赖特定的身份验证机制 调试模式Flask 应用在 调试模式中运行， 默认加载 重载器和调试器， 重载器： 源码文件变动时，自动重启服务器 调试器： 当应用抛出未处理的异常，会出现在浏览器中。 千万不要在生产服务器中启动调试模式，启动调试模式可以要求输入 PIN 应用和请求上下文 变量名 上下文 说 明 current_app 应用上下文 当前应用的应用实例 g 应用上下文 处理请求时用作临时存储的对象，每次请求都会重设这个变量 request 请求上下文 请求对象，封装了客户端发出的 HTTP请求中的内容 session 请求上下文 用户会话，值为一个字典，存储请求之间需要 记住 的值]]></content>
      <categories>
        <category>flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[部署]]></title>
    <url>%2Fpython%2Fflask%2F%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[部署流程 自动执行全部任务 把生产环境中的错误写入日志 部署方式 云托管 容器 eg:docker PaaS 平台即服务 使用docker 部署 安装docker 构建容器映像 运行容器 数据库等最好另开容器 容器编排 Docker Compose 定义的所有容器，可以使用 docker-compose 命令一次性全部启动]]></content>
      <categories>
        <category>flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[个人计算机]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2Flearn_linux%2F%E4%B8%AA%E4%BA%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[个人计算机架构与接口设备主板主流 x86 开发商（Intel，AMD）的 cpu 架构并不兼容， 两大主流的 CPU 所需要的主板芯片组设计也不相同。 芯片组 分为两个 桥接器 来控制各组件通信 北桥负责连接速度较快的 CPU 、内存、显卡等组件 南桥负责连接速度较慢的周边接口，包括usb,硬盘，网卡等 tips : AMD 将内存控制组件集成到 CPU 当中，加速 CPU 与内存的传输速度。（AMD 和 INTEL 的架构上的主要区别） CPU 多核 ： 一个 CPU 多个运算内核 频率 ： CPU 每秒可进行的工作次数，等于外频和倍数的乘积（外频：CPU与外部组件进行数据传输/运算时的速度，倍频：CPU内部用来加速工作性能的一个倍速） 32位 与 64位： 主要依据 CPU 解析的字组大小来判定。 32位 CPU 最大只能够支持到 4GB 内存 内存个人计算机的内存主要组件为 动态随机访问内存 （通电使用与记录，断电数据消失） 双通道设计理念 ： 一条内存仅达 64位，两条内存可达128位 BIOS ： Basic input output System , 写死到只读存储器中 （Read Only Memory,rom）,BIOS 系统在开机的时候首先读取的一个程序。（因为升级BIOS，现在BIOS通常写在闪存或EEPROM） 显卡显卡上面有一个 内存的容量，将会影响到最终的屏幕分辨率与色彩深度。运算速度，显卡上面嵌入一个 3D 加速的芯片 ， GPU 的由来。 硬盘PCI适配卡电源操作系统与应用程序操作系统 内核 （kernel）： 是一组程序，重点在于管理计算机的所有活动以及驱动系统中的所有硬件 内核程序所放置到内存当中的区块是受保护的，并且开机常驻内存。主要功能有： 系统调用接口、 程序管理、 内存管理、 文件系统管理、 设备驱动等 系统调用 ： 通常会提供一整组的开发接口给工程师来开发软件应用程序应用程序： 是参考操作系统提供的开发接口所开发出来的软件]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日志文件]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2Flearn_linux%2F%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[日志文件日志文件记录系统在什么时候由哪个进程做了什么样的行为，发生了何种事件等。 syslogd: 主要登录系统与网络等服务的信息。 klogd: 主要登录内核产生的各项信息。 logrotate: 主要进行日志文件的轮替功能。]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[权限目录]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2Flearn_linux%2F%E6%9D%83%E9%99%90%EF%BC%8C%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[用户与用户组 u g o a (user group other all) r:4 w:2 x:1 chgrp chown chmod 目录1234567891011121314151617181920# 一般情况下lrwxrwxrwx. 1 root root 7 Feb 2 14:33 bin -&gt; usr/bin #bin 放用户可用，启动时会用到的命令 l 连接文件 指向 /usr/bin dr-xr-xr-x. 6 root root 4096 Feb 20 10:37 boot # 开机用到的文件，内核，相关设置drwxr-xr-x. 19 root root 3560 Apr 22 16:07 dev # 任何设备与接口设备drwxr-xr-x. 93 root root 12288 May 24 16:05 etc # 配置文件drwxr-xr-x. 6 root root 4096 May 24 14:42 home # 默认用户主文件夹lrwxrwxrwx. 1 root root 7 Feb 2 14:33 lib -&gt; usr/lib #系统函数库lrwxrwxrwx. 1 root root 9 Feb 2 14:33 lib64 -&gt; usr/lib64 drwx------. 2 root root 16384 Feb 2 14:32 lost+found # 文件系统发生错误时，保存的一些丢失片段dr-xr-xr-x. 9 root root 2048 Jan 15 21:24 media # 可删除设备drwxr-xr-x. 2 root root 4096 Jun 25 2018 mnt # 额外挂载设备drwxr-xr-x. 7 root root 4096 May 24 16:16 opt # 第三方软件放置库dr-xr-xr-x. 505 root root 0 Feb 19 17:39 proc #虚拟文件系统，内核进程网络状态等存在于内存中，不占磁盘空间dr-xr-x---. 4 root root 4096 May 24 14:54 root # 系统管理员主文件夹lrwxrwxrwx. 1 root root 8 Feb 2 14:33 sbin -&gt; usr/sbin # 开机过程需要的命令drwxr-xr-x. 3 root root 4096 May 24 14:39 srv # 服务数据目录dr-xr-xr-x. 13 root root 0 Feb 19 17:40 sys # 同proc ，目前已加载的内核模块，与内存监测到的硬件设备信息等。drwxrwxrwt. 25 root root 4096 May 24 16:44 tmp # 临时放置文件drwxr-xr-x. 14 root root 4096 Feb 2 14:33 usr # 可分享不可变动的，所有系统默认软件等drwxr-xr-x. 21 root root 4096 Feb 20 10:37 var # 缓存，登录文件以及某些软件运行所产生的文件等。 可变动的，不可变动的 可分享的，不可分享的]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件，目录]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2Flearn_linux%2F%E6%96%87%E4%BB%B6%EF%BC%8C%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[目录与路径 cd pwd mkdir rmdir mkdir -m 711 test , mkdir -p -m mkdir -m 711 test/test/test/test1 (仅test1 为711) rmdir -p test/test/test/test1 （递归删除空目录） 查询 file /user/bin/passwd # 查询某文本数据类型 which python # 查询某命令位置 whereis passwd # 查询某目录，文件位置 locate passwd # -i 忽略大小写 -r 接正则表达式 find # 能执行额外的动作 内存交换空间（swap）CPU读取的数据都来自于内存，内存不足时，内存中暂不使用的程序和数据会被移动到swap中 #]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机概论]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2Flearn_linux%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[计算机概论计算机五大部分 输入单元 中央处理器 （控制器，运算器） 内存 输出单元 cpu 种类 精简指令集 （RISC） 复杂指令集 （CISC） CPU内部已经含有一小的指令集，我们所使用的软件都要经过 CPU 内部的微指令集来完成 精简指令集RISC比较精简，每个指令执行时间短，完成的操作也很单纯，指令的执行性能比较好，但要做复杂的事情，就要多个指令来完成（ ARM ） 复杂指令集CISC的微指令集中，每个小指令可以执行一些较低阶的硬件操作，指令数目多且复杂，每条指令的长度并不相同。每个指令花费时间长，但每条个别指令可以处理的工作比较丰富。（AMD INTEL 等 x86 架构 CPU ）(64 位的个人计算机CPU 统称为 x86_64 架构) 接口设备最重要的接口设备是主板，主板将所有的设备连接在一起，让它们能够协调通信 主板上最重要的组件 ： 主板芯片组 ，将所有设备汇聚在一起 计算机发展简史 电子管计算机 晶体管计算机 集成电路计算机 （计算机具备进入千家万户条件）IBM 推出兼容的产品 System/360 操作系统的雏形 超大规模集成电路计算机 （当前计算机） 计算机分类 超级计算机 # 天河二号等 大型计算机 # 去’IOE’ 微型计算机 # 小型机，普通服务器, 已经代替了传统大型机，成为大规模企业计算的中枢 工作站 # 比个人计算机更强大的性能 微电脑 （个人 pc ） 计算机上常用的计算单位大小单位理论上只认识0与1，0/1 的单位称为 bit，存储数据时，每份简单的数据都会使用 8 个 bit 来记录，称之为 Byte1Byte = 8 bitk M G T P 用来简化1024写法 速度单位CPU 常用 MHz 和 GHz ，(Hz 秒分之一) 网络上使用的 bit 为单位， 8Mbit/s ,转化为 Byte 为 1024 kB/s 或 1 MB/s 或 8Mbps ##]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2Flearn_linux%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[计算机组成原理总结计算机系统简介计算机系统由“软件“及”硬件“组成，软件通常分为系统软件和应用软件。系统软件:用来管理整个计算机系统，监视服务，使系统资源得到合理调度，高效运行。应用软件:根据用户任务需求所编制的各种程序。 计算机系统的层次结构通常用户用高级语言编写程序，然后将它和数据一起送入计算机内，再由计算机将其翻译成机器能识别的机器语言程序，然后交由机器运行。 高级语言机器 → → 汇编语言机器 → →机器语言机器 或 高级语言机器 → → 机器语言机器 通常，将高级语言程序翻译成机器语言程序的软件成为翻译程序。翻译程序分为：编译程序，解释程序。编译程序：一次全部翻译成机器语言程序，然后交由机器执行。解释程序：边翻译，边执行。 高级语言机器 → → 汇编语言机器 → →机器语言机器 → →微指令系统 高级语言机器 → → 汇编语言机器 → →操作系统机器→ →机器语言机器 → →微指令系统 第1章：计算机系统概论1、计算机系统由哪两部分组成？计算机系统性能取决于什么？ 计算机系统是由“硬件”和“软件”组成。衡量一台计算机性能的优劣是根据多项技术指标综合确定的，既包括硬件的各种性能指标，又包括软件的各种功能。1）计算机系统由硬件和软件两部分组成。2）计算机系统性能由硬件和软件共同决定。 2、计算机系统5层层次结构从下到上由哪五层组成？哪些是物理机，哪些是虚拟机？ 1）微程序机器、传统机器、操作系统机器、汇编语言机器、高级语言机器2）微程序机器和传统机器是物理机，其他是虚拟机。 3、在计算机系统结构中，什么是翻译？什么是解释？ 1）翻译：将一种语言编写的程序全部翻译成另一种语言，然后再执行；2）解释：将一种语言编写的程序的一条语句翻译成另一种语言的一条或多条语句，然后执行，执行完这条语言后，再解释下一条。 4、什么是计算机体系结构？什么是计算机组成？以乘法指令为例说明二者区别。 1）计算机体系结构是指那些能够被程序员看到的计算机的属性。如指令集、数据类型等；2）计算机组成是指如何实现计算机体系结构所体现出来的属性；3）以乘法指令为例，计算机是否有乘法指令，属于体系结构的问题。乘法指令是采用专用的乘法器，还是使用加法器和移位器构成，属于计算机组成的问题。 5、冯诺依曼机器的主要特点？ 1）计算机由运算器、存储器、控制器、输入设备和输出设备五大部分组成；2）指令和数据存储在存储器中，并可以按地址访问；3）指令和数据均以二进制表示；4）指令由操作码和地址码构成，操作码指明操作的性质，地址码表示操作数在存储器中的位置；5）指令在存储器内按顺序存放，通常按自动的顺序取出执行；6）机器以运算器为中心，I/O设备与存储器交换数据也要通过运算器。（因此，后来有了以存储器为中心的计算机结构） 7、什么是存储单元、存储字、存储字长、存储体？ 存储单元：存储一个存储字并具有特定存储地址的存储单位；存储字：一个存储单元中存放的所有的二进制数据，按照某个地址访问某个存储单元获取的二进制数据。存储字长：存储字中二进制数据的位数，即按照某个地址访问某个存储单元获取的二进制数据的位数；存储体：由多个存储单元构成的存储器件。 8、主存储器中，什么是MAR，什么是MDR，存储器的最大容量由什么决定？ 1）MAR：存储地址寄存器，保存需要访问的存储单元地址。反映存储单元的个数。2）MDR：存储数据寄存器，缓存读出/写入存储单元的数据。反映存储字长。3）存储器的最大容量由MAR寄存器的位数和MDR寄存器的位数决定。 9、什么是机器字长，什么是存储字长长？ 机器字长：CPU一次能够处理的二进制数据的位数。存储字长：按照某个地址访问某个存储单元获取的二进制数据的位数。 10、假设MAR寄存器的位数为16位，MDR寄存器的位数为16位，存储器的最大容量是多少？ 1）MAR寄存器的位数为16位，能表示的地址个数为2的16次方，为64K；2）MDR寄存器的位数为16位，说明存储字长为16位，也即2个字节；3）存储器的最大容量为64K * 2B = 128K Byte 第三章 系统总线1、为什么要使用总线？ 在冯诺依曼结构中，各个部件之间均有单独连线，不仅线多，而且导致扩展I/O设备很不容易。即扩展一个I/O设备，需要连接很多线。因此，引入了总线连接方式，将多个设备连接在同一组总线上，构成设备之间的公共传输通道。 2、总线的两大基本特征是什么？ 1）共享：多个部件连接在同一组总线上，各个部件之间都通过该总线进行数据交换。2）分时：同一时刻，总线上只能传输一个部件发送的信息； 3、系统总线按照传输信息的不同，分成哪几类？是单向的，还是双向的？ 1）分成数据总线、地址总线以及控制总线。2）数据总线：各个功能部件之间传送数据信息，双向传输；3）地址总线：用来指明数据总线上，源数据或目的数据所在的主存单元的地址。单向：由CPU发出4）控制总线：用来发送各种控制信号。对于控制总线中的单根线，是单向的，即只能由一个部件发向另一个部件。而一组控制总线中，有输入也有输出，因此，控制总线也可以看成是双向的。 3、什么是总线宽度、总线带宽、总线复用、信号线数？ 1）总线宽度：数据总线的根数，一般是8的倍数。是衡量计算机系统性能的重要指标；2）总线带宽：即总线数据传输速率，总线上每秒能够传输的最大字节量。3）总线复用：一条信号线上分时传送两种信号。例如数据总线和地址总线的分时复用；4）信号线数：地址总线、数据总线和控制总线三种总线的线数之和。 4、假设总线的工作频率为33MHz，总线宽度为32位，则它最大的传输速率是多少？ 33 * （32/8） = 132 MB/s 5、简要说明单总线结构的概念及缺点？（现代计算机为什么要采用多总线结构？） 在单总线结构中，所有的部件（CPU、主存、I/O设备）都连接在一组总线上。但所有的信息传送都要通过这组总线，同时只能有一个部件向总线上发送信息，导致总线成为系统的瓶颈。因此，发展出来了多总线结构，其基本思想均是将速度相近的设备挂接在同一组总线上，总线之间通过总线控制器相连。例如CPU和Cache之间、I/O设备之间等。 6、集中式总线判优控制有哪三种方式，哪种方式的优先级不能改变？ 1）链式查询、计数器定时查询、以及独立请求。2）链式查询的优先级不能改变，离控制器最近的优先级最高。 8、什么是总线周期，分为哪几个阶段？ 1）总线周期：总线上两个部件完成一次完整且可靠的数据传输时间；2）分为四个阶段：申请分配阶段：申请总线寻址阶段：发出地址及有关命令传数阶段：进行数据交换结束：从总线上撤除信号，让出总线 9、什么是总线通信控制，总线通信控制有哪几种？ 1）总线通信控制：解决通信双方如何获知传输开始和传输结束，以及如何协调配合；2）同步通信、异步通信、半同步通信、分离式通信 10、什么是同步通信？其优点和缺点？ １）同步通信：总线上各个部件由统一的时钟信号控制；在总线周期中，每个时钟周期各个部件如何动作都有明确的规定。２）优点：速度快，各个模块间配合简单３）缺点：以总线上最慢的部件来设计公共时钟，影响总线效率。 11、什么是异步通信？异步通信分为哪几种类型？ 1）异步通信：总线上各部件没有统一的时钟标准，采用应答式通信；（主模块发出请求后，一直等到从模块反馈回来应答信号之后才开始通信）2）不互锁、半互锁、全互锁。（需要了解各种方式的含义） 12、什么是波特率？什么是比特率？（需要掌握如何计算波特率、比特率） 波特率：单位时间内传送的二进制数据数据的位数，单位bps比特率：单位时间内传送的有效的二进制位数。 13、异步通信时，常规需要设置的参数有哪些？ 波特率、停止位（1/2/1.5）、校验位（奇校验、偶校验、无校验） 14、简述半同步通信的基本原理。 半同步通信结合同步通信和异步通信。同步通信：采用统一的时钟，规定了在一定的时钟周期干什么事情；异步通信：如果从模块没有准备好，增加一个“等待响应”信号。 15、简述分离式通信的基本原理。 主模块发出地址和命令之后，放弃总线，在从模块准备数据期间，使得总线可以被其他设备所用。提高总线利用率。但是，这种方式控制比较复杂。 16、奇偶校验可以纠错吗？汉明码可以纠错码？ 1）奇偶校验只能检错，不能纠错。2）汉明码可以纠错。 第四章 存储器1、存储器按存取方式，可以分成哪四类？哪些属于随机访问存储器，哪些属于串行访问存储器？ 1）可以分为随机存储器、只读存储器、顺序存储器和直接存储器；2）随机存储器和只读存储器属于随机存储器，即存取时间与物理地址无关；3）顺序存储器（典型的如磁带）和直接存储器（典型的如磁盘）属于串行存储器，即存取时间与物理地址有关。 2、衡量存储器使用哪三个指标？寄存器、缓存、主存中，哪个速度最快？哪个最便宜？ 1）速度、容量、位价格。2）寄存器速度最快，主存最便宜。 3、常见的存储系统层次结构有哪两种？透明性如何？各自用来解决什么问题的？ 1）缓存-主存层次：用来缓解CPU和主存速度不匹配的问题，由硬件来完成，对所有的程序员完全透明。2）主存-辅存层次：用来解决主存容量不够的问题，由操作系统和硬件共同完成，对应用程序设计者透明，对系统程序设计者不透明。（现在一般存储器都即能按字访问，也能按照字节访问，因此，存储器编址时，每个字节都有一个独立的地址。） 4、字在存储单元中有两种存储方式，大端方式和小端方式。各是什么含义？x86采用的是哪种存储方式？ 1）大端方式：字的低位存在内存的高地址中，而字的高位存在内存的低地址中；2）小端方式：字的低位存在内存的低地址中，而字的高位存在内存的高地址中。3）x86CPU采用的是小端方式。 5、主存的三个主要技术指标 存储容量、存取速度和存储带宽 6、什么是存取时间？什么是存取周期？哪个大？ 1）存取时间：启动一次存储器完成本次操作（读或写）所需的时间；2）存取周期：连续两次启动存储器所需要的最小间隔时间；3）存取周期包含存取时间； 7、什么是存储器带宽？（要了解如何计算存储器带宽） 单位时间内存储器存取的信息量； 8、半导体存储芯片译码驱动包含哪两种方式，请简要说明。 1）线选法：所有的地址芯片通过一个译码器译码，选择一个存储单元的各位，适合于存储容量不大的芯片；2）重合法：将地址分为两组，每组通过一个译码器译码，选择行或列，行、列交叉处就是要访问的存储位。 9、随机存储器包含哪两大类？哪个需要刷新？请从速度、容量、价格等方面进行简要比较。 1）静态RAM：采用锁存器原理实现；2）动态RAM：采用电容原理实现，需要刷新。3）相比于动态RAM，静态RAM的速度快、容量小、价格高，一般用于缓存，而动态RAM一般用于内存。 10、只读存储器有哪几种？ 1）掩模ROM（MROM）：出厂后内容不能被更改。2）PROM：可编程只读存储器，可以进行一次性编程；3）EPROM：可擦除只读ROM，用紫外线照射；4）EEPROM：电可擦除只读ROM。6）FLash Memory：采用EEPROM的非易失性存储器。 11、单片存储器芯片的容量有限，很难满足实际需要，因此必须将若干存储芯片连接在一起才能组成足够容量的存储器。存储器的扩展通常有位扩展和字扩展，什么是字扩展，什么是位扩展？请举例简要说明 1）位扩展：增加存储器的字长，例如两个1K 4位的存储芯片构成1个1K8位的存储器；2）字扩展：增加存储器的字数，例如两个1K 8位的存储芯片构成1个2K 8位的存储器；通常字扩展和位扩展两种方式混合使用。 12、熟虑掌握存储器的扩展，包括地址空间分配、地址线的连接、数据线的连接、片选信号的产生及连接等；参看P94页，例4.1 13、假设欲检测的二进制代码为n位，为了使其具有1位的纠错能力，需添加K位检测位，组成n+k位的代码。问，应添加多少位检测位？ 应添加的检测位位数：2的k次方大于等于n+k+1。因为要使其有1位的检测能力，必须使用k位来说明n+k位到底哪一位出现了错误，k位能表达的数量为2的k次方，而n+k位到底哪一位出现了错误或者是全部正确，共有n+k+1种状况，因此，k的取值需要满足：2的k次方大于等于n+k+1 14、对于汉明码，应熟练掌握汉明码的编码方式（按照配偶或配奇的原则），以及给出汉明码，得到要传送的原始信息（包括纠错过程）。 15、提高访存速度的三种方式。 1）采用高速元器件；2）采用存储层次结构：cache-主存结构；3）调整主存结构：包括单体多字，多体并行两种方式。 16、简述单体多字的存储系统的工作原理，及其优点。 1）单体多字存储系统一次访存取出多个CPU字，即存储字为CPU字的n倍（假设一次访存取出n个cpu字）。2）优点是：显著提高了存储器带宽。 17、多体并行系统有哪两种编址方式？请简要说明其编址方式及其优点。 1）高位交叉编址方式：存储体的编址方式为顺序存储，即一个存储体存满后，再存入下一个；存储单元地址的高位为存储体的编号。高位交叉编址并不能提高单次访存速度，但能使多应用并行访存，提高系统的并发性。2）低位交叉编址方式：存储体的编址方式为交叉存储。即程序连续存放在相邻的存储体之中。存储单元地址的低位为存储体的编号。低位交叉编址能显著提高单次访存速度。 19、在四位低位交叉编址中，假设存取周期为T，总线传输周期为τ，为了实现流水线方式存储，应满足什么条件？如果连续读取四个字，所需要的时间是多少？ 1）T= 4τ2）连续读取四个字，所需要的时间为T + （4-1）τ注意：假设不是低位交叉编址，而是高位交叉编址，连续读取四个字所需要的时间仍然为4T。 20、需要大家掌握多体并行存储器在高位交叉编址（顺序存储）和低位交叉编址（交叉存储）的情况下，存储器带宽的计算方式。 21、在CPU和内存之间引入cache的原因。 1）避免cpu空等I/O访存；2）缓解CPU和主存速度不匹配的问题。 22、什么是程序的局部性原理。 CPU从主存取指令或数据，在一定时间内，只是对主存局部地址区域访问。 23、Cache命中率、平均访问时间以及访问效率的计算。 24、Cache写操作有哪两种方式？ 1）写直达法：写操作既写入Cache又写入主存；2）写回法：只把数据写入Cache而不写入主存，当Cache中数据被替换出去之后才写入主存。 25、将主存地址映射到Cache地址称为地址映射，常见的Cache映射方式有哪几种？ 直接映射、全相联映射、组相联映射。 26、直接映射的优缺点？ 优点：地址变换速度快。缺点：cache利用率不高，块冲突率高； 27、全相联映射的优缺点？ 优点：cache利用率高，块冲突率低。缺点：地址变换复杂，需要较多的硬件。 28、需要大家掌握各种映射方式之下，写出主存地址格式、cache地址格式，以及主存地址向cache地址的转换。 29、Cache常用的替换算法有哪些？哪个命中率最高？ 1）先进先出、近期最少使用算法和随机替换算法；2）命中率最高的是近期最少使用算法； 30、磁盘的三地址结构包括哪些？ 柱面、磁头号和扇区号 第五章 输入输出系统1、I/O系统的发展大致可以分为哪4个阶段？ 1）早期（分散连接、串行工作、程序查询）2）接口模块和DMA阶段（总线连接、并行工作、中断及DMA）3）通道阶段（通道是具有特殊功能的处理器）4）I/O处理机阶段I/O系统的发展实际上是逐步将CPU从繁重的I/O工作中解放出来的过程； 2、I/O设备编址有哪两种方式？各有什么优缺点？ 1）统一编址方式：和存储器统一编址，I/O地址作为存储器地址的一部分；无须用专用的I/O指令，但占用存储器空间。2）独立编址方式：和存储地址分开编址，需用专用的I/O指令。 3、I/O设备与主机的联络方式有哪几种？ I/O设备与主机间交互信息时必须了解彼此的状态。根据I/O设备工作速度的不同，可以分为3类：1）立即响应：不管其状态（认为其时刻准备好），适用于慢速设备。2）应答信号：通过应答信号来进行交互；3）同步时标：采用统一的时钟信号。 4、I/O总线包括哪四类？ 数据线、设备选择线、状态线、命令线 5、I/O设备通常使用D触发器（完成触发器）和B触发器（工作触发器）来标识设备所处的状态。D=0，B=0：暂停状态；D=0，B=1：准备状态D=1，B=0：就绪状态 6、程序查询的基本工作原理。 cpu不断去查询I/O设备状态，导致CPU和I/O设备串行工作。 7、什么是中断？ 计算机在执行程序过程中，当出现异常清空或特殊请求时，计算机停止现行程序的运行，转去处理这些异常清空或特殊请求，处理结束后，再返回现行程序的间断处，继续执行原程序，即为中断。 8、中断服务程序的基本流程包括哪四部分？ 1）保护现场2）中断服务3）恢复现场4）中断返回 9、什么是单重中断和多重中断？ 1）单重中断：不允许中断现行的中断服务程序；2）多重中断：允许级别更高的中断源中断现行的中断服务程序，也称为中断嵌套； 10、CPU响应中断的时机？ 当前指令执行完毕后，cpu发出中断查询信号，也就是说，中断响应一定是在每条指令执行结束之后进行的，不可能在指令执行过程中响应中断。 11、什么是DMA？ DMA：直接内存访问。在主存和I/O设备之间建立独立的总线连接。 12、在DMA方式中，由于DMA接口与CPU共享主存，可能会出现两者争用主存的冲突，为解决冲突，DMA和主存交换数据时，通常采用哪三种工作方式？ 1）停止CPU访问主存：DMA访存优先级高；2）周期挪用（窃取）：DMA挪用存储或窃取总线使用权一个或几个主存存取周期；3）DMA和CPU交替访问：将CPU工作周期分成两部分，一部分供DMA访存，一部分供CPU访存。 13、DMA工作过程包括哪三部分？ 1）预处理2）数据传输2）后处理 第六章 计算机的运算方法1、掌握有符号数的原码计算方法，以及通过原码求真值； 2、掌握补码计算的方法，以及通过补码求原码，然后求真值的方法。 1）通过原码求补码：符号位不变，各位取反，末位加1；2）通过补码求原码：符号位不变，各位取反，末位加1； 3、原码中0有2种表示方法（正零和负零），补码中0只有一种表示方法（正零和负零的表示方法一致） 4、假设有符号数的位数为8（包括符号位），补码能表示的真值的范围？ 补码能表示的真值范围为-128~+127（参见补码定义）5、掌握求反码以及移码的方法。 6、什么是定点表示？什么是浮点表示？ １）定点表示：小数点固定在某一位置的数为定点数；２）浮点表示：小数点位置可以浮动的数。 7、浮点数在机器中的表示形式，由哪几部分组成？ 由尾数、数符、阶码、阶符四部分组成。 8、掌握规格化浮点数的表示范围（最大正数、最小正数、最大负数、最小负数）的计算方法。 9、IEEE754标准规定的浮点数由哪几部分组成？ 由数符、阶码（含阶符）以及尾数组成。 10、IEEE754标准规定的浮点数中，阶码和尾数用什么形式表示？ 阶码用移码表示，其偏移量是2^(n-1)，尾数用原码表示。 11、float占多少位？double占多少位？ float为短实数，占32位，其中阶码8位，尾数23位。double为长实数，占64位，其中阶码占11位，尾数为52位。 12、对正数进行算术移位，当正数采用源码、补码、反码时，左移或右移时，低位或高位添补什么代码？ 对于正数，其源码、补码、反码均等于真值，左移时，低位添补0，右移时，高位添补0。 13、对负数进行算术移位，当负数采用源码、补码、反码时，左移或右移时，低位或高位添补什么代码？ 对于源码，左移或右移时，低位或高位均添补0；对于补码：左移时，低位添补0，右移时高位添补1对于反码：左移或右移时，低位或高位均添补1； 14、什么是逻辑移位？ 逻辑移位是对无符号数的移位，由于无符号数不存在符号位，左移时，高位移丢，低位补零。右移时，低位移丢，高位补零。 15、加法和减法时，什么情况下可能发生溢出？如何简单判断发生溢出？ 1）正数加正数，正数减负数，负数加负数，负数减正数时，可能会发生溢出。2）如果参加操作的两个数符号相同（转换成补码的加法），其结果与源操作数符号不同，即为溢出。3）如果补码采用1位符号位，如果最高有效位的进位和符号位的进位不同，则发生溢出。 16、定点乘法运算可以使用加法和移位来实现吗？ 可以。 17、浮点加减运算基本按照哪几步来进行？ 1）对阶：使小数点对齐；2）尾数求和：将对阶后的两个尾数按照定点加减运算规则求和；3）规格化：尾数规格化；4）舍入：尾数右规时，丢失数值位；5）溢出判断：判断结果是否溢出。 18、如何判断浮点运算结果是否溢出？ 阶码是否超出了其表示范围。（使用2个符号位判溢出） 第七章 指令系统1、什么是机器指令？什么是指令系统？1）机器指令：每一条机器语言的语句；2）指令系统：全部机器指令的集合。 2、一条指令包含哪两个主要部分？请简要说明各部分作用。1）操作码：指明指令要完成的操作；2）地址码：指明指令要操作的数据或数据来源； 3、操作码长度有固定长度和可变长度两种，各自有什么优点？1）固定长度：便于硬件设计，指令译码时间短；2）可变长度：压缩了操作码平均长度； 4、指令中地址码中的地址可以是哪些设备的地址？可以是主存地址、寄存器地址或I/O设备的地址； 5、指令中地址的个数可以有几个？四地址、三地址、二地址、一地址以及零地址。 6、假设指令中有四个地址、三个地址、两个地址以及一个地址，各自需要访存几次？1）四地址：访存4次；2）三地址：访存4次；3）两地址：访存3次；4）一地址：访存2次； 7、当使用寄存器代替指令字中的地址码字段后，有哪些优点？1）扩大指令字的寻址范围；2）缩短指令字长；3）减少访存次数 8、数据在存储器中存储时，为什么要按照边界对齐？减少访存次数。 9、寻址方式包括哪两类？1）指令寻址：下一条将要执行的指令的指令地址；2）数据寻址：确定本指令的操作数地址。 10、什么是形式地址？什么是有效地址？1）形式地址：指令的地址码字段通常都不代表操作数的真实地址，成为形式地址，记为A；2）有效地址：操作数的真实地址，记为EA，由寻址特征和形式地址共同决定； 11、了解各种寻址方式的概念及根据形式地址形成有效地址的方式。立即寻址、直接寻址、隐含寻址、间接寻址、寄存器寻址、寄存器间接寻址、基址寻址（隐式或显式）、变址寻址、相对寻址、堆栈寻址 12、什么是RISC？什么是CISC？RISC：精简指令集；CISC：复杂指令集；]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2Fpython%2FDesignPattern%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2Freadme%2F</url>
    <content type="text"><![CDATA[当项目有几个部分不会影响代码的执行时，（例如日志记录）那么使用全局状态是可以接受的 避免使用全局状态的原因之一就是不想使 项目一部分中的代码修改全局状态 logger_class.py123456789101112131415161718192021222324252627282930313233# def log_message(msg):# with open( &apos;filename.log&apos;, &apos;a&apos; ) as log_file:# log_file.write(f&quot;&#123;msg&#125;\n&quot;) # 代替 format，python3新特性## log_message(&apos;save this for later&apos;)class Logger(): def __init__(self, filename): self.filename = filename def _write_log(self, level, msg): with open(self.filename , &apos;a&apos;) as log_file: log_file.write(&apos;&#123;0&#125; &#123;1&#125;\n&apos;.format(level, msg)) def critical(self, msg): self._write_log(&apos;CRUTICAL&apos;,msg) def error(self, msg): self._write_log(&apos;ERROR&apos;,msg) def warn(self, msg): self._write_log(&apos;WARN&apos;,msg) def info(self, msg): self._write_log(&apos;INFO&apos;, msg) def debug(self, msg): self._write_log(&apos;DEBUG&apos;,msg) main_script.py12345678910# import logger### for i in range(4):# logger.log_message(f&apos;log massger &#123;i&#125;&apos;)from logger_class import Loggerlogger_object = Logger(&apos;filename_class&apos;)logger_object.info( &apos;hahahaha&apos;) init函数并不是真正意义上的构造函数，init方法做的事情是在对象创建好之后初始化变量。真正创建实例的是new方法123456789101112131415161718class Singleton(object): &apos;&apos;&apos; 实现__new__方法 并在将一个类的实例绑定到类变量_instance上, 如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回 如果cls._instance不为None,直接返回cls._instance &apos;&apos;&apos; _instance = None def __new__(cls, *args, **kwargs): if cls._instance is None: cls._instance = object.__new__(cls, *args, **kwargs) return cls._instances1 = Singleton()s2 = Singleton()print(s1)print(s2)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IP地址]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2Fip%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[ip 地址就是 网络中的 地址信息 IPv4 与 IPIPVIPv4 格式 A.B.C.D 取值范围 0 ~ 255 2*32 个IPv6 格式 A:B:C:D:E:F:G:H 十六进制 2*128 个 16*32 公网 ip 和 内网 ip公网内 ip 地址由 inter NIC 负责。公有地址全球唯一私有地址 是非注册地址，用于组织机构内部使用 私有地址范围 A 类 IP 地址 ： 10.0.0.0 ~ 10.255.255.255 B 类 IP 地址 ： 172.16.0.0 ~ 172.31.255.255 C 类 IP 地址 ： 192.168.0.0 ~ 192.168.255.255 私有地址 不是由 internet分配的，不会出现在internet中。需要将私有 ip地址 转为 公网 IP 地址，与外部连接 （NAT）（私网地址访问互联网地址很方便，但互联网地址访问私有地址很困难） 内网的地址都是使用的路由器中的公共的公网ip来连接internet。 局域网内， IP 地址 是唯一的。但不同局域网， IP地址可以重复 localhost， 127.0.0.1 和 0.0.0.0 区别 localhost : 域名， windows默认将 localhost 指向127.0.0.1. 127.0.0.1 : 回环地址，凡是127 开头的 IP地址，都是回环地址（主机上发送给回环地址的数据 会自己接收，根本不传出去） 0.0.0.0 : 并不是一个真实的IP地址，他表示本机中所有的IPV4地址。监听本机所有的ip端口]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[给博客加日期]]></title>
    <url>%2Fpython%2F%E7%BB%99%E5%8D%9A%E5%AE%A2%E5%8A%A0%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[之前写文章，一直没有写时间，也没多大问题。后来换了一台电脑后，上传新文章全部乱了顺序。原来之前是按文件的创建时间排序，而我这复制过来的文件，创建时间几乎一样。所以博客乱了套。后来发现文件的修改时间还是以前的，于是给每篇文章，按修改时间添加了date。 代码如下12345678910111213141516171819import osimport sysimport timepath = r&apos;E:\WeiLai\OneDrive\blog\source\_posts&apos;for root, dir, files in os.walk(path): for file in files: full_path = os.path.join(root, file) if &apos;.md&apos; in full_path: mtime = os.stat(full_path).st_mtime file_modify_time = time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;, time.localtime(mtime)) date = &apos;date: &apos;+file_modify_time with open (full_path,&apos;r&apos;, encoding=&apos;UTF-8&apos;) as f: s = f.read() q = s.partition(&apos;tags:&apos;) t = q[0] + date +&apos;\n&apos; + q [1] + q[2] with open (full_path,&apos;w&apos;, encoding=&apos;UTF-8&apos;) as f: f.write(t)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql基础(1)]]></title>
    <url>%2FMySQL%2Fmysql%E5%9F%BA%E7%A1%80(1)%2F</url>
    <content type="text"><![CDATA[windows安装过程参考之前的文章https://www.jianshu.com/p/e35185ec3294 MySQL语法基础创建表– 为注释，不会被执行 使用查询语句建表12345678910111213141516171819202122232425-- 新建数据库CREATE DATABASE`school`;-- 使用数据库USE `school`;-- 创建表格-- id-- name-- nickname-- sex-- in_timeCREATE TABLE `students`( `id` INT NOT NULL AUTO_INCREMENT PRIMARY KEY, `name` VARCHAR(20) NOT NULL, `nickname` VARCHAR(20) NULL, `sex` CHAR(1) NULL, `in_time` DATETIME NULL) DEFAULT CHARSET &apos;UTF8&apos;;-- PRIMARY KEY 主键是用来唯一定位记录的-- 建议不使用任何业务相关的字段作为主键-- 在students表中添加一个class idALTER TABLE `school`.`students`ADD COLUMN `class id` int NULL AFTER `id`; 插入数据12345678910111213-- 插入students表 -- now():mysql中当前时间INSERT INTO `students` VALUE(1,&apos;weilai&apos;,&apos;imwl&apos;,&apos;男&apos;,now());-- 可以选择性插入INSERT INTO `students`(`name`,`nickname`,`sex`,`in_time`) VALUES(&apos;weilai&apos;,&apos;imwl&apos;,&apos;男&apos;,now());-- 插入多行数据INSERT INTO `students`(`name`,`nickname`,`sex`,`in_time`) VALUES(&apos;weilai2&apos;,&apos;imwl&apos;,&apos;男&apos;,now()),(&apos;weilai&apos;,&apos;imwl&apos;,&apos;男&apos;,now()),(&apos;weilai&apos;,&apos;imwl&apos;,&apos;男&apos;,now()),(&apos;weilai&apos;,&apos;imwl&apos;,&apos;男&apos;,now()); 查询数据1234567891011121314151617-- 查询数据库-- * 表示所有的SELECT * FROM `students`;-- 只查询name 和 nicknameSELECT `name`,`nickname` FROM `students`;-- 只查询name 和 nickname,同时性别为男的(查询表中不显示男)SELECT `name`,`nickname` FROM `students` WHERE `sex`=&apos;男&apos;;-- 在上面基础上id倒序SELECT `id`,`name`,`nickname` FROM `students` WHERE `sex`=&apos;男&apos;ORDER BY `id` DESC;-- 在上面基础上分页-- 0，2 : 从第1条数据开始，显示2条SELECT `id`,`name`,`nickname` FROM `students` WHERE `sex`=&apos;男&apos;ORDER BY `id` DESC LIMIT 0,2;-- 1,2 : 从第2条数据开始，显示2条SELECT `id`,`name`,`nickname` FROM `students` WHERE `sex`=&apos;男&apos;ORDER BY `id` DESC LIMIT 1,2; 修改数据where 很重要，不然就是改动整张表的数据123456789-- 修改-- 将所有的性别改女UPDATE `students` SET `sex`=&apos;女&apos;;-- 将name为weilai 的性别回男UPDATE `students` SET `sex`=&apos;男&apos; WHERE `name` = &apos;weilai&apos;;-- 将name为weilai 的性别为男,nickname改为没有昵称UPDATE `students` SET `sex`=&apos;男&apos;,`nickname`=&apos;没有昵称&apos; WHERE `name` = &apos;weilai&apos;;-- 将id &lt;3 的性别改为女UPDATE `students` SET `sex`=&apos;女&apos; WHERE `id` &lt; 3 删除数据 12345-- 删除数据 -- 删除students表中，性别为女的数据DELETE FROM `students` WHERE `sex` = &apos;女&apos;-- 删除students表中全部数据DELETE FROM `students` 444]]></content>
      <categories>
        <category>mysql学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql基础(2)]]></title>
    <url>%2FMySQL%2Fmysql%E5%9F%BA%E7%A1%80(2)%2F</url>
    <content type="text"><![CDATA[外键在students表中，通过class id的字段，可以把数据与另一张表（class）关联起来，这种列称为外键。 在students表中添加一个class id(id的后一列)12ALTER TABLE `school`.`students`ADD COLUMN `class id` int NULL AFTER `id`; 在数据库school中建立一个班级表1234CREATE TABLE `students`( `class id` INT NOT NULL AUTO_INCREMENT PRIMARY KEY, `name` VARCHAR(20) NOT NULL,) DEFAULT CHARSET &apos;UTF8&apos;; 添加/删除 外键12345678910111213ALTER TABLE `students`ADD CONSTRAINT `qe`-- 外键约束名称，随意取值 FOREIGN KEY (`class id`)REFERENCES `class` (`id`);-- ALTER TABLE `school`.`students` -- ADD FOREIGN KEY (`class id`) REFERENCES `school`.`class` (`id`);-- 删除外键ALTER TABLE `students`DROP FOREIGN KEY `qe`;删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现的 通过中间表，可以定义了一个“多对多”关系。 一对一：一个表的记录对应到另一个表的唯一一个记录 有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度 索引在查找记录的时候，想要获得非常快的速度，就需要使用索引123456ALTER TABLE `school`.`students` ADD INDEX `sex search`(`sex`); -- 名称为sex search，使用列 sex 的索引-- 也可以多列ALTER TABLE `school`.`students` ADD INDEX `search`(`sex`，`name`); 索引的效率取决于索引列的值是否散列，例如sex列，大约一半的记录值是男，另一半是女，因此，对该列创建索引就没有意义。123ALTER TABLE `school`.`students` DROP INDEX `sex search`;-- 删除索引 **假设name不重复，那么可以创建唯一索引1ADD UNIQUE INDEX `search`(`name`) **没索引，但对is_vaild进行唯一约束12ALTER TABLE studentsADD CONSTRAINT uni_name UNIQUE (is_vaild); 通过对数据库表创建索引，可以提高查询速度。 通过创建唯一索引，可以保证某一列的值具有唯一性。 数据库索引对于用户和应用程序来说都是透明的。 查询补充12345SELECT * FROM `students` WHERE `id` &gt;= 10 AND `sex` != &apos;女&apos; GROUP BY `id` HAVING `in_time` ORDER BY `id` DESC LIMIT 0,3;SELECT COUNT(*) num FROM `students` WHERE NOT `id` &gt;= 10 AND `sex` != &apos;女&apos; ORDER BY `id` DESC LIMIT 0,8 ;SELECT AVG(id) num FROM `students` WHERE NOT `id` &gt;= 10 AND `sex` != &apos;女&apos; ORDER BY `id` DESC LIMIT 0,8 ; 4]]></content>
      <categories>
        <category>mysql学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql基础(3)]]></title>
    <url>%2FMySQL%2Fmysql%E5%9F%BA%E7%A1%80(3)%2F</url>
    <content type="text"><![CDATA[多表联查 使用多表查询可以获取M x N行记录（M,N为两个表各自的行数）多表查询的结果集可能非常巨大，要小心使用。 内连接123456789101112131415mysql&gt; SELECT s.id, s.name,`s`.`class id`, s.nickname,s.sex,c.name,s.in_time,s.is_vaild FROM students s INNER JOIN class c ON `s`.`class id` = c.id;+----+---------+----------+-----------+------+--------------+---------------------+----------+| id | name | class id | nickname | sex | name | in_time | is_vaild |+----+---------+----------+-----------+------+--------------+---------------------+----------+| 7 | weilai | 202 | imwl | 男 | 二年二班 | 2018-12-27 22:05:41 | 1 || 8 | weilai | 202 | imwl | 男 | 二年二班 | 2018-12-27 22:05:41 | 2 || 9 | weilai | 202 | imwl | 男 | 二年二班 | 2018-12-27 22:05:41 | NULL || 10 | weilai2 | 201 | imwl | 男 | 二年一班 | 2018-12-27 22:05:41 | NULL || 12 | name1 | 201 | nickname1 | 女 | 二年一班 | NULL | NULL || 13 | name2 | 201 | nickname2 | 男 | 二年一班 | NULL | NULL || 19 | 2 | 301 | i | 男 | 三年一班 | 2019-02-27 12:02:04 | NULL || 20 | 3 | 301 | m | 女 | 三年一班 | 2019-02-27 12:02:04 | NULL || 21 | 4 | 302 | w | 男 | 三年二班 | 2019-02-27 12:02:04 | NULL || 22 | 5 | 302 | l | 男 | 三年二班 | 2019-02-27 12:02:04 | NULL |+----+---------+----------+-----------+------+--------------+---------------------+----------+ INNER JOIN查询的写法是： 先确定主表，仍然使用FROM &lt;表1&gt;的语法；再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法；然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是s.class id = c.id，表示students表的class id列与class表的id列相同的行需要连接；可选：加上WHERE子句、ORDER BY等子句。 小结JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上； INNER JOIN是最常用的一种JOIN查询，它的语法是SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;； JOIN查询仍然可以使用WHERE条件和ORDER BY排序。 补充知识假设查询语句是： 1SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2; 我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录： LEFT OUTER JOIN是选出左表存在的记录： RIGHT OUTER JOIN是选出右表存在的记录： FULL OUTER JOIN则是选出左右表都存在的记录：]]></content>
      <categories>
        <category>mysql学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python操作mysql(ORM)]]></title>
    <url>%2FMySQL%2Fpython%E6%93%8D%E4%BD%9Cmysql(ORM)%2F</url>
    <content type="text"><![CDATA[使用SQLAlchemy 安装方法pip install SQLAlchemy 更多内容参考flask鱼书项目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127from sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_base from sqlalchemy import Column, Integer, String ,DateTime, Boolean# 连接数据库engine = create_engine(&apos;mysql://root:password@localhost:3306/school?charset=utf8&apos;)## 编码问题# # 获取基类Base = declarative_base()class News(Base): # 继承基类 __tablename__ = &apos;students1&apos; id = Column(Integer, primary_key = True) nickname = Column(String(20)) name = Column(String(20), nullable = False) sex = Column(String(1)) in_time = Column(DateTime) is_vaild = Column(Boolean) idcard = Column(Integer, unique = True) News.metadata.create_all(engine) # 创建表格## 新增数据from sqlalchemy.orm import sessionmakerSession = sessionmaker(bind=engine)class OrmTest(object): def __init__(self): self.session = Session() def add_one(self): new_obj = News( nickname = &apos;123&apos;, name = &apos;321&apos;, sex = &apos;男&apos;, ) self.session.add(new_obj) self.session.commit() return new_obj def add_more(self): new_obj = News( nickname = &apos;123&apos;, name = &apos;321&apos;, sex = &apos;男&apos;, ) new_obj2 = News( nickname = &apos;wei&apos;, name = &apos;lai&apos;, sex = &apos;女&apos;, ) self.session.add_all([new_obj, new_obj2]) self.session.commit() return new_obj## 查询数据 def get_one(self): return self.session.query(News).get(10) # get 是选id为2的 def get_more(self): return self.session.query(News).filter_by(is_vaild=True)## 修改数据## 将一条当作多条的一种情况 def update_data(self): data_list = self.session.query(News).filter(News.id &gt;= 5) for item in data_list: if item: item.is_vaild = 0 self.session.add(item) # 加入 self.session.commit() # 提交## filter 与 filter_by 的区别## 删除数据 def delete_data(self): data = self.session.query(News).get(8) if data: self.session.delete(data) self.session.commit() else: return False def delete_data_more(self): delete_list = self.session.query(News).filter(News.id &lt;= 5) for item in delete_list: if item: self.session.delete(item) else: return False self.session.commit() def main(): obj = OrmTest() obj.add_one() obj.add_more() data = obj.get_one() ## 防止查询失误 if data: print(&apos;ID:&#123;0&#125; &#123;1&#125;&apos;.format(data.id,data.sex)) else: print(&apos;Not exist&apos;) data_more = obj.get_more() print(data_more.count()) # 计数 for new_obj in data_more: print(&apos;ID:&#123;0&#125; &#123;1&#125; &#123;2&#125; &#123;3&#125;&apos;.format(new_obj.id,new_obj.sex,new_obj.name,new_obj.nickname)) obj.update_data() print(&apos;数据修改成功&apos;) obj.delete_data() print(&apos;数据删除成功&apos;) obj.delete_data_more()if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>mysql学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python操作mysql（增删改查）]]></title>
    <url>%2FMySQL%2Fpython%E6%93%8D%E4%BD%9Cmysql(%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5)%2F</url>
    <content type="text"><![CDATA[使用mysqlclient先安装mysqlclient网址：https://pypi.org/project/mysqlclient/python中可使用pip安装，pip install mysqlclient 也可以使用别的方法，详细可查看之前的文章：爬取百度百科词条写入数据库 python操作mysql查询数据1234567891011121314151617181920import MySQLdb# 获取连接connection = MySQLdb.connect( host = &apos;localhost&apos;, user = &apos;root&apos;, password = &apos;password&apos;, db = &apos;school&apos;, charset = &apos;utf8mb4&apos;, port = 3306 # 默认3306，可不填port)# 获取数据cursor = connection.cursor()cursor.execute(&apos;SELECT * FROM `students`ORDER BY `in_time`DESC;&apos;) result = cursor.fetchone() # 获取第一条数据print (result)# 关闭连接connection.close() 可能会出现异常，所以改写12345678910111213141516171819202122232425import MySQLdbtry:# 获取连接 connection = MySQLdb.connect( host = &apos;localhost&apos;, user = &apos;root&apos;, password = &apos;password&apos;, db = &apos;school&apos;, charset = &apos;utf8mb4&apos;, port = 3306 # 默认3306，可不填port ) # 获取数据 cursor = connection.cursor() cursor.execute(&apos;SELECT * FROM `students`ORDER BY `in_time`DESC;&apos;) result = cursor.fetchone() # 获取第一条数据 print (result)except MySQLdb.Error as e: print(&apos;Error : %s &apos; % e)finally: # 关闭连接 connection.close() 因为这个操作是所有都有的，所以封装成一个对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import MySQLdbclass MysqlSearch: def __init__(self): self.get_connection() def get_connection(self): try: self.connection = MySQLdb.connect( host = &apos;localhost&apos;, user = &apos;root&apos;, password = &apos;password&apos;, db = &apos;school&apos;, charset = &apos;utf8mb4&apos;, port = 3306 # 默认3306，可不填port ) except MySQLdb.Error as e: print(&apos;Error : %s &apos; % e) def close_connection(self): try: if self.connection: self.connection.close() except MySQLdb.Error as e: print(&apos;Error : %s &apos; % e) def get_one(self): # 获取会话指针 cursor = self.connection.cursor() # 准备sql sql = &apos;SELECT * FROM `students`WHERE`name`=%s ORDER BY `in_time`DESC;&apos; # 执行sql cursor.execute(sql,(&apos;weilai&apos;,)) # print(cursor.description) ## ((&apos;id&apos;, 3, 1, 11, 11, 0, 0), (&apos;name&apos;, 253, 6, 80, 80, 0, 0), ## (&apos;nickname&apos;, 253, 4, 80, 80, 0, 1), (&apos;sex&apos;, 254, 3, 4, 4, 0, 1), ## (&apos;in_time&apos;, 12, 19, 19, 19, 0, 1)) ## 获得一条结果 # a = [k[0] for k in cursor.description], ## a = [&apos;id&apos;, &apos;name&apos;, &apos;nickname&apos;, &apos;sex&apos;, &apos;in_time&apos;] # b = [k[0] for k in cursor.description],cursor.fetchone() ## ([&apos;id&apos;, &apos;name&apos;, &apos;nickname&apos;, &apos;sex&apos;, &apos;in_time&apos;], ## (7, &apos;weilai&apos;, &apos;imwl&apos;, &apos;男&apos;, datetime.datetime(2018, 12, 27, 22, 5, 41))) result = dict(zip([k[0] for k in cursor.description],cursor.fetchone())) # 关闭 cursor 和连接 cursor.close() self.close_connection() return result def get_more(self): cursor = self.connection.cursor() sql = &apos;SELECT * FROM `students`WHERE`name`=%s ORDER BY `in_time`DESC;&apos; cursor.execute(sql,(&apos;weilai&apos;,)) result = [dict(zip([k[0] for k in cursor.description],row)) for row in cursor.fetchall()] # print(result) # [&#123;&apos;id&apos;: 7, &apos;name&apos;: &apos;weilai&apos;, &apos;nickname&apos;: &apos;imwl&apos;, &apos;sex&apos;: &apos;男&apos;, &apos;in_time&apos;: datetime.datetime(2018, 12, 27, 22, 5, 41)&#125;, # &#123;&apos;id&apos;: 8, &apos;name&apos;:&apos;weilai&apos;, &apos;nickname&apos;: &apos;imwl&apos;, &apos;sex&apos;: &apos;男&apos;, &apos;in_time&apos;: datetime.datetime(2018, 12, 27, 22, 5, 41)&#125;, # &#123;&apos;id&apos;: 9, &apos;name&apos;: &apos;weilai&apos;, &apos;nickname&apos;: &apos;imwl&apos;, &apos;sex&apos;: &apos;男&apos;, &apos;in_time&apos;: datetime.datetime(2018, 12, 27, 22, 5, 41)&#125;] cursor.close() self.close_connection() return resultdef main(): obj = MysqlSearch() # a = obj.get_one() # print(a) # print(a[&apos;id&apos;]) b = obj.get_more() for item in b: print(item)if __name__ == &apos;__main__&apos;: main()# zip函数&apos;&apos;&apos;zip() 将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，元素个数与最短的一致&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b) # 返回一个对象&gt;&gt;&gt; zipped&lt;zip object at 0x103abc288&gt;&gt;&gt;&gt; list(zipped) # list() 转换为列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; list(zip(a,c)) # 元素个数与最短的列表一致[(1, 4), (2, 5), (3, 6)] &gt;&gt;&gt; a1, a2 = zip(*zip(a,b)) # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式&gt;&gt;&gt; list(a1)[1, 2, 3]&gt;&gt;&gt; list(a2)[4, 5, 6]&apos;&apos;&apos; ** 补充(分页查询)：12345678910111213141516def get_more_by_pages(self, page, page_size): # 分页查询数据 offset = (page -1) * page_size cursor = self.connection.cursor() sql = &apos;SELECT * FROM `students`WHERE`name`=%s ORDER BY `in_time`DESC LIMIT %s , %s;&apos; cursor.execute(sql,(&apos;weilai&apos;, offset, page_size)) result = [dict(zip([k[0] for k in cursor.description],row)) for row in cursor.fetchall()] # print(result) # [&#123;&apos;id&apos;: 7, &apos;name&apos;: &apos;weilai&apos;, &apos;nickname&apos;: &apos;imwl&apos;, &apos;sex&apos;: &apos;男&apos;, &apos;in_time&apos;: datetime.datetime(2018, 12, 27, 22, 5, 41)&#125;, # &#123;&apos;id&apos;: 8, &apos;name&apos;:&apos;weilai&apos;, &apos;nickname&apos;: &apos;imwl&apos;, &apos;sex&apos;: &apos;男&apos;, &apos;in_time&apos;: datetime.datetime(2018, 12, 27, 22, 5, 41)&#125;, # &#123;&apos;id&apos;: 9, &apos;name&apos;: &apos;weilai&apos;, &apos;nickname&apos;: &apos;imwl&apos;, &apos;sex&apos;: &apos;男&apos;, &apos;in_time&apos;: datetime.datetime(2018, 12, 27, 22, 5, 41)&#125;] cursor.close() self.close_connection() return result 新增/修改数据到数据库出现问题不应该提交 12345678910111213141516171819202122def add_one(self): # 准备SQL try: sql = ( &quot;INSERT INTO `students` (`name`,`nickname`,`sex`,`in_time`) VALUE&quot; &quot;(%s,%s,%s,%s);&quot; ) cursor = self.connection.cursor() # 可以提交多条 cursor.execute(sql,(&apos;name1&apos;, &apos;nickname1&apos;, &apos;男&apos;, None)) cursor.execute(sql,(&apos;name2&apos;, &apos;nickname2&apos;, &apos;男&apos;, &apos;haha&apos;)) # 提交事务 self.connection.commit() # 关闭cursor和连接 cursor.close() except MySQLdb.Error as e: print(&apos;Error : %s &apos; % e) self.connection.rollback() self.close_connection()]]></content>
      <categories>
        <category>mysql学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用MySQL]]></title>
    <url>%2FMySQL%2F%E4%BD%BF%E7%94%A8MySQL%2F</url>
    <content type="text"><![CDATA[示例数据 https://codeload.github.com/datacharmer/test_db/zip/master导入 eg: mysql -u root -p &lt; employees.sql 连接到 MySQL \g 输出水平显示 \G 输出垂直显示 12mysql -h localhost -P 3306 -u root -p - 连接到mysqlALTER USER `root`@`localhost` IDENTIFIED BY &apos;password&apos;; - 修改密码 创建数据库数据库是许多表的集合，数据库服务器可以容纳许多这样的数据库 数据库服务器 → 数据库 → 表（由列定义） → 行 CREATE/ALTER/DROP 数据库对象（数据库和表） 称为 数据定义语言（DDL）操作 INSERT/UPDATE/DELETE /SELECT 称为 数据操作语言（DML） 前三项也称 写，SELECT 也称 读 1234567CREATE DATABASE company; - 创建数据库 建议都用 ``CREATE DATABASE `my.contacts`; - 用反标记字符 ``（当数据库和表含特殊字符时） USE `company`; - 使用 company 数据库mysql -u root -p company - 直接连接到 company 数据库SELECT DATABASE(); - 查找连接到的数据库SHOW DATABASES; - 查找有权访问的所有数据库SHOW VARIABLES LIKE &apos;company&apos;; - 获取当前的数据目录 sudo ls -lhtr /usr/lcoal/mysql/data/ 创建表1234567891011CREATE TABLE IF NOT EXISITS `company`.`customers`(`id` int unsigned AUTO_INCREMENT PRIMARY KEY,`first_name` varchar(20),`last_name` varchar(20),`country` varchar(20)) ENGINE=InnoDB DEFAULT CHARSET=utf8;SHOW TABLES - 查看所有表SHOW CREATE TABLE customers\G - 查看表结构DESC customers;CREATE TABLE new_costomers Like customers - 克隆表结构 增删改查参考 删除表的所有行最快的方式 TRUNCATE TABLE customers DDL操作。 创建用户除非是localhost的管理任务等，一般不推荐使用root 用户连接到 mysql执行语句]]></content>
      <categories>
        <category>mysql学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库]]></title>
    <url>%2FMySQL%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[数据库分类 关系型数据库 （MySQL,SQLServer,MariaDB,ORACLE等） 非关系型数据库 (mongoDB,redis等） 非关系型数据库分类1 . 文档型2 . key-value型3 . 列式数据库4 . 图形数据库]]></content>
      <categories>
        <category>mysql学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017-2018年总结(初版)]]></title>
    <url>%2F%E9%9A%8F%E7%AC%94%2F2017-2018%20%E6%80%BB%E7%BB%93(%E5%88%9D%E7%89%88)%2F</url>
    <content type="text"><![CDATA[本打算写一个2018年总结，想了一下，觉得还是从学生时代结束后开始写比较好。 从2017-07到现在2019-01，没想到竟然已经18个月了。这18个月，真的算是，对自己一个磨练。所以之前元旦所说的空空如也，并不完全正确，至少在某些方面，确实还有点进步。(2018-10应该算是一个比较重要的分水岭吧) 粗略分为4个方面工作方面准确来说，目前从事过两份工作。 2017-08 至 2017-12。毕业后在某研究所工作。刚开始得到这个工作机会的时候还是挺开心的，毕竟做毕设拿院优，他们的软件占很大成分；同事之间相处也很和睦。主要工作就是给客户解决软件以及设计上的问题，时常需要出差。这工作太闲了，所以当时一直在胡思乱想。后来，我认真思考了一下以后的出路，如果继续这一行，好像只有去做设计了，而我对设计确实没什么兴趣。(一到冬天我就不想呆在济南的原因,可能就是因为雾霾吧。那个地方雾霾比济南还严重，所以就提出了辞职。） 2018-04至2019-01。亲戚介绍了一份工作。当时我其实不想去的，但当时已经在家闲置了快3个月。加上确实很迷茫，不知道以后该干嘛。还有当时说先去看看，然后就过去了。刚开始抱着学习技术的态度去的，后来发现自己多虑了。我从没有想过会从事这么久，期间真的无数次想辞职。刚开始碍于情面，所以不曾开口。后来又因为惰性，习惯了。目前看来，从事这么久的主要原因:一是确实很闲，平常帮师傅们打打下手啥的；二是旅游耗费了太多钱财，弄得经济困难；三是，国庆后，开始认真学习python，有时间学习。 学习方面第一个工作阶段，确实很充实，每天都在自学（职业相关的），即使现在对我而言一点意义都没有了。 第二个工作阶段，到国庆前，即使很闲，但也基本没有主动学习过；国庆后开始感觉自己的学习效率在逐渐提高，也有学习的意识了。在此期间，搭建了自己的个人博客来记录，网址为：https://itswl.github.io 生活方面没有以前那么慵懒了，变得更加的独立。 17年的时候，想着爬华山，看兵马俑，逛陕博，但又因为一个人，懒得行动。心想着不急，终究会去的，结果离开了也未曾去过。 今年得知，张家界离这里不远。（以前外公曾说，等我们初中的时候，就带我们去张家界玩，结果到现在还没带我们去。我都不知道是不是他不记得了，我中秋的时候回去也忘记提这件事了。）然后五一期间，就一个人去了。去了发现凤凰也不远，于是也去了凤凰。算是一个开端吧。 当然还有一个特别重大的事：我从2018-8到现在一滴可乐都没喝过。我并不觉得可乐会带来什么危害，不喝可乐，只是单纯的为了克制一下自己那种欲望。 思想上面我觉得一个人最大的进步就是思想上面的，当然只是我个人现在的想法。挺怀恋刚毕业的时候，自信，洒脱。也享受孤独的感觉，能在元旦的晚上冻成狗，也能在群处怡然自得。更加包容多元，更加心平气和。 总结既然是总结，那么总结一下。不好的地方:浪费了太多时间，当断不断。 好的地方：戒掉了可乐，开始养生，有了学习的意识。变得更加的独立，也不会感到孤独。 期待:2019，能够真的成长吧 补(一)读万卷书，行万里路，真的是很有用的话。行，使我开阔；读书使我静下心。 补(二)今年春运，本着学习爬虫看一下12306，结果还是使用了他人的软件，帮别人买了10多张张春运票，也能算是比较有成就感吧。 补(三)]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬虫整理（四）多进程分布式与异步]]></title>
    <url>%2Fpython%2F%E7%88%AC%E8%99%AB%E6%95%B4%E7%90%86-(%E5%9B%9B)-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[有的时候，爬取速度不快，就要想一些其他的办法。比如多进程多线程以及异步。不过一般的网站都会对其有限制，所以还得看实际情况具体来选取爬虫方式。爬虫并不复杂。爬虫更关键的是在，爬虫，反爬虫和反反爬虫这一块。 多进程分布式与异步的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from urllib.request import urlopen, urljoinfrom bs4 import BeautifulSoupimport multiprocessing as mpimport reimport timedef crawl(url): response = urlopen(url) time.sleep(0.1) # slightly delay for downloading return response.read().decode()def parse(html): soup = BeautifulSoup(html, &apos;lxml&apos;) urls = soup.find_all(&apos;a&apos;, &#123;&quot;href&quot;: re.compile(&apos;^/.+?/$&apos;)&#125;) title = soup.find(&apos;h1&apos;).get_text().strip() page_urls = set([urljoin(base_url, url[&apos;href&apos;]) for url in urls]) # remove duplication url = soup.find(&apos;meta&apos;, &#123;&apos;property&apos;: &quot;og:url&quot;&#125;)[&apos;content&apos;] return title, page_urls, urlif __name__ == &apos;__main__&apos;: base_url = &apos;https://morvanzhou.github.io/&apos; # base_url = &quot;http://127.0.0.1:4000/&quot; # DON&apos;T OVER CRAWL THE WEBSITE OR YOU MAY NEVER VISIT AGAIN if base_url != &quot;http://127.0.0.1:4000/&quot;: restricted_crawl = True else: restricted_crawl = False unseen = set([base_url,]) seen = set() pool = mp.Pool(4) # number strongly affected count, t1 = 1, time.time() while len(unseen) != 0: # still get some url to visit if restricted_crawl and len(seen) &gt; 20: break print(&apos;\nDistributed Crawling...&apos;) crawl_jobs = [pool.apply_async(crawl, args=(url,)) for url in unseen] htmls = [j.get() for j in crawl_jobs] # request connection htmls = [h for h in htmls if h is not None] # remove None print(&apos;\nDistributed Parsing...&apos;) parse_jobs = [pool.apply_async(parse, args=(html,)) for html in htmls] results = [j.get() for j in parse_jobs] # parse html print(&apos;\nAnalysing...&apos;) seen.update(unseen) unseen.clear() for title, page_urls, url in results: print(count, title, url) count += 1 unseen.update(page_urls - seen) print(&apos;Total time: %.1f s&apos; % (time.time()-t1, )) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import aiohttpimport asyncioimport timefrom bs4 import BeautifulSoupfrom urllib.request import urljoinimport reimport multiprocessing as mpbase_url = &quot;https://morvanzhou.github.io/&quot;# base_url = &quot;http://127.0.0.1:4000/&quot;# DON&apos;T OVER CRAWL THE WEBSITE OR YOU MAY NEVER VISIT AGAINif base_url != &quot;http://127.0.0.1:4000/&quot;: restricted_crawl = Trueelse: restricted_crawl = Falseseen = set()unseen = set([base_url])def parse(html): soup = BeautifulSoup(html, &apos;lxml&apos;) urls = soup.find_all(&apos;a&apos;, &#123;&quot;href&quot;: re.compile(&apos;^/.+?/$&apos;)&#125;) title = soup.find(&apos;h1&apos;).get_text().strip() page_urls = set([urljoin(base_url, url[&apos;href&apos;]) for url in urls]) url = soup.find(&apos;meta&apos;, &#123;&apos;property&apos;: &quot;og:url&quot;&#125;)[&apos;content&apos;] return title, page_urls, urlasync def crawl(url, session): r = await session.get(url) html = await r.text() await asyncio.sleep(0.1) # slightly delay for downloading return htmlasync def main(loop): pool = mp.Pool(2) # slightly affected async with aiohttp.ClientSession() as session: count = 1 while len(unseen) != 0: if restricted_crawl and len(seen) &gt; 20: break tasks = [loop.create_task(crawl(url, session)) for url in unseen] finished, unfinished = await asyncio.wait(tasks) htmls = [f.result() for f in finished] parse_jobs = [pool.apply_async(parse, args=(html,)) for html in htmls] results = [j.get() for j in parse_jobs] seen.update(unseen) unseen.clear() for title, page_urls, url in results: print(count, title, url) unseen.update(page_urls - seen) count += 1if __name__ == &quot;__main__&quot;: t1 = time.time() loop = asyncio.get_event_loop() loop.run_until_complete(main(loop)) loop.close() print(&quot;Async total time: &quot;, time.time() - t1)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬取百度百科词条写入数据库]]></title>
    <url>%2Fpython%2F%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91%E8%AF%8D%E6%9D%A1%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[这是在把百度百科上从一个词条中，随机选择一个关键字，然后从这个关键词的词条中，继续这样一个步骤，同时保存到数据库。如果遇到某词条下没有其他关键字，就会返回到上一个关键字处，目前有一个问题，就是两条关键词都只有一个的话，会进入循环。数据库中可以设置url唯一数据库这一块的操作，得先安装pymysql。直接使用pip安装即可。随机数random是python自带的。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from bs4 import BeautifulSoupfrom urllib.request import urlopenimport reimport randomimport pymysql.cursors # 数据库base_url = &quot;https://baike.baidu.com&quot;his = [&quot;/item/%E5%8F%B2%E8%AE%B0&quot;]for i in range(1000): # dealing with Chinese symbols url = base_url + his[-1] html = urlopen(url).read().decode(&apos;utf-8&apos;) soup = BeautifulSoup(html, features=&apos;lxml&apos;) print(i, soup.find(&apos;h1&apos;).get_text(), &apos; url: &apos;, url) # find valid urls sub_urls = soup.find_all(&quot;a&quot;, &#123;&quot;target&quot;: &quot;_blank&quot;, &quot;href&quot;: re.compile(&quot;/item/(%.&#123;2&#125;)+$&quot;)&#125;) if len(sub_urls) != 0: his.append(random.sample(sub_urls, 1)[0][&apos;href&apos;]) else: # no valid sub link found his.pop()# 链接数据库 connection = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, password = &apos;password&apos;, db = &apos;baikeurl&apos;, charset = &apos;utf8mb4&apos;, ) try: # 获取会话指针 with connection.cursor() as cursor: # 创建sql 语句 sql = &apos;insert into `urls`(`urlname`,`urlhref`)values(%s,%s)&apos; # 执行sql 语句 cursor.execute(sql,(soup.find(&apos;h1&apos;).get_text(),url)) # 提交 connection.commit() except: pass finally: connection.close() 读取数据库12345678910111213141516171819202122import pymysql.cursorsconnection = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, password = &apos;password&apos;, db = &apos;baikeurl&apos;, charset = &apos;utf8mb4&apos;, )try: # 获取会话指针 with connection.cursor() as cursor: # 查询sql 语句 sql = &apos;select `urlname` , `urlhref` from `urls` where `id` is not null&apos; # 执行sql 语句 conut = cursor.execute(sql) print(conut) # result = cursor.fetchall() # print(result)finally: connection.close()]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读取TXT_PDF]]></title>
    <url>%2Fpython%2F%E8%AF%BB%E5%8F%96TXT_PDF%2F</url>
    <content type="text"><![CDATA[这个是我学习爬取TXT和PDF的代码，前半段是读取TXT，后半段是读取PDF，PDF中使用了第三方库，pdfminer3k,使用pip安装即可。pip install pdfminer3k。PDF其中注释掉的为读取网络上的PDF文档。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from urllib import requestfrom pdfminer.pdfdevice import PDFDevicefrom pdfminer.pdfinterp import PDFPageInterpreter, PDFResourceManagerfrom pdfminer.pdfparser import PDFDocument, PDFParserfrom pdfminer.converter import PDFPageAggregatorfrom pdfminer.layout import LAParams# html = request.urlopen(# &apos;https://en.wikipedia.org/robots.txt&apos;# ).read().decode(&apos;utf-8&apos;)# print(html) # 读取txt# fp = open(&apos;./practice/byte-of-python-chinese-edition.pdf&apos;,&apos;rb&apos;) # 获取文档对象fp = request.urlopen(&apos;https://q.stock.sohu.com/newpdf/201831703172.pdf&apos;) # 读取网络pdfparser = PDFParser(fp) # 创建一个与文档关联的解释器doc = PDFDocument() # 文档对象# 链接解释器和文档对象parser.set_document(doc)doc.set_parser(parser)# 初始化文档doc.initialize() # 可接收文档密码resource = PDFResourceManager() # 创建PDF资源管理器laparam = LAParams() # 参数分析器device = PDFPageAggregator(resource,laparams=laparam)# 创建一个聚合器interpreter = PDFPageInterpreter(resource,device)# 创建 PDF页面解释器# 使用文档对象得到页面的集合for page in doc.get_pages(): # 使用页面解释器来读取 interpreter.process_page(page) # 使用聚合器来获取内容 layout = device.get_result() for out in layout: if hasattr(out,&apos;get_text&apos;): # 有没有这个属性 print(out.get_text())]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬虫整理（五）slenium]]></title>
    <url>%2Fpython%2F%E7%88%AC%E8%99%AB%E6%95%B4%E7%90%86-(%E4%BA%94)--slenium%2F</url>
    <content type="text"><![CDATA[首先使用pip安装并加入环境变量123456789101112131415161718192021222324from selenium import webdriverfrom selenium.webdriver.chrome.options import Options# firefox plugin# https://askubuntu.com/questions/870530/how-to-install-geckodriver-in-ubuntu# hide browser windowchrome_options = Options()chrome_options.add_argument(&quot;--headless&quot;) # define headless# add the option when creating driverdriver = webdriver.Chrome(chrome_options=chrome_options)driver.get(&quot;https://morvanzhou.github.io/&quot;)driver.find_element_by_xpath(u&quot;//img[@alt=&apos;强化学习 (Reinforcement Learning)&apos;]&quot;).click()driver.find_element_by_link_text(&quot;About&quot;).click()driver.find_element_by_link_text(u&quot;赞助&quot;).click()driver.find_element_by_link_text(u&quot;教程 ▾&quot;).click()driver.find_element_by_link_text(u&quot;数据处理 ▾&quot;).click()driver.find_element_by_link_text(u&quot;网页爬虫&quot;).click()print(driver.page_source[:200])driver.get_screenshot_as_file(&quot;./img/sreenshot2.png&quot;)driver.close()print(&apos;finish&apos;)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PandaTV爬取主播人气并排序]]></title>
    <url>%2Fpython%2FPandaTV%E7%88%AC%E5%8F%96%E4%B8%BB%E6%92%AD%E4%BA%BA%E6%B0%94%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[很早前，第一次爬虫，就用的re加urllib原生爬虫。这次重新来爬取一次PandaTV主播人气排名，来练一下手。毕竟看直播嘛，颜值区更喜欢一点。就以颜值区为例，颜值区url = ‘https://www.panda.tv/cate/yzdr&#39;。结果保存在运行目录下的`PandaTV主播人气排名.md`中。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import refrom urllib import requestimport osimport datetime class Spider(): url = &apos;https://www.panda.tv/all&apos; root_pattern =&apos;&lt;div class=&quot;video-info&quot;&gt;[\s\S]*?&lt;/div&gt;&apos; # 因为number和name均在其下 name_pattern = &apos;&lt;span class=&quot;video-nickname&quot; title=&quot;([\s\S]*?)&quot;&gt;\n&apos; number_pattern = &apos;&lt;span class=&quot;video-number&quot;&gt;&lt;i class=&quot;ricon ricon-eye&quot;&gt;&lt;/i&gt;([\s\S]*?)&lt;/span&gt;\n&apos; # 获取htmls数据 def __fetch_content(self): r = request.Request(Spider.url) r.add_header(&apos;User-Agent&apos;,&apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/18.17758&apos;) r = request.urlopen(r) # 打开网页 request 下面的urlopen方法 htmls = r.read() # 读取 htmls = str(htmls, encoding=&apos;utf-8&apos;) # 转为str return htmls # 建立一个list为: [&#123;&apos;name&apos;:name,&apos;number&apos;: number&#125;,&#123;&apos;name&apos;:name,&apos;number&apos;: number&#125;,...] def __analysis(self, htmls): root_html = re.findall(Spider.root_pattern, htmls) # 抓取所有的&lt;div class=&quot;video-info&quot;&gt;[\s\S]*?&lt;/div&gt; anchors = [] for html in root_html: # 将&lt;div class=&quot;video-info&quot;&gt;[\s\S]*?&lt;/div&gt;一个一个提取出来 name = re.findall(Spider.name_pattern, html) # 将一个的name提取出来 ，格式为[str] number = re.findall(Spider.number_pattern, html) # 将一个的number提取出来,格式为[str] anchor = &#123;&apos;name&apos;: name, &apos;number&apos;: number&#125; # 将name 和 number 对应起来，组成一个字典 anchors.append(anchor) # 将这个字典添加到 anchors列表中 return anchors # def __refine(self, anchors): l = lambda anchors: &#123; &apos;name&apos;: anchors[&apos;name&apos;][0], #strip() 内置函数，去掉空格 &apos;number&apos;: anchors[&apos;number&apos;][0] # 取出字符串 &#125; return map(l, anchors) #&#123;[&apos;name&apos;:&apos;xxx&apos;,&apos;number&apos;:&apos;yyy&apos;]&#125;,&#123;[&apos;name&apos;:&apos;xxx1&apos;,&apos;number&apos;:&apos;yyy1&apos;]&#125;... def __sort(self, anchors): #排序 anchors = sorted(anchors, key=self.__sort_seed, reverse=True) #reverse=True表示降序 return anchors #anchor[&apos;number&apos;]中的转为float格式，按转化后的数字大小进行排序 def __sort_seed(self, anchor): # 排序调用的方法 r = anchor[&apos;number&apos;] if &apos;万&apos; in r: r = r.strip(&apos;万&apos;) r = float(r) r *= 10000 number = float(r) return number def __show(self, anchors): # 显示格式 time_stamp = datetime.datetime.now() b = str(time_stamp.strftime(&apos;%Y.%m.%d - %H:%M:%S&apos;) ) with open(&apos;./PandaTV主播人气排名.md&apos;, &apos;a&apos;) as f: f.write(&apos;\n\n&apos;) f.write(b) f.write(&apos;\n\n&apos;) for rank in range(0, len(anchors)): a = str((&apos;rank &apos; + str(rank + 1) + &apos; &apos; #加排名，因为是从0开始 &apos;主播姓名&apos; + &apos;:&apos; + anchors[rank][&apos;name&apos;] + &apos; &apos; + &apos;观看人数:&apos;+anchors[rank][&apos;number&apos;])) with open(&apos;./PandaTV主播人气排名.md&apos;, &apos;a&apos;) as f: f.write(a) f.write(&apos;\n&apos;) def go(self): #主方法 htmls = self.__fetch_content() anchors = self.__analysis(htmls) anchors = list(self.__refine(anchors)) anchors = self.__sort(anchors) self.__show(anchors) spider = Spider()spider.go() 附带本次成果]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[慕课网数据采集总结]]></title>
    <url>%2Fpython%2F%E6%85%95%E8%AF%BE%E7%BD%91%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/video/12637 课程地址]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬虫整理（一）使用re和urllib]]></title>
    <url>%2Fpython%2F%E7%88%AC%E8%99%AB%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E4%BD%BF%E7%94%A8re%E5%92%8Curllib%2F</url>
    <content type="text"><![CDATA[完整代码123456789101112131415161718192021from urllib.request import urlopenhtml = urlopen( &quot;https://morvanzhou.github.io/static/scraping/basic-structure.html&quot;).read( ).decode(&apos;utf-8&apos;)print(html)import reres = re.findall(r&quot;&lt;title&gt;(.+?)&lt;/title&gt;&quot;, html)print(&quot;\nPage title is: &quot;, res[0])res = re.findall(r&quot;&lt;p&gt;(.*?)&lt;/p&gt;&quot;, html, flags=re.DOTALL) print(&quot;\nPage paragraph is: &quot;, res[0])res = re.findall(r&apos;href=&quot;(.*?)&quot;&apos;, html)print(&quot;\nAll links: &quot;, res) 正文使用re和urllib123456from urllib.request import urlopen# if has Chinese, apply decode()html = urlopen( &quot;https://morvanzhou.github.io/static/scraping/basic-structure.html&quot;).read().decode(&apos;utf-8&apos;) print(html) # 打开，读取，转换可显示中文，最后打印出来 结果显示 接下来，使用re筛选数据1234567891011import reres = re.findall(r&quot;&lt;title&gt;(.+?)&lt;/title&gt;&quot;, html) print(res) # [&apos;Scraping tutorial 1 | 莫烦Python&apos;] # 列表print(res[0]) # Scraping tutorial 1 | 莫烦Pythonres = re.findall(r&quot;&lt;p&gt;(.*?)&lt;/p&gt;&quot;, html)print(res) # []res = re.findall(r&quot;&lt;p&gt;(.*?)&lt;/p&gt;&quot;, html, flags=re.DOTALL) # re.DOTALL if multi lineprnt(res)print(res[0]) 12res = re.findall(r&apos;href=&quot;(.*?)&quot;&apos;, html)print(&quot;\nAll links: &quot;, res)]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬虫整理（三）Requests]]></title>
    <url>%2Fpython%2F%E7%88%AC%E8%99%AB%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89Requests%2F</url>
    <content type="text"><![CDATA[Requests 是一个 Python 的外部模块, 需要手动安装. 使用 pip 安装就好了. 1234567import requestsimport webbrowser # 使用浏览器打开param = &#123;&quot;wd&quot;: &quot;itswl.github&quot;&#125; # 搜索的信息r = requests.get(&apos;https://www.baidu.com/s&apos;, params=param)print(r.url) # 用get 方式webbrowser.open(r.url)# https://www.baidu.com/s?wd=itswl.github 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import requestsimport webbrowser # 使用浏览器打开param = &#123;&quot;wd&quot;: &quot;itswl.github&quot;&#125; # 搜索的信息r = requests.get(&apos;http://www.baidu.com/s&apos;, params=param)print(r.url) # 用get 方式webbrowser.open(r.url)def get(): print(&apos;\nget&apos;) param = &#123;&quot;wd&quot;: &quot;itswl.github&quot;&#125; r = requests.get(&apos;https://www.baidu.com/s&apos;, params=param) print(r.url) print(r.text)# get()def post_name(): print(&apos;\npost name&apos;) # http://pythonscraping.com/pages/files/form.html data = &#123;&apos;firstname&apos;: &apos;laii&apos;, &apos;lastname&apos;: &apos;weii&apos;&#125; r = requests.post(&apos;http://pythonscraping.com/files/processing.php&apos;, data=data) print(r.text)post_name()def post_image(): print(&apos;\npost image&apos;) # http://pythonscraping.com/files/form2.html file = &#123;&apos;uploadFile&apos;: open(&apos;./image.png&apos;, &apos;rb&apos;)&#125; r = requests.post(&apos;http://pythonscraping.com/files/processing2.php&apos;, files=file) print(r.text)def post_login(): print(&apos;\npost login&apos;) # http://pythonscraping.com/pages/cookies/login.html payload = &#123;&apos;username&apos;: &apos;Morvan&apos;, &apos;password&apos;: &apos;password&apos;&#125; r = requests.post(&apos;http://pythonscraping.com/pages/cookies/welcome.php&apos;, data=payload) print(r.cookies.get_dict()) # http://pythonscraping.com/pages/cookies/profile.php r = requests.get(&apos;http://pythonscraping.com/pages/cookies/profile.php&apos;, cookies=r.cookies) print(r.text)def session_login(): # 使用cookie print(&apos;\nsession login&apos;) # http://pythonscraping.com/pages/cookies/login.html session = requests.Session() payload = &#123;&apos;username&apos;: &apos;Morvan&apos;, &apos;password&apos;: &apos;password&apos;&#125; r = session.post(&apos;http://pythonscraping.com/pages/cookies/welcome.php&apos;, data=payload) print(r.cookies.get_dict()) r = session.get(&quot;http://pythonscraping.com/pages/cookies/profile.php&quot;) print(r.text)post_name()post_image()post_login()session_login() 下载文件123456789101112131415161718192021222324252627282930313233import osos.makedirs(&apos;./img/&apos;, exist_ok=True)IMAGE_URL = &quot;https://morvanzhou.github.io/static/img/description/learning_step_flowchart.png&quot;def urllib_download(): from urllib.request import urlretrieve urlretrieve(IMAGE_URL, &apos;./img/image1.png&apos;) # whole documentdef request_download(): import requests r = requests.get(IMAGE_URL) with open(&apos;./img/image2.png&apos;, &apos;wb&apos;) as f: f.write(r.content) # whole documentdef chunk_download(): import requests r = requests.get(IMAGE_URL, stream=True) # stream loading with open(&apos;./img/image3.png&apos;, &apos;wb&apos;) as f: for chunk in r.iter_content(chunk_size=32): f.write(chunk)urllib_download()print(&apos;download image1&apos;)request_download()print(&apos;download image2&apos;)chunk_download()print(&apos;download image3&apos;) 一个小练习，抓取美女吧图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# coding=utf-8import requestsfrom lxml import etreeimport osimport reclass TieBa(object): &quot;&quot;&quot;抓取百度贴吧美女图片&quot;&quot;&quot; def __init__(self, word): self.url = &apos;https://tieba.baidu.com/f?kw=&#123;&#125;&apos;.format(word) # word 美女 self.headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0; TUCOWS) &apos; &#125; def get_data(self, url): # 构造请求 response = requests.get(url, headers=self.headers) data = response.content # print(data) return data def parse_page(self, data): &quot;&quot;&quot;解析数据&quot;&quot;&quot; # 创建xpath对象 html = etree.HTML(data) # 提取当前页标题，url数据 node_list = html.xpath(&apos;//*[@id=&quot;thread_list&quot;]/li/div/div[2]/div[1]/div[1]/a&apos;) detail_list = [] for node in node_list: temp = dict() temp[&apos;title&apos;] = node.xpath(&apos;./text()&apos;)[0] temp[&apos;url&apos;] = &apos;https://tieba.baidu.com&apos; + node.xpath(&apos;./@href&apos;)[0] detail_list.append(temp) # print(temp) # 提取下一页连接 next_url = html.xpath(&apos;//*[@id=&quot;frs_list_pager&quot;]/a[contains(text(), &quot;下一页&quot;)]/@href&apos;)[0] next_url = &apos;http:&apos; + next_url if len(next_url) &gt; 0 else None # print(next_url) return detail_list, next_url def parse_detail(self, detail_list): &quot;&quot;&quot;提取详情页url&quot;&quot;&quot; data_url = [] for detail in detail_list: data_url.append(detail[&apos;url&apos;]) return data_url def save_data(self, url): &quot;&quot;&quot;保存数据&quot;&quot;&quot; # 请求标题连接地址 data = self.get_data(url) # 创建xpath对象 html = etree.HTML(data) # print(html) # print(url) # 获取图片url try: image_url = html.xpath(&apos;//*[contains(@id,&quot;post_content&quot;)]/img[1]/@src&apos;)[0] except Exception as e: return print(image_url) # 判断图片地址是否已jpg结尾 if re.match(r&apos;.*\.jpg$&apos;, image_url): # 请求图片地址，获取图片 image_data = self.get_data(image_url) filename = &apos;image/&apos; + image_url.split(&apos;/&apos;)[-1] # print(filename) # 保存图片 with open(filename, &apos;wb&apos;) as f: f.write(image_data) def run(self): # 判断是否有image文件夹 if not os.path.exists(&apos;image&apos;): # 创建文件夹 os.mkdir(&apos;image&apos;) next_url = self.url # 请求美女吧首页 data = self.get_data(next_url) # 保存首页文件，观察数据，是否有需要的数据 with open(&apos;tieba.json&apos;, &apos;wb&apos;) as f: f.write(data) # 如果有下一页就执行 while next_url: # 获取每页标题和对应的连接地址 detail_list, next_url = self.parse_page(data) # 提取每页的详情页的url data_url = self.parse_detail(detail_list) # 遍历每个url for url in data_url: # 保存图片 self.save_data(url) # 构造下一页请求 data = self.get_data(next_url)if __name__ == &apos;__main__&apos;: tb = TieBa(&apos;美女&apos;) tb.run()]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬虫整理（二）BeautifulSoup]]></title>
    <url>%2Fpython%2F%E7%88%AC%E8%99%AB%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89BeautifulSoup%2F</url>
    <content type="text"><![CDATA[BeautifulSoup 解析：基础本段完整代码 具体安装过程可自行搜索。beautifulSoup使用过程 选择要爬的网址 (url) 使用 python 打开这个网址 (urlopen等) 读取网页信息 (read() 出来) 将读取的信息放入 BeautifulSoup 使用 BeautifulSoup 选取 tag 信息等 (代替正则表达式)123456from urllib.request import urlopen# if has Chinese, apply decode()html = urlopen(&quot;https://morvanzhou.github.io/static/scraping/basic-structure.html&quot;).read().decode(&apos;utf-8&apos;) 使用BeautifulSoup筛选数据1234from bs4 import BeautifulSoupsoup = BeautifulSoup(html, features=&apos;lxml&apos;) #以 lxml 的这种形式加载print(soup) 12345678print(soup.h1) # 输出&lt;h1&gt; 标题print(soup.p) # 输出&lt;p&gt; 标题all_href = soup.find_all(&apos;a&apos;)print(&apos;\n&apos;,all_href)all_href = [l[&apos;href&apos;] for l in all_href] #像 Python 字典的形式, 用 key 来读取 l[&quot;href&quot;]print(&apos;\n&apos;, all_href) BeautifulSoup 解析网页:CSS本节代码 12345678910111213141516171819202122232425from bs4 import BeautifulSoupfrom urllib.request import urlopen# if has Chinese, apply decode()html = urlopen(&quot;https://morvanzhou.github.io/static/scraping/list.html&quot;).read().decode(&apos;utf-8&apos;)soup = BeautifulSoup(html, features=&apos;lxml&apos;)# use class to narrow searchmonth = soup.find_all(&apos;li&apos;, &#123;&quot;class&quot;: &quot;month&quot;&#125;)print(month)#要找所有 class=month 的信息. 并打印出它们的 tag 内文字for m in month: print(m.get_text()) # 打印tag中的文字jan = soup.find(&apos;ul&apos;, &#123;&quot;class&quot;: &apos;jan&apos;&#125;)print(&apos;\n&apos;,jan)d_jan = jan.find_all(&apos;li&apos;) # use jan as a parentprint(&apos;\n&apos;,d_jan)for d in d_jan: print(&apos;\n&apos;,d.get_text()) BeautifulSoup 解析网页正则表达式本节代码12345678910111213141516html = urlopen(&quot;https://morvanzhou.github.io/static/scraping/table.html&quot;).read().decode(&apos;utf-8&apos;)print(html)soup = BeautifulSoup(html, features=&apos;lxml&apos;)img_links = soup.find_all(&quot;img&quot;, &#123;&quot;src&quot;: re.compile(&apos;.*?\.jpg&apos;)&#125;)for link in img_links: print(link[&apos;src&apos;])print(&apos;\n&apos;)course_links = soup.find_all(&apos;a&apos;, &#123;&apos;href&apos;: re.compile(&apos;https://morvan.*&apos;)&#125;)for link in course_links: print(link[&apos;href&apos;]) 我们发现, 如果是图片, 它们都藏在这样一个 tag 中:123&lt;td&gt; &lt;img src=&quot;https://morvanzhou.github.io/static/img/course_cover/tf.jpg&quot;&gt;&lt;/td&gt; 用 soup 将这些 tag 全部找出来, 但是每一个 img 的链接(src)都可能不同，可能是 jpg 有的是 png, 只挑选 jpg 形式的图片, 用这样一个正则 r’.*?.jpg’ 来选取. 把正则的 compile 形式放到 BeautifulSoup 的功能中, 就能选到符合要求的图片链接了.想要的链接都有统一的形式, 就是开头都会有 https://morvan., 定一个正则, 让 BeautifulSoup 找到符合规则的链接. 一个小练习来熟悉1234567891011121314151617181920212223242526from bs4 import BeautifulSoupfrom urllib.request import urlopenimport reimport randombase_url = &quot;https://baike.baidu.com&quot;his = [&quot;/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/5162711&quot;]for i in range(20): # dealing with Chinese symbols url = base_url + his[-1] html = urlopen(url).read().decode(&apos;utf-8&apos;) soup = BeautifulSoup(html, features=&apos;lxml&apos;) print(i, soup.find(&apos;h1&apos;).get_text(), &apos; url: &apos;, url) # find valid urls sub_urls = soup.find_all( &quot;a&quot;, &#123;&quot;target&quot;: &quot;_blank&quot;, &quot;href&quot;: re.compile(&quot;/item/(%.&#123;2&#125;)+$&quot;)&#125;) if len(sub_urls) != 0: his.append(random.sample(sub_urls, 1)[0][&apos;href&apos;]) else: # no valid sub link found his.pop()]]></content>
      <categories>
        <category>python练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(18) python异常]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常异常的概念 程序在运行时，如果 Python 解释器 遇到 到一个错误，会停止程序的执行，并且提示一些错误信息，这就是 异常 程序停止执行并且提示错误信息 这个动作，我们通常称之为：抛出(raise)异常 程序开发时，很难将 所有的特殊情况 都处理的面面俱到，通过 异常捕获 可以针对突发事件做集中的处理，从而保证程序的 稳定性和健壮性 [图片上传失败…(image-81f29f-1542201966094)] 捕获异常：try except else finally简单的捕获异常语法 在程序开发中，如果 对某些代码的执行不能确定是否正确，可以增加 try(尝试) 来 捕获异常 1234try: 尝试执行的代码except: 出现错误的处理 try 尝试，下方编写要尝试代码，不确定是否能够正常执行的代码 except 如果不是，下方编写尝试失败的代码 简单异常捕获1 —— 要求用户输入整数 12345try: # 提示用户输入一个数字 num = int(input(&quot;请输入数字：&quot;))except: print(&quot;请输入正确的数字&quot;) 错误类型捕获 在程序执行时，可能会遇到 不同类型的异常，并且需要 针对不同类型的异常，做出不同的响应，这个时候，就需要捕获错误类型了 1234567891011try: # 尝试执行的代码 passexcept 错误类型1: # 针对错误类型1，对应的代码处理 passexcept (错误类型2, 错误类型3): # 针对错误类型2 和 3，对应的代码处理 passexcept Exception as result: print(&quot;未知错误 %s&quot; % result) 当 Python 解释器 抛出异常 时，最后一行错误信息的第一个单词，就是错误类型 异常类型捕获2 —— 要求用户输入整数 12345678try: num = int(input(&quot;请输入整数：&quot;)) result = 8 / num print(result)except ValueError: print(&quot;请输入正确的整数&quot;)except ZeroDivisionError: print(&quot;除 0 错误&quot;) 捕获未知错误 在开发时，要预判到所有可能出现的错误，还是有一定难度的 如果希望程序 无论出现任何错误，都不会因为 Python 解释器 抛出异常而被终止，可以再增加一个 except 语法如下： 12except Exception as result: print(&quot;未知错误 %s&quot; % result) 异常捕获完整语法 在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下： 123456789101112131415161718192021try: # 尝试执行的代码 passexcept 错误类型1: # 针对错误类型1，对应的代码处理 passexcept 错误类型2: # 针对错误类型2，对应的代码处理 passexcept (错误类型3, 错误类型4): # 针对错误类型3 和 4，对应的代码处理 passexcept Exception as result: # 打印错误信息 print(result)else: # 没有异常才会执行的代码 passfinally: # 无论是否有异常，都会执行的代码 print(&quot;无论是否有异常，都会执行的代码&quot;) else 只有在没有异常时才会执行的代码 finally 无论是否有异常，都会执行的代码 之前一个演练的 完整捕获异常 的代码如下： 1234567891011121314try: num = int(input(&quot;请输入整数：&quot;)) result = 8 / num print(result)except ValueError: print(&quot;请输入正确的整数&quot;)except ZeroDivisionError: print(&quot;除 0 错误&quot;)except Exception as result: print(&quot;未知错误 %s&quot; % result)else: print(&quot;正常执行&quot;)finally: print(&quot;执行完成，但是不保证正确&quot;) 异常的传递 异常的传递 —— 当 函数/方法 执行 出现异常，会 将异常传递 给 函数/方法 的 调用一方 如果 传递到主程序，仍然 没有异常处理，程序才会被终止 提示： 在开发中，可以在主函数中增加 异常捕获，而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的异常捕获中 这样就不需要在代码中，增加大量的异常捕获，能够保证代码的整洁 123456789101112131415161718&apos;&apos;&apos;需求:1\. 定义函数 `demo1()` **提示用户输入一个整数并且返回**2\. 定义函数 `demo2()` 调用 `demo1()`3\. 在主程序中调用 `demo2()`&apos;&apos;&apos;def demo1(): return int(input(&quot;请输入一个整数：&quot;))def demo2(): return demo1()try: print(demo2())except ValueError: print(&quot;请输入正确的整数&quot;)except Exception as result: print(&quot;未知错误 %s&quot; % result) 抛出异常： raise应用场景 在开发中，除了 代码执行出错 Python 解释器会 抛出 异常之外 还可以根据 应用程序 特有的业务需求 主动抛出异常 示例 提示用户 输入密码，如果 长度少于 8，抛出 异常 [图片上传失败…(image-3d2a0b-1542201966092)] 抛出异常 Python 中提供了一个 Exception 异常类 在开发时，如果满足 特定业务需求时，希望 抛出异常，由其他需要处理的函数捕获异常，可以： 创建 一个 Exception 的 对象 使用 raise 关键字 抛出 异常对象 12345678910111213141516171819202122232425262728&apos;&apos;&apos;**需求*** 定义 `input_password` 函数，提示用户输入密码* 如果用户输入长度 &lt; 8，抛出异常* 如果用户输入长度 &gt;=8，返回输入的密码&apos;&apos;&apos;def input_password(): # 1\. 提示用户输入密码 pwd = input(&quot;请输入密码：&quot;) # 2\. 判断密码长度，如果长度 &gt;= 8，返回用户输入的密码 if len(pwd) &gt;= 8: return pwd # 3\. 密码长度不够，需要抛出异常 # 1&gt; 创建异常对象 - 使用异常的错误信息字符串作为参数 ex = Exception(&quot;密码长度不够&quot;) # 2&gt; 抛出异常对象 raise extry: user_pwd = input_password() print(user_pwd)except Exception as result: print(&quot;发现错误：%s&quot; % result) 参考文章：https://www.jianshu.com/p/ebc19de7a204]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(19) 网络编程]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Python进行网络编程，就是在Python程序本身这个进程内，连接别的服务器进程的通信端口进行通信。 TCP/IP 简介互联网上每个计算机的唯一标识就是IP地址，类似123.123.123.123。如果一台计算机同时接入到两个或更多的网络，比如路由器，它就会有两个或多个IP地址，所以，IP地址对应的实际上是计算机的网络接口，通常是网卡。 IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。 IPv4地址实际上是一个32位整数，以字符串表示的。IP地址如192.168.0.1实际上是把32位整数按8位分组后的数字表示，目的是便于阅读IPv6地址全部长度128位(bit)，每16位为一个双字节。 TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。 socket是电脑网络中进程间数据流的端点 主要分为UDP和TCP两种通信方式 TCP编程Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。 大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。 创建一个基于TCP连接的Socket，可以这样做：1234567# 导入socket库:import socket# 创建一个socket:s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect((&apos;www.baidu.com&apos;, 80)) 创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议，这样，一个Socket对象就创建成功，但是还没有建立连接。 客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。新浪网站的IP地址可以用域名www.sina.com.cn自动转换到IP地址。80端口是Web服务的标准端口。其他服务都有对应的标准端口号，例如SMTP服务是25端口，FTP服务是21端口，等等。端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。 因此，连接新浪服务器的代码如下：1s.connect((&apos;www.baidu.com&apos;, 80)) 注意参数是一个tuple，包含地址和端口号。 建立TCP连接后，我们就可以向百度服务器发送请求，要求返回首页的内容：12# 发送数据:s.send(b&apos;GET / HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: close\r\n\r\n&apos;) TCP连接创建的是双向通道，双方都可以同时给对方发数据。但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。 发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收百度服务器返回的数据了：12345678910# 接收数据:buffer = []while True: # 每次最多接收1k字节: d = s.recv(1024) if d: buffer.append(d) else: breakdata = b&apos;&apos;.join(buffer) 接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。 当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了：12# 关闭连接:s.close() 接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件：123456header, html = data.split(b&apos;\r\n\r\n&apos;, 1)print(header.decode(&apos;utf-8&apos;))# python3.x版本，网络数据的发送接受都是byte类型，需要解码# 把接收的数据写入文件:with open(&apos;baidu.html&apos;, &apos;wb&apos;) as f: f.write(html) 现在，只需要在浏览器中打开这个baidu.html文件，就可以看到百度的首页了。1234567891011121314151617import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((&apos;www.baidu.com&apos;, 80))s.send(b&apos;GET / HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: close\r\n\r\n&apos;)buffer = []while True: d = s.recv(1024) if d: buffer.append(d) else: breakdata = b&apos;&apos;.join(buffer)s.close()header, html = data.split(b&apos;\r\n\r\n&apos;, 1)print(header.decode(&apos;utf-8&apos;))with open(&apos;baidu.html&apos;, &apos;wb&apos;) as f: f.write(html) 服务器和客户端编程相比，服务器编程就要复杂一些。 服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。 所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。 但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。 我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上Hello再发回去。 首先，创建一个基于IPv4和TCP协议的Socket： 1s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。 端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用9999这个端口号。请注意，小于1024的端口号必须要有管理员权限才能绑定： 12# 监听端口:s.bind((&apos;127.0.0.1&apos;, 9999)) 紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量： 12s.listen(5)print(&apos;Waiting for connection...&apos;) 接下来，服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接: 1234567# 不断循环，不断接受数据while True: # 接受一个新连接: sock, addr = s.accept() # 创建新线程来处理TCP连接: t = threading.Thread(target=tcplink, args=(sock, addr)) t.start() 每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接： 12345678910111213def tcplink(sock, addr): print(&apos;Accept new connection from %s:%s...&apos; % addr) sock.send(b&apos;Welcome!&apos;) # 不断接受客服端发来的消息 while True: data = sock.recv(1024) time.sleep(1) if not data or data.decode(&apos;utf-8&apos;) == &apos;exit&apos;: # 退出 break sock.send((&apos;Hello, %s!&apos; % data.decode(&apos;utf-8&apos;)).encode(&apos;utf-8&apos;)) #处理客户端数据 sock.close() print(&apos;Connection from %s:%s closed.&apos; % addr) 连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上Hello再发送给客户端。如果客户端发送了exit字符串，就直接关闭连接。 要测试这个服务器程序，我们还需要编写一个客户端程序： 123456789101112s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect((&apos;127.0.0.1&apos;, 9999))# 接收欢迎消息:print(s.recv(1024).decode(&apos;utf-8&apos;))for data in [b&apos;Michael&apos;, b&apos;Tracy&apos;, b&apos;Sarah&apos;]: # 发送数据: s.send(data) print(s.recv(1024).decode(&apos;utf-8&apos;))s.send(b&apos;exit&apos;)s.close() 我们需要打开两个命令行窗口，一个运行服务器程序，另一个运行客户端程序，就可以看到效果了： 需要注意的是，客户端程序运行完毕就退出了，而服务器程序会永远运行下去，必须按Ctrl+C退出程序。 小结用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，然后，对每一个新的连接，创建一个线程或进程来处理。通常，服务器程序会无限运行下去。 同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。 #UDP 编程 TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。 使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。 虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。 我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口： 123s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 绑定端口:s.bind((&apos;127.0.0.1&apos;, 9999)) 创建Socket时，SOCK_DGRAM指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是不需要调用listen()方法，而是直接接收来自任何客户端的数据： 123456print(&apos;Bind UDP on 9999...&apos;)while True: # 接收数据: data, addr = s.recvfrom(1024) print(&apos;Received from %s:%s.&apos; % addr) s.sendto(b&apos;Hello, %s!&apos; % data, addr) recvfrom()方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用sendto()就可以把数据用UDP发给客户端。 注意这里省掉了多线程，因为这个例子很简单。 客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用connect()，直接通过sendto()给服务器发数据： 1234567s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)for data in [b&apos;Michael&apos;, b&apos;Tracy&apos;, b&apos;Sarah&apos;]: # 发送数据: s.sendto(data, (&apos;127.0.0.1&apos;, 9999)) # 接收数据: print(s.recv(1024).decode(&apos;utf-8&apos;))s.close() 从服务器接收数据仍然调用recv()方法。 仍然用两个命令行分别启动服务器和客户端测试，结果如下： 小结UDP的使用与TCP类似，但是不需要建立连接。此外，服务器绑定UDP端口和TCP端口互不冲突，也就是说，UDP的9999端口与TCP的9999端口可以各自绑定。]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(17) python文件操作]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件文件####文件的概念 计算机的 文件，就是存储在某种 长期储存设备 上的一段 数据 长期存储设备包括：硬盘、U 盘、移动硬盘、光盘… 文件的作用：将数据长期保存下来，在需要的时候使用文件的存储方式：在计算机中，文件是以 二进制 的方式保存在磁盘上的文本文件：可以使用 文本编辑软件 查看，本质上还是二进制文件二进制文件：保存的内容 不是给人直接阅读的，而是 提供给其他软件使用的，例如：图片文件、音频文件、视频文件等等，二进制文件不能使用 文本编辑软件 查看 文件的基本操作操作文件的套路：在 计算机 中要操作文件的套路非常固定，一共包含三个步骤： 打开文件 读、写文件 读 将文件内容读入内存 写 将内存内容写入文件 关闭文件 操作文件的函数/方法在 Python 中要操作文件 序号 函数/方法 说明 01 open 打开文件，并且返回文件操作对象 02 read 将文件内容读取到内存 03 write 将指定内容写入文件 04 close 关闭文件 open 函数负责打开文件，并且返回文件对象read/write/close 三个方法都需要通过 文件对象 来调用 读取文件示例 open 函数的第一个参数是要打开的文件名（文件名区分大小写）如果文件 存在，返回 文件操作对象如果文件 不存在，会 抛出异常 read 方法可以一次性 读入 并 返回 文件的 所有内容 close 方法负责 关闭文件如果 忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问 注意：read 方法执行后，会把 文件指针 移动到 文件的末尾 123456789# 1\. 打开 - 文件名需要注意大小写file = open(&quot;README&quot;)# 2\. 读取text = file.read()print(text)# 3\. 关闭file.close() 提示 在开发中，通常会先编写 打开 和 关闭 的代码，再编写中间针对文件的 读/写 操作！ &lt;补&gt; 文件指针 文件指针 标记 从哪个位置开始读取数据 第一次打开 文件时，通常 文件指针会指向文件的开始位置 当执行了 read 方法后，文件指针 会移动到 读取内容的末尾 默认情况下会移动到 文件末尾 思考：如果执行了一次 read 方法，读取了所有内容，那么再次调用 read 方法，还能够获得到内容吗？答案：不能！第一次读取之后，文件指针移动到了文件末尾，再次调用不会读取到任何的内容。 &lt;补&gt; 打开文件的方式 open 函数默认以 只读方式 打开文件，并且返回文件对象 1f = open(&quot;文件名&quot;, &quot;访问方式&quot;) 访问方式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常 w 以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 a 以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 r+ 以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常 w+ 以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 a+ 以读写方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 提示：频繁的移动文件指针，会影响文件的读写效率，开发中更多的时候会以 只读、只写 的方式来操作文件 写入文件示例 12345678# 打开文件f = open(&quot;README&quot;, &quot;w&quot;)f.write(&quot;hello python！\n&quot;)f.write(&quot;今天天气真好&quot;)# 关闭文件f.close() &lt;补&gt; 按行读取文件内容：readline() read 方法默认会把文件的 所有内容 一次性读取到内存 如果文件太大，对内存的占用会非常严重 readline 方法可以一次读取一行内容 方法执行后，会把 文件指针 移动到下一行，准备再次读取 读取大文件的正确姿势 12345678910111213141516# 打开文件file = open(&quot;README&quot;)while True: # 读取一行内容 text = file.readline() # 判断是否读到内容 if not text: break # 每读取一行的末尾已经有了一个 `\n` print(text, end=&quot;&quot;)# 关闭文件file.close() 复制大文件 打开一个已有文件，逐行读取内容，并顺序写入到另外一个文件 123456789101112131415161718# 1\. 打开文件file_read = open(&quot;README&quot;)file_write = open(&quot;README[复件]&quot;, &quot;w&quot;)# 2\. 读取并写入文件while True: # 每次读取一行 text = file_read.readline() # 判断是否读取到内容 if not text: break file_write.write(text)# 3\. 关闭文件file_read.close()file_write.close() 文件/目录的常用管理操作 在 终端 / 文件浏览器、 中可以执行常规的 文件 / 目录 管理操作，例如： 创建、重命名、删除、改变路径、查看目录内容、…… 在 Python 中，如果希望通过程序实现上述功能，需要 import os 模块 文件管理操作 序号 方法名 说明 示例 01 rename 重命名文件 os.rename(源文件名, 目标文件名) 02 remove 删除文件 os.remove(文件名) 目录管理操作 序号 方法名 说明 示例 01 listdir 目录列表 os.listdir(目录名) 02 mkdir 创建目录 os.mkdir(目录名) 03 rmdir 删除目录 os.rmdir(目录名) 04 getcwd 获取当前目录 os.getcwd() 05 chdir 修改工作目录 os.chdir(目标目录) 06 path.isdir 判断是否是文件 os.path.isdir(文件路径) 提示：文件或者目录操作都支持 相对路径 和 绝对路径 文本文件的编码格式 文本文件存储的内容是基于 字符编码 的文件，常见的编码有 ASCII 编码，UNICODE 编码等 Python 2.x 默认使用 ASCII 编码格式Python 3.x 默认使用 UTF-8 编码格式 ASCII 编码 计算机中只有 256 个 ASCII 字符 一个 ASCII 在内存中占用 1 个字节 的空间 8 个 0/1 的排列组合方式一共有 256 种，也就是 2 ** 8 UTF-8 编码格式 计算机中使用 1~6 个字节 来表示一个 UTF-8 字符，涵盖了 地球上几乎所有地区的文字 大多数汉字会使用 3 个字节 表示 UTF-8 是 UNICODE 编码的一种编码格式 123456789# *-* coding:utf8 *-*# 在字符串前，增加一个 `u` 表示这个字符串是一个 utf8 字符串hello_str = u&quot;你好世界&quot;print(hello_str)for c in hello_str: print(c)]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(13) python中用字典代替switch]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E7%94%A8%E5%AD%97%E5%85%B8%E4%BB%A3%E6%9B%BFswitch%2F</url>
    <content type="text"><![CDATA[switch语句类型12345678910111213&apos;&apos;&apos;switch(n)&#123;case 1: 执行代码块 1 break;case 2: 执行代码块 2 break;default: n 与 case 1 和 case 2 不同时执行的代码&#125;&apos;&apos;&apos; 例如：12345678910111213141516&apos;&apos;&apos;switch (day)&#123;case 0: x=&quot;Today it&apos;s Sunday&quot;; break;case 1: x=&quot;Today it&apos;s Monday&quot;; break;case 2: x=&quot;Today it&apos;s Tuesday&quot;; break;case 3: x=&quot;unknown&quot;&#125;&apos;&apos;&apos; python中字典方式123456789day = 3switcher = &#123; 0:&apos;Today it\&apos;s Sunday&apos;, 1:&apos;Today it\&apos;s Monday&apos;, 2:&apos;Today it\&apos;s Tuesday&apos;&#125;#day_name =switcher[day] #并不能显示defaultday_name = switcher.get(day,&apos;Unknown&apos;)print(day_name) 函数12345678910111213141516171819202122day = 3def get_monday(): return &apos;Monday&apos;def get_sunday(): return &apos;Sunday&apos;def get_tuesday(): return &apos;Tuesday&apos;def get_default(): return &apos;Unknown&apos;switcher1 = &#123; 0:get_sunday, 1:get_monday, 2:get_tuesday&#125; day_name = switcher1.get(day,get_default)()print(day_name)]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(14) python中的列表推导式]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[#####列表推导式 #####集合字典也可 #####元组也可 1234a=[1,2,3,4,5,6,7,8,9]b=[i**3 for i in a if i &lt;=5]print(b) #b=&#123;....&#125;为集合，b(...)为元组，与a&#123;[(...)]&#125;,什么的无关。#为b()时，是一个对象 也可以map filter表示1234list_a=[1,2,3,4,5,6,7,8,9]r=filter(lambda x:x if x&lt;=5 else 0,list_a)s=map(lambda x:x*x,r)print(list(s)) 12345#同上，不建议list_a=[1,2,3,4,5,6,7,8,9]r=filter(lambda x:x if x&lt;=5 else 0,list_a)s=map(lambda x:x**3,filter(lambda x:x if x&lt;=5 else 0,list_a))print(list(s)) #####当为字典时123456789students =&#123; &apos;wei&apos;:18, &apos;lai&apos;:19, &apos;wan&apos;:20&#125;b = [key for key,value in students.items()]print(b)#[&apos;wei&apos;, &apos;lai&apos;, &apos;wan&apos;]for x in b: print(x)#wei#lai#wan **交换key和value12345678students =&#123; &apos;wei&apos;:18, &apos;lai&apos;:19, &apos;wan&apos;:20&#125;b =&#123;value:key for key,value in students.items()&#125;print(b)#&#123;18: &apos;wei&apos;, 19: &apos;lai&apos;, 20: &apos;wan&apos;&#125;]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(15) python中的None]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E7%9A%84None%2F</url>
    <content type="text"><![CDATA[None 表示空 不同于 空字符串 空的列表 0 False 类型不同，值不同1234567print(type(None)) &lt;class &apos;NoneType&apos;&gt;None是None类a=&apos;&apos;b=Falsec=[]print(a==None) #Falseprint(b==None) #Falseprint(c==None) #False #值不相等 深入123456789101112131415def fun(): return Nonea = fun()if not a: print(&apos;S&apos;)else: print(&apos;F&apos;)if a is None: print(&apos;S&apos;)else: print(&apos;F&apos;)#S#S 123456789101112131415def fun(): return Nonea = []if not a: print(&apos;S&apos;)else: print(&apos;F&apos;)if a is None: print(&apos;S&apos;)else: print(&apos;F&apos;)#S#F 类中默认非空123456789class Test(): passtest = Test()if test: print(&apos;S&apos;)else: print(&apos;F&apos;)#S 类中为空的情况12345678910class Test(): def __len__(self): return 0 #(只能为int类型)test = Test()if test: print(&apos;S&apos;)else: print(&apos;F&apos;)#F 123456789class Test(): def __len__(self): return 0 #(只能为int类型)test = Test()print(bool(None)) #Falseprint(bool(&#123;&#125;))#Falseprint(bool([]))#Falseprint(bool(test))#False 由bool决定True or False,与len无关(即print 只有 bool call True,或者bool call False ))12345678910111213class Test(): def __bool__(self): print(&apos;bool called&apos;) return False#(/True) def __len__(self): print(&apos;len called&apos;) return True #(只能为int类型)print(bool(Test()))#bool called#False#(/True)]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(16) python补充]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[1234567num2 = 100sum1 = lambda num1 : num1 + num2 num2 = 10000sum2 = lambda num1 : num1 + num2 print( sum1( 1 ) )#10001print( sum2( 1 ) )#10001 lambda 表达式中的 num2 是一个自由变量，在运行时绑定值，而不是定义时就绑定，这跟函数的默认值参数定义是不同的。打印乘法表占位符12345678910111213#方法1for i in range(1, 10): for j in range(1, i+1): # end=&apos;&apos; 意思是末尾不换行，加空格 print(&apos;&#123;&#125;x&#123;&#125;=&#123;&#125;\t&apos;.format(i, j, i*j), end=&apos;&apos;) print()#方法2for m in range(1, 10): for n in range(1, m+1): print(&apos;%d*%d=%d\t&apos;%(n,m,n*m), end=&apos;&apos;) print() while 与for (待补充) 从键盘获取输入信息：input在 Python 中可以使用 input 函数从键盘等待用户的输入用户输入的 任何内容 Python 都认为是一个 字符串 格式化输出：print如果希望输出文字信息的同时，一起输出 数据，就需要使用到 格式化操作符% 被称为 格式化操作符，专门用于处理字符串中的格式包含 % 的字符串，被称为 格式化字符串% 和不同的 字符 连用，不同类型的数据 需要使用 不同的格式化字符 格式化字符 含义%s 字符串%d 有符号十进制整数，%06d 表示输出的整数显示位数，不足的地方使用 0 补全%f 浮点数，%.2f 表示小数点后只显示两位%% 输出 % 随机数生成1234567import random#导入模块后，可以直接在 模块名称 后面敲一个 . 然后按 Tab 键，会提示该模块中包含的所有函数#random.randint(a, b) ，返回 [a, b] 之间的整数，包含 a 和 brandom.randint(12, 20) # 生成的随机数n: 12 &lt;= n &lt;= 20 random.randint(20, 20) # 结果永远是 20 random.randint(20, 10) # 该语句是错误的，下限必须小于上限。 随机数的小游戏 12345678910111213141516171819202122232425262728import random# 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3）player = int(input(&quot;请输入您要出的拳 石头（1）／剪刀（2）／布（3）：&quot;))# 电脑 随机 出拳 —— 先假定电脑只会出石头，完成整体代码功能computer = random.randint(1, 3)print(&quot;玩家选择的拳头是 %d - 电脑出的拳是 %d&quot; % (player, computer))# 比较胜负# 1 石头 胜 剪刀# 2 剪刀 胜 布# 3 布 胜 石头# if (()# or ()# or ()):if ((player == 1 and computer == 2) or (player == 2 and computer == 3) or (player == 3 and computer == 1)): print(&quot;欧耶，电脑弱爆了！&quot;)# 平局elif player == computer: print(&quot;真是心有灵犀啊，再来一盘&quot;)# 其他的情况就是电脑获胜else: print(&quot;不服气，我们决战到天明！&quot;) 12345678910111213141516import randomguess_list = [&quot;石头&quot;, &quot;剪刀&quot;, &quot;布&quot;]win_combination = [[&quot;布&quot;, &quot;石头&quot;], [&quot;石头&quot;, &quot;剪刀&quot;], [&quot;剪刀&quot;, &quot;布&quot;]]while True: computer = random.choice(guess_list) people = input(&apos;请输入：石头,剪刀,布\n&apos;).strip() if people not in guess_list: continue elif computer == people: print (&quot;平手，再玩一次！&quot;) elif [computer, people] in win_combination: print (&quot;电脑获胜，再玩，人获胜才能退出！&quot;) else: print (&quot;人获胜！&quot;) break 函数1234567891011121314151617181920def print_code(code): print(code) #return Noneprint_code(&apos;python&apos;) # pythondef add(x,y): result=x+y return resulta = add(1,2)print(a) # 3def add1(x,y): result = x + y print(result)add1(1,2) # 3def add2(x,y): result = x + y print(&apos;%d + %d = %d&apos;%(x,y,x+y))add2(1,2) # 1 + 2 = 3 ####多值参数有时可能需要 一个函数 能够处理的参数 个数 是不确定的，这个时候，就可以使用 多值参数。 python 中有 两种 多值参数： 参数名前增加 一个 * 可以接收 元组参数名前增加 两个 ** 可以接收 字典 一般在给多值参数命名时，习惯使用以下两个名字 args —— 存放 元组 参数，前面有一个 kwargs —— 存放 字典 参数，前面有两个 123456789101112131415161718192021def demo(num, *args, **kwargs): print(num) print(args) print(kwargs)demo(1, 2, 3, 4, 5, name=&quot;小明&quot;, age=18, gender=True)#1#(2, 3, 4, 5)#&#123;&apos;name&apos;: &apos;小明&apos;, &apos;age&apos;: 18, &apos;gender&apos;: True&#125;demo(1,(2,3,4,5),&#123;&quot;name&quot;:&quot;小明&quot;, &quot;age&quot;:18, &quot;gender&quot;:True&#125;)#1#((2, 3, 4, 5), &#123;&apos;name&apos;: &apos;小明&apos;, &apos;age&apos;: 18, &apos;gender&apos;: True&#125;)#&#123;&#125;demo(1,(2,3,4,5), name=&quot;小明&quot;, age=18, gender=True)#1#((2, 3, 4, 5),)#&#123;&apos;name&apos;: &apos;小明&apos;, &apos;age&apos;: 18, &apos;gender&apos;: True&#125; 元组和字典的拆包在调用带有多值参数的函数时，如果希望：将一个 元组变量，直接传递给 args将一个 字典变量，直接传递给 kwargs就可以使用 拆包，简化参数的传递，拆包 的方式是：在 元组变量前，增加 一个 在 字典变量前，增加 两个 12345678910111213141516def demo(*args, **kwargs): print(args) print(kwargs)# 需要将一个元组变量/字典变量传递给函数对应的参数gl_nums = (1, 2, 3)gl_xiaoming = &#123;&quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 18&#125;# 会把 num_tuple 和 xiaoming 作为元组传递个 argsdemo(gl_nums, gl_xiaoming)#((1, 2, 3), &#123;&apos;name&apos;: &apos;小明&apos;, &apos;age&apos;: 18&#125;)#&#123;&#125;demo(*gl_nums, **gl_xiaoming)#(1, 2, 3)#&#123;&apos;name&apos;: &apos;小明&apos;, &apos;age&apos;: 18&#125; 函数的返回值12# Python 专有，利用元组交换两个变量的值a, b = b, a #面向对象(补充)]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(10) python中的枚举]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[在python中，枚举的本质是一个类，所有枚举类都是Enum的子类枚举值不能动态更改且标签唯一，标签唯一但是数值不唯一。如果数值不唯一，相当于起别名 表示类型的三种方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101from enum import Enumclass VIP(Enum): #所有枚举类都是Enum的子类 YELLOW = 1 #常量是不能更改的 用大写表示（约定的，python中没有真的常量） GREEN = 2 RED = &apos;str&apos; BLACK = 4 PINK = 1 # 其实就是YELLOW = 1， 可以看作YELLOW 的别名， #YELLOW = 1 #会报错，不能同时有两个YELLOW Attempted to reuse key: &apos;YELLOW&apos; # GREEN = 6 #会报错，不能继续使用GREEN这个标签 Attempted to reuse key: &apos;GREEN&apos;#class Common(): # YELLOW = 1 #VIP.YELLOW =6 #会报错，枚举中的值不能被更改print(VIP.PINK)print(VIP.YELLOW) #VIP.YELLOW (不关心取值)print(VIP.PINK) #VIP.YELLOW 可以看作YELLOW 的别名print(type(VIP.YELLOW)) #&lt;enum &apos;VIP&apos;&gt; 枚举类型print(VIP.YELLOW.name) #YELLOW 获取标签名字print(type(VIP.YELLOW.name)) #&lt;class &apos;str&apos;&gt; 字符串类型print(VIP[&apos;YELLOW&apos;]) #VIP.YELLOWprint(VIP.YELLOW.value) #1 获取值#枚举类型、枚举的名字、枚举的值for v in VIP: #遍历枚举类型(并不会把别名打印出来) print(v) #VIP.YELLOW #VIP.GREEN #VIP.RED #VIP.BLACK #枚举的比较运算#枚举不可以进行大小比较，但可以进行等值比较，身份比较result = VIP.YELLOW == VIP.PINK #枚举之间的等值比较 #Trueresult1 = VIP.YELLOW == 1 #False#result = VIP.YELLOW &gt;= VIP.PINK #枚举不能进行大小比较报错 #&apos;&gt;=&apos; not supported between instances of &apos;VIP&apos; and &apos;VIP&apos;result2 = VIP.YELLOW is VIP.PINK #True 身份比较print(result) print(result1)print(result2) class VIP1(Enum): YELLOW = 1 GREEN = 2 RED = &apos;3&apos; BLACK = 4 PINK = 1result = VIP.YELLOW == VIP1.YELLOW #Fales 虽然值相等，但其实是两个不同的枚举类型print(result) for v in VIP.__members__.items(): #遍历枚举类型(把别名也打印出来) print(v)&apos;&apos;&apos;(&apos;YELLOW&apos;, &lt;VIP.YELLOW: 1&gt;)(&apos;GREEN&apos;, &lt;VIP.GREEN: 2&gt;)(&apos;RED&apos;, &lt;VIP.RED: 3&gt;)(&apos;BLACK&apos;, &lt;VIP.BLACK: 4&gt;)(&apos;PINK&apos;, &lt;VIP.YELLOW: 1&gt;)&apos;&apos;&apos;for v in VIP.__members__: print(v) #枚举的名字（包括别名）&apos;&apos;&apos;YELLOWGREENREDBLACKPINK&apos;&apos;&apos;a = 1a = VIP(a) #把a变成一个枚举类型print(a) #VIP.YELLOW from enum import IntEnum #(枚举的值得是int类型)from enum import IntEnum,unique #(枚举的值得是int类型,且不能重复)class VIP2(IntEnum): YELLOW = 1 GREEN = 2 # RED = &apos;str&apos; #会报错,(枚举的值得是int类型) BLACK = 4 PINK = 1 @uniqueclass VIP3(IntEnum): YELLOW = 1 GREEN = 2 # RED = &apos;str&apos; #会报错,(枚举的值得是int类型) BLACK = 4 # PINK = 1 #会报错,取值重复#枚举 是单例模式 #23种设计模式 实践中]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(11) python之函数式编程]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[函数式编程是一种思维，闭包只是其一种体现 匿名函数12345678#例如 x+y#普通函数def add(x,y): return x+y#匿名函数lambda x,y:x+y 三元表达式12345678# x,y x大于y，取x 否则，取y# x &gt; y ? x:y (其他语言中)# x if x &gt; y else y #python中#条件为真时返回的结果 if 条件判断 else 条件为假时的返回结果 x = 1y = 4r = x if x &gt; y else yprint(r) #4 map类12345678910111213141516list_a = [1,2,3,4,5,6,7,8]def square(x): return x * xr = map(square,list_a)print(r) #&lt;map object at 0x0000026BCECDE9E8&gt;#map类print(list(r)) #[1, 4, 9, 16, 25, 36, 49, 64]#map:将集合里每个元素传到square里去，并且映射到新的集合中#也可以用fordef square1(x): return x * xfor x in list_a: x = square1(x) print(x)#1, 4, 9, 16, 25, 36, 49, 64 map常用方法1234list_a = [1,2,3,4,5,6,7,8]r = map(lambda x:x * x,list_a)print(list(r))#[1, 4, 9, 16, 25, 36, 49, 64] 12345list_a = [1,2,3,4,5,6,7,8]list_b = [1, 4, 9, 16, 25, 36, 49]s = map(lambda x,y:x * x + y,list_a,list_b) #map中传入多个listprint(list(s)) #[2, 8, 18, 32, 50, 72, 98] 长度取决于列表少的那个 reduce 连续计算，连续计算，连续调用lambda12345from functools import reducelist_a = [1,2,3,4,5,6,7,8]r = reduce(lambda x,y:x + y,list_a,10) #初始值为10 #10+1,得到11，11+2,得到13.....等一系列计算print(r) #46 12345#初始值为50，从0累加到99from functools import reducea = range(0,100)r = reduce(lambda x,y:x+y,a,50)print(r) map/reduce编程模型 映射 归纳并行计算函数式编程 filter 过滤1234list_a = [1,1,0,0,1,1,0,1,0]# r = filter(lambda x: True if x==1 else False, list_a)r = filter(lambda x:x,list_a) #因为0代表Falseprint(list(r))]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(9) python之闭包]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B9%8B%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包闭包 = 函数 + 环境变量(函数定义的时候) 一个最简单的闭包1234567def curve_pre(): def curve(): print(&apos;This is a function&apos;) return curvef = curve_pre()f() #This is a function 闭包不受外部变量影响1234567891011121314def curve_pre1(): a = 25 def curve1(x): return a*x**2 return curve1#闭包 = 函数 + 环境变量(函数定义的时候)a = 20 #全局变量f1 = curve_pre1()print(f1.__closure__) #(&lt;cell at 0x00000216457D06D8: int object at 0x00007FFEF75AD720&gt;,)实质返回了一个闭包print(f1.__closure__[0].cell_contents) #25 取出环境变量f1(2) print(f1(2)) #100 调用时 a 取 25 非闭包1234567891011121314def f2(): a = 10 def f3(): #a(=20)被python 认为是一个局部变量,没有引用上面的a(=10)(环境变量)就不是闭包了 a = 20 print(a) print(a) f3() print(a)f2()#首先运行f2() ,a=10，print(a)即为10#然后运行f3() ,a=20，print(a)即为20，此时a为f3()中的局部变量#最后print(a)即为10 闭包12345678910def f4(): a = 10 def f5(): c = 20 * a #调用了 a=10 return f5f = f4()print(f) #&lt;function f4.&lt;locals&gt;.f5 at 0x0000015AF4F479D8&gt;print(f.__closure__)#(&lt;cell at 0x0000015AF4ED06D8: int object at 0x00007FFC0F54D540&gt;,) 闭包 只是一种思维方式，函数式编程 闭包可以记忆上次调用的状态 例题，origin 最初为0，累加计算12345678910111213141516171819#闭包模式origin = 0def factory(pos): def go(step): nonlocal pos #pos不是本地局部变量 new_pos = pos +step pos = new_pos return new_pos return gotourist = factory(origin) #初始化为 0print(tourist(2)) #即step为2print(tourist.__closure__[0].cell_contents)#取环境变量#2记住了调用的值print(tourist(3))print(tourist.__closure__[0].cell_contents)#5print(tourist(5))print(tourist.__closure__[0].cell_contents)#10print(origin) #0 使用闭包，并没有改变全局变量,所有操作都在函数内部 1234567891011121314#非闭包origin = 0def go(step): global origin #定义一个全局变量 new_pos = origin + step origin = new_pos return new_posprint(go(2))#2print(origin)#2 #改变了全局变量的值print(go(3))#5print(origin)#5print(go(5))#10print(origin)#10 1234567891011121314#面向对象编程class Tourist(): origin = 0 def pos(self,new_pos): self.origin += new_postourist=Tourist()print(tourist.origin)tourist.pos(2)print(tourist.origin)tourist.pos(3)print(tourist.origin)tourist.pos(5)print(tourist.origin)]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(12) python中的装饰器]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[对修改是封闭的，对扩展是开放的 ####在原有函数上调用时加时间1234567891011121314import timedef a(): print(&apos;This is a function&apos;) def b(): print(&apos;Hello world&apos;) def print_current_time(abc): print(time.time()) abc()print_current_time(a)print_current_time(b) 等同于12345678910111213141516import timedef a(): print(&apos;This is a function&apos;) def b(): print(&apos;Hello world&apos;) def print_current_time(abc): print(time.time()) abc()print(time.time())a()print(time.time())b() 更改了内部实现，不够优雅 ####装饰器12345678910111213import timedef decorator(func): def wrapper(): print(time.time()) func() return wrapperdef f1(): print(&apos;This is a function&apos;) f = decorator(f1)f() 修改一下 1234567891011121314import timedef decorator(func): def wrapper(): print(time.time()) func() return wrapper@decorator #@装饰器名字def f1(): print(&apos;This is a function&apos;) f1() #并没有改变原有函数的调用方式#这才是装饰器 意义所在 进一步优化，支持不同个数的参数1234567891011121314151617181920import timedef decorator(func): def wrapper(*args): print(time.time()) func(*args) return wrapper@decorator #@装饰器名字def f1(func_name): print(&apos;This is a function&apos;+ func_name) @decoratordef f2(func_name1,func_name2,func_name3): print(&apos;hello world&apos;+ func_name1) print(&apos;hello world&apos;+ func_name2) print(&apos;hello world&apos;+ func_name3) f1(&apos;tset func&apos;) f2(&apos;tset func1&apos;,&apos;tset func2&apos;,&apos;tset func3&apos;) 进一步优化，加入关键字参数12345678910111213141516171819202122232425262728import timedef decorator(func): def wrapper(*args,**kw): print(time.time()) func(*args,**kw) return wrapper@decorator #@装饰器名字def f1(func_name): print(&apos;This is a function&apos;+ func_name) @decoratordef f2(func_name1,func_name2,func_name3): print(&apos;hello world&apos;+ func_name1) print(&apos;hello world&apos;+ func_name2) print(&apos;hello world&apos;+ func_name3) @decoratordef f3(func_name1,func_name2,**kw): print(&apos;hello world&apos;+ func_name1) print(&apos;hello world&apos;+ func_name2) print(kw)f1(&apos;tset func&apos;) f2(&apos;tset func1&apos;,&apos;tset func2&apos;,&apos;tset func3&apos;)f3(&apos;tset func1&apos;,&apos;tset func2&apos;,a = 1,b = 2,c = &apos;123&apos;) 装饰器也可以用来控制访问一个函数上就可以加多个装饰器]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(8) python之初识JSON]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B9%8B%E5%88%9D%E8%AF%86JSON%2F</url>
    <content type="text"><![CDATA[JSON是一种轻量级的数据交换格式JSON 是一种数据格式字符串是 JSON的表现形式符合JSON格式的字符串叫做 JSON字符串json易于阅读，易于解析，网络传输效率高 跨语言交换数据 json.loads()解码(反序列化),json.dumps()编码(序列化)123456789101112131415import json #反序列化json_str = &apos;&#123;&quot;name&quot;:&quot;weilai&quot;,&quot;age&quot;:18,&quot;a&quot;:true&#125;&apos; #JSON字符串格式，双引号json_str1 = &apos;[&#123;&quot;name&quot;:&quot;weilai&quot;,&quot;age&quot;:18,&quot;a&quot;:false&#125;,&#123;&quot;name&quot;:&quot;weilai&quot;,&quot;age&quot;:18&#125;]&apos;student = json.loads(json_str) #将一个JSON编码的字符串转换回一个Python数据结构student1 = json.loads(json_str1) print(type(student)) #字典格式 &#123;&apos;name&apos;: &apos;weilai&apos;, &apos;age&apos;: 18, &apos;a&apos;: True&#125;print(type(student1)) #列表形式 [&#123;&apos;name&apos;: &apos;weilai&apos;, &apos;age&apos;: 18, &apos;a&apos;: False&#125;, &#123;&apos;name&apos;: &apos;weilai&apos;, &apos;age&apos;: 18&#125;]print(student) print(student1)print(student[&apos;age&apos;]) print(student[&apos;name&apos;]) 序列化12345678910import jsonstudent = [ &#123;&apos;name&apos;: &apos;weilai&apos;, &apos;age&apos;: 18,&apos;a&apos;: False&#125;, &#123;&apos;name&apos;: &apos;weilai&apos;, &apos;age&apos;: 18&#125; ]json_str = json.dumps(student)print(type(json_str)) #&lt;class &apos;str&apos;&gt;print(json_str) #[&#123;&quot;name&quot;: &quot;weilai&quot;, &quot;age&quot;: 18, &quot;a&quot;: false&#125;, &#123;&quot;name&quot;: &quot;weilai&quot;, &quot;age&quot;: 18&#125;] JSON对象，json, json字符串 在python中没有JSON对象 json 是对ecmascript的一种实现 与Javascript相同 json 是一种中间数据类型，有自己的数据类型，与JavaScript相似 rest 服务的标准格式]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(7) python正则表达式的学习过程]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[12345 #优先使用内置函数a = 'C|C++|Java|C#|Python|Javascript'print(a.index('Python')&gt;-1)print('Python' in a) #利用内置函数判断字符串'python'是否在a中 正则表达式是一个特殊的字符序列，帮助检测一个字符串是否与所设定字符序列相匹配。.可快速检索文本、实现一些替换文本的操作。例如:1、检查一串数字是否是电话号码.2、检测一个字符串是否符合email3、把一个文本里指定的单词替换为另外一个单词。 #用正则表达式123456789101112131415161718192021import re # 引入re 模块 a = 'C|C++|Java|C#|Python|Javascript'r = re.findall('Python',a) #findall 方法 print(r)if len(r) &gt; 0: print('字符串中包含Python')else: print('No') ``` 正则表达式不仅可以用来检测字符串，也可以用来替换字符串。```pythonimport re a = 'C0C++7Java12C#9Python67\nJavascript8' #用r来提取a中的数字r = re.findall('\d',a) #\d 来表示数字（0-9）print(r)#用s来提取a中的非数字s = re.findall('\D',a) #\D 来表示非数字的字符print(s) 上面’python’是普通字符，’\d’,’\D’属于元字符正则表达式就是由普通字符和元字符等组合在一起的。 字符集虽然可以提取字符串，但提取出来的都是一个一个字符。只能匹配单一的字符（单个字母，数字）12345import rea = 'abc,acc,adc,aec,adfc,ahc,afc'r = re.findall('a[cf]c',s) #提取afc 或acc,普通字符a,c定界，元字符c，f#[]里表示或。[cf] c或f.[cdf] c或d或f [^cfd]取反，不是c和d和f。[c-f]取c到f。print(r) 概括字符集 \d即 [0-9]\D所有的非数字\w单词字符 ‘[A-Za-z0-9]和下划线_\W 非单词字符，\s 空白字符(空格/制表符/换行符)\S 非空白字符. 匹配除换行符之外其他所有的字符12345import rea = 'C0C++7Java12C#9Python67Javascript8\n\r &amp;^'r = re.findall('\d',a) print(r)#可自行验证 数量词,贪婪与非贪婪123456789101112import rea = 'C0C++7Java12C#9Python67Javascript8\n\r &amp;^'r = re.findall('\w&#123;3&#125;',a) #提取出来的\w 3个一组s = re.findall('[A-Za-z]&#123;3&#125;',a)t = re.findall('[A-Za-z]&#123;3,7&#125;',a)#3到7个一组，优先选择7个#贪婪 与 非贪婪#python默认使用贪婪 按最大的匹配u = re.findall('[A-Za-z]&#123;3,7&#125;?',a)#非贪婪 按最小的匹配，即3个一组print(r) print(s)print(t)print(u) 问号，星号，加号的使用方法123456789import rea = 'pytho0python1pythonn2'r = re.findall('python*',a) #['pytho', 'python', 'pythonn']s = re.findall('python+',a)t = re.findall('python?',a)print(r)print(s)print(t) 1、 对前的字符匹配0次或无限多次2、+ 对+前的字符匹配1次或无限多次3、 ? 对?前的字符匹配0次或1次 与贪婪中的?是不同的 边界匹配123456import re qq = '100001'#qq位数4-10位数r = re.findall('^\d&#123;4,10&#125;$',qq) #^从字符串开头匹配 ， $从字符串末尾匹配#即开头到结尾得在4-10之间print(r) 组1234import rea = 'PythonPythonPythonPythonPythonPython'r = re.findall('(Python)&#123;2&#125;',a)print(r)#['Python', 'Python', 'Python'] 匹配模式 （函数中的第三个参数）re.I 忽略匹配中的大小写re.S 匹配所有的字符，包括换行符123456import rea = &apos;C0C++7Java12C#\n9Python67Javascript#8&apos;r = re.findall(&apos;c#&apos;,a,re.I)r = re.findall(&apos;c#.&#123;1&#125;&apos;,a,re.I|re.S) # | 且print(r)#[&apos;C#&apos;]print(r1)#[&apos;C#\n&apos;] re.sub简单用法12345678import rea = 'C0C++C#7Java12C#\n9Python6C#7JavascriptC#8'r = re.sub('C#','GO',a,0) #无限次替换s = re.sub('C#','GO',a,1) #只替换一次t = a.replace('C#','GO') #python内置函数print(r)print(s)print(t) re.sub高阶用法123456789101112131415import rea = &apos;C0C++C#7Java12C#\n9Python6C#7JavascriptC#8&apos;def convert(value): print(value)#&lt;re.Match object; span=(5, 7), match=&apos;C#&apos;&gt;#&lt;re.Match object; span=(14, 16), match=&apos;C#&apos;&gt;#&lt;re.Match object; span=(25, 27), match=&apos;C#&apos;&gt;#&lt;re.Match object; span=(38, 40), match=&apos;C#&apos;&gt;#所以用value.group() matched = value.group() return &apos;!!&apos; + matched +&apos;!!&apos;r = re.sub(&apos;C#&apos;,convert,a)print(r) 把函数作为传递参数12345678910111213import res = &apos;A1b2c3d4e5f6g7h8i9&apos;def convert1(value): print(value) matched1 = value.group() if int(matched1) &gt;=6: return &apos;9&apos; else: return &apos;0&apos;s = re.sub( r&apos;\d&apos;,convert1,s)print(s) match和searchmatch和search方法类似, 但有些许区别, 顾明思议match是匹配的意思, 从第一个字符开始匹配, 匹配不到就返回search是搜索的意思, 如果第一个字符匹配不到, 会继续往后匹配, 直到字符结束1234567import res = &apos;A1b2c3d4e5f6g7h8i9&apos;r = re.match(r&apos;\d&apos;,s) r1 = re.search(r&apos;\d&apos;,s)print(r) #Noneprint(r1)#&lt;re.Match object; span=(1, 2), match=&apos;1&apos;&gt; group()的用法123456789101112import res = &apos;life is short,i use python&apos;r = re.search(&apos;life.*python&apos;,s)r1 = re.search((&apos;life.*python&apos;),s) #与上行一样r2 = re.search(&apos;life(.*)python&apos;,s)print(r.group())print(r1.group())print(r2.group(0)) #全文匹配print(r2.group(1)) #括号内匹配r3 = re.findall(&apos;life(.*)python&apos;,s)print(r3) 12345678910import res = &apos;life is short,i use python,I love python&apos;r = re.search(&apos;life(.*)python(.*)python&apos;,s)print(r.group())#life is short,i use python,I love pythonprint(r.group(0))#life is short,i use python,I love pythonprint(r.group(1))# is short,i use (第一组)print(r.group(2))#,I love（第二组）print(r.group(0,1,2)) #用元组的方式表达出来#(&apos;life is short,i use python,I love python&apos;, &apos; is short,i use &apos;, &apos;,I love &apos;)print(r.groups()) #只会表示出（.*）的内容#(&apos; is short,i use &apos;, &apos;,I love &apos;)]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(6) python中面向对象]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[有意义的面向对象的代码类 是面向对象最核心的观念类、对象实例化类最基本的作用：封装一定要用self,引用 self.类只负责定义，不会去运行类和对象。数据成员构造函数可以让模板生成不同的对象 类是现实世界或思维世界中的实体在计算机中的反馈它将数据以及这些数据上的操作封装在一起 类 被 实例化后 就成了一个具体的对象类就像是一个模板，通过类 就可以产生很多对象。123456789101112131415#比如这段代码为 1.pyclass Human(): sum = 0 #在class内部定义变量 类变量 （和类相关联在一起的） def __init__(self,name,age):#构造函数 ， #文件夹中得含有 _init_.py 模块才会被认为是一个包。包 导入时会优先运行. #初始化对象属性 self.name = name # 定义实例时需要self，调用实例不需要给self赋参 self.age = age #定义实例变量，实例变量只和对象相关 self. #return NONE (构造函数只能返回NONE) (补充知识) def get_name(self): print(self.name) def do_homework(self): print(&apos;This is a parent method&apos;) 12345678910111213141516171819202122232425from 1.py import Human class Student(Human): #Human是Student的父类，Student是Human的子类 def __init__(self,school,name,age): self.school = school super(Student,self).__init__(name,age) #建议以此方式调用父类 #super 不仅仅可用于构造函数，也可以用于普通的实例方法 # Human.__init__(self,name,age) #子类里调用父类构造函数 #self 用类调用实例方法没意义，所以加self # self.age = age def do_homework(self): #子类和父类同名的话，不会报错，先使用子类 #super(Student,self).do_homework() #This is a parent method print(&apos;English homework&apos;) student1 = Student(&apos;jinan university&apos;,&apos;wei&apos;,18) #实例化student1.do_homework() #English homeworkprint(student1.name) #weiprint(student1.age)#18#继承 单继承 多继承 定义一个类1234567891011121314151617181920class Student(): name = &apos;&apos; #在class内部定义变量 类变量 （和类相关联在一起的） age = 0 #行为 与 特征 def __init__(self,age,name): #构造函数(实例化后，会自动调用) #初始化对象属性 self.neme = name self.age = age #定义实例变量，实例变量只和对象相关 self. # #return NONE (构造函数只能返回NONE) (补充知识) def print_files(self): #在class内部定义函数 print(&apos;name:&apos;+ self.name) print(&apos;age:&apos;+ str(self.age))student = Student() #类的实例化student.print_files() #类下面方法的调用# 建议 类的实例化以及类下面方法的调用 与类的定义放在不同的模块。# 定义实例时需要self，调用实例不需要给self赋参 详解123456789101112# 模块c = 50def add(x, y): c= x+y print(c)add(1,2) #3 函数中局部变量的值print(c) #50 全局变量的值 # 两个print(c)的区别 # 局部变量不会改变全局变量的值 类和模块要区别对待 ‘类变量’ 和 类 关联在一起的######’实例变量’ 和 对象 关联在一起的123456789101112131415161718class Student(): sum=0 name = &apos;weilai&apos; age = 0 def __init__(self,name,age): self.name = name self.age = age def marking(self,sorce): #内部访问 if sorce &lt; 0: #建议通过方法 对 类变量赋值 # sorce =0 return &apos;不能给同学打负分&apos; self.__sorce = sorce print(self.name + &apos;同学本次的考试分数为：&apos; + str(self.__sorce)) return &apos;hello&apos;result = student1.marking(80)#wang同学本次的考试分数为：80print(result) #hello 12345678910111213141516class Student(): sum=0 # 类变量 和类相关 name = &apos;weilai&apos; #在class内部定义变量 类变量 age = 0 # 类中赋值没有意义的。 #21 ，22 其实是与对象相关，不应出现在这 # 行为 与 特征 def __init__(self,name,age): #构造函数(实例化后，会自动调用),是一个特殊的方法 #主要是被用来初始化对象属性 self.name = name #实例方法操控实例变量 self.age = age print(self.__class__.sum) print(Student.sum) self.__class__.sum +=1 #实例方法访问类变量中的sum print(Student.sum)student1 = Student(&apos;wang&apos;,18)student2 = Student(&apos;li&apos;,19) 类方法主要操作和类相关的变量用类调用类方法123456789101112131415161718class Student(): sum=0 name = &apos;weilai&apos; age = 0 def __init__(self,name,age): self.name = name self.age = age @classmethod #让其成为类方法 def plus_sum(cls): #sum每运行一次就+1 cls.sum+=1 print(cls.sum)student1 = Student(&apos;wang&apos;,18)Student.plus_sum() #用类调用类方法student2 = Student(&apos;li&apos;,19)Student.plus_sum() 对象调用类方法(python可用但最好不要用)123456789101112131415161718class Student(): sum=0 name = &apos;weilai&apos; age = 0 def __init__(self,name,age): self.name = name self.age = age @classmethod #让其成为类方法 def plus_sum(cls): #sum每运行一次就+1 cls.sum+=1 print(cls.sum)student1 = Student(&apos;wang&apos;,18)student1.plus_sum() #用对象调用类方法student2 = Student(&apos;li&apos;,19)student2.plus_sum() 静态方法12345678910111213class Student(): sum=0 name = &apos;weilai&apos; age = 0 def __init__(self,name,age): self.name = name self.age = age @staticmethod #静态方法 def add(x): print(Student.sum) print(&apos;this is a static method&apos;) 静态方法 能用的地方 基本可以用 类方法替代(最好用类方法)当和类和对象没多大关系的时候,可以使用静态方法静态方法和类方法 均不能访问 实例变量 类中赋值没有意义的。1234567891011121314151617class Student(): name = &apos;weilai&apos; age = 0 def __init__(self,name,age): name = name age = age student1 = Student(&apos;wang&apos;,18)print(student1.name) #weilaiprint(student1.age) #0print(student1.__dict__) #&#123;&#125; #__dict__显示student1下所有的变量，即没有变量# python 会先在 实列变量上寻找 ，寻找不到就会到类变量里寻找，（然后再到父类里寻找）# 所以即使student1为空，也显示了类变量下的值#公开的 public 私有的（外部不能访问）private 在方法或变量前加__ 表示私有的#__init__ 构造函数是python特有的，可以从外部访问#print(student1._Student__sorce) 表明python中私有只是改了一个名字]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(5) python项目的组织结构]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[包、模块、类→函数、变量 序列解包1234# a=1# b=2# c=3# d,e,f=4,5,6 定义一个函数12345678def damage(skill1,skill2): damage1 = skill1*3 damage2 = skill2*2+10 return damage1,damage2 (不return，就是返回none)skill1s,skill2s=damage(2,3)print(skill1s,skill2s) 1234567891011def add(x,y): result=x+y return result def print_code(code): print(code) returna=add(1,2)print_code(&apos;python&apos;)print(a) 函数参数1234567891011121314151617181920212223def print_student_files(name, gender,age,adress): print(&quot;I&apos;m &quot;+name) print(&quot;I&apos;m &quot;+age+&apos;years old&apos;) print(&quot;I&apos;m &quot;+ gender) print(&quot;I&apos;m living in &quot;+adress)print_student_files(&apos;weilai&apos;,&apos;man&apos;,&apos;18&apos;,&apos;hubei&apos;)def print_student_files1(name, gender=&apos;man&apos;,age=18,adress=&apos;hubei&apos;): print(&quot;I&apos;m &quot;+name) print(&quot;I&apos;m &quot;+str(age)+ &apos;years old&apos;) print(&quot;I&apos;m &quot;+gender) print(&quot;I&apos;m living in &quot;+adress)print_student_files1(&apos;weilai&apos;,&apos;woman&apos;,18,&apos;hubei&apos;)#重点：#1）必须参数:形参(例如name)，实参(&apos;weilai&apos;,&apos;man&apos;,18,&apos;hubei&apos;)#2）关键字参数#3)默认参数：大多数情况下，函数的参数选取的的是一种默认值，可选用默认参数# 注意事项:1、形参没有给默认值的，函数调用时得给一个实参# 2、非默认参数不能放在默认参数之后（调用时，同理）# 3、参数顺序得与默认参数顺序相同（关键字参数有时，可不遵守顺序）# 4、给了默认参数，函数调用时优先使用实参 import1234567891011121314import _init_print(_init_.b)# 注意事项：import 与 from import# 1）如 print t包C7.py中的a# import t.c7 ~ print（t.c7.a） 等价于from t.c7 import a ~print（a）# 等价于from t import c7.a ~print（c7.a）# 2)import t.c7 ~ print（t.c7.a） 等价于import t.c7 as m ~print（m.a）# 3）包和模块不会被重复导入 # 4）避免循环导入 # 5）from t.c7 import * (导入C7中所有的变量) # 6）from t.c7 impor _all_=[&apos;a&apos;,&apos;c&apos;] (导入C7中&apos;a&apos;,&apos;c&apos;两个变量） if12345mood=True if mood: print(&apos;go to left&apos;)else : print(&apos;go to right&apos;) 123456789101112a=1b=2c=3d,e,f=4,5,6 #序列解包if d&lt;a: print(&apos;go to left&apos;)elif d&lt;b: print(&apos;go to left&apos;)elif d&lt;c: print(&apos;go to left&apos;)elif d&lt;e: print(&apos;go to left&apos;) for1234567891011121314151617181920a=[1,2,3,4,5]for x in a: if x==3: break print(x) # continue # print(x)a = [[&apos;apple&apos;,&apos;orange&apos;,&apos;banana&apos;],(1,2,3)]for x in a: for y in x: print(y) print(x)for x in range(0,10): print(x)for x in range(0,10,2): print(x) 注意事项： 1)break和continue区别：break到3就停止，continue跳过3继续 2）注意print()函数的位置，对结果的影响 3）递归用while，遍历用for]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(4) python中流程控制语句]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[条件语句if elif else都是关键字，需要能读和写 基本格式：123456if 条件语句1： 执行语句块1elif 条件语句2： 执行语句块2else： 执行语句块3 执行过程：12a.先判断条件语句1是否为True，如果为True就执行冒号后边的执行语句块1，整个条件结构就执行完了;如果是False，就去判断条件语句2是否为True。b.如果是True就执行执行语句块2，再执行其他语句;如果是False,就直接执行语句块3，再执行其他语句。 注意：冒号后边语句块和冒号所在得语句要保持一个缩进。 if判断条件语句的值是否为True，如果为True，就只执行执行语句块。否则就直接执行if语句后面的其他语句。123456789101112if 条件语句： 执行语句块age=20要求判断年龄是否大于18，如果大于18就输出&apos;成年人&apos;if age&gt;18: print(&apos;成年人&apos;)练习：判断一个数是否是偶数，如果是就打印&apos;xxx是偶数&apos;n=18if n%2==0: print(&apos;%d是偶数&apos;%(n)) 2.if-else判断条件语句是否为True，如果为True，就执行语句块1;否则就执行语句块2.12345678910111213141516171819202122if 条件语句： 执行语句块1else： 执行语句块2n=17if n%2==0: print(&apos;%d是偶数&apos;%(n))else: print(&apos;%d是奇数&apos;%(n))练习：输入一个数，如果这个数大于10，就输出他的2倍值。否 则输出这个数的2次幂。input():从控制台获取键盘输入的一个字符串，以回车结束。inputvalue=input(&apos;请输入一个数：&apos;)print(inputvalue)n=int(inputvalue)比较运算符和+以及*，在运算的时候，两边可以都是字符串，也可以都是数字，但是不可以一样一个。if n&gt;10:num=n*2 print(num)else:num=n**2 print(num) 3.if-elif-elif-else总结: a.如果要求中需要多个判断，可以使用多个elif的if语句。b.一个if/elif/else语句中可以嵌套其他的if语句。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354（1）给一个成绩，判断成绩是优秀(90-100)、良好(80-89)、 中等(60-79)、不及格(60以下)方法一：grade=96if grade&gt;=90: if grade&gt;100: print(&apos;成绩有误&apos;) else: print(&apos;优秀&apos;)elif grade&gt;=80: print(&apos;良好&apos;)elif grade&gt;=60: print(&apos;中等&apos;)elif grade&gt;=0: print(&apos;不及格&apos;)else: print(&apos;成绩有误&apos;)方法二：grade=67if 100&gt;=grade&gt;=90: print(&apos;优秀&apos;)elif 90&gt;grade&gt;=80: print(&apos;良好&apos;)elif 80&gt;grade&gt;=60: print(&apos;中等&apos;)elif 60&gt;grade&gt;=0: print(&apos;不及格&apos;)else: print(&apos;成绩有误&apos;) （2）给个年龄，判断年龄处于：婴儿（0-1岁）、儿童（2-4 岁）、少年（5-12岁）、青年（13-18岁）、成年（19-40）、 中年（41-60）、老年（60以上）age=1if age&lt;2: if age&lt;=0: print(&apos;年龄输入错误&apos;) else: print(&apos;婴儿&apos;)elif age&lt;5: print(&apos;儿童&apos;)elif age&lt;13: print(&apos;少年&apos;)elif age&lt;19: print(&apos;青年&apos;)elif age&lt;41: print(&apos;成年&apos;)elif age&lt;61: print(&apos;中年&apos;)else: print(&apos;老年&apos;)说明：Python中没有switch语法。pass：占位，防止因为没有写块结构而出现语法错误。if n==10: pass 转换函数 1.int()int():将其他的数据转换成int类型的数据123456num=12.56print(int(num)) # 12 将浮点数转换成整数（直接去掉小数部分）bool1=Trueprint(int(bool1)) # 1 将布尔值转换成整数，True-&gt;1 False-&gt;0str1=&apos;123&apos;print(int(str1)) # 123 只有纯数字字符串或者纯数字字符串前有正负号的字符串才能转换成相应的整数。 2.flot()flot():将其他数据转换成浮点型3.bool()bool()：将其他的数据转换成布尔值 数字转换成布尔，非0是True，0是False。1234567print(bool(12)) # Trueprint(bool(-12.3)) # Trueprint(bool(0)) # False字符串转换成布尔，除了空串是False，其他的都是True。print(bool(&apos;abc&apos;)) # Trueprint(bool(&apos;&apos;)) # False 注意：在if或者while循环后的条件语句，可以不是结果为True/False的表达式，也可以是值是其他类型的表达式.判断的是时候就看这个值转换成bool后的结果是True还是False。1234if 10: print(&apos;aaa&apos;) # aaa （10转换成bool后是True) if 0: print(&apos;aaa&apos;) # （0转换成bool后是False） 练习：判断一个字符串是否是空串，如果不是就直接打印这个字符 串，否则打印“空串”123456789101112方法1：str1=&apos;&apos;if str1: print(str1)else: print(&apos;空串&apos;)方法2：str1=&apos;abc&apos;if str1!=&apos;&apos;: print(str1)else: print(&apos;空串&apos;) 4.str()str()：将其他的数据转换成字符串。所有的数据类型都可以转换成字符串。循环python中循环：for循环、while循环（一个操作需要重复执行多次，这个时候就要考虑使用循环）for循环python中的for循环只有for-in循环：123456789101112131415161718192021格式：for 变量名 in 列表： 循环体执行过程：使用变量去依次获取列表中的数据直到获取完为止;没获取一个数据，执行一次循环体。循环次数：由列表中的数据的个数决定。去获取字符串中的每一个字符str1=&apos;abcdef&apos;for char in str1: print(char)去统计字符串中&apos;a&apos;出现的次数str1=&apos;avaadafvaavafaaa&apos;n=0for char in str1: if char==&apos;a&apos;: n=n+1 print(n)range（）函数：可以生成一个数值范围` 1234567打印1-100for n in range(1,101): print(n)用法1：range(n),生成0~n-1的值for x in range(9): print(x)` 用法2：range(m,n),生成m~n-1的数123456for n in range(5,9): print(n)打印0-100之间所有的偶数for x in range(101): if x%2==0: print(x) 用法3：range(m,n,step):从m开始每step取一个数，取到n前 一个数为止。123456for x in range(1,8,2): print(x) # 1,3,5,7 不通过字符串相乘，打印10次“=”,并且打印在同一行。for _ in range(10): print(&apos;=&apos;,end=&apos; &apos;) 求1+2+3…+1001234n=0for x in range(1,101): n=n+xprint(n) 注意：如果循环中的变量取到的值没有意义，循环只是单纯的控制次数，这个时候for后面的变量名一般用“_”代替。 while循环123格式： while 条件语句： 循环体 执行过程：判断条件语句结果是否为True，如果为True就执行一次循环体。执行完循环体后再判断条件语句是否为True，如果为True继续执行循环体。重复这个过程，直到条件语句结果为False for循环可以实现的操作，while循环都可以 打印1-10012345678910方法1：x=0while x&lt;100: x+=1 print(x) 方法2：x=1while x&lt;=100: print(x) x+=1 计算1+2+3+…+100123456x=0n=0while n&lt;100: n+=1 x+=n print(x) 求1-100中所有偶数的和123456789101112131415方法1：n=0x=0while n&lt;=100: if n%2==0: x=x+n n=n+1 print(x)方法2：n=0x=0while n&lt;100: n+=2 x=x+nprint(x) break和continue1、breakbreak是一个让循环提前结束的关键字 如果在for循环或者while循环中遇到了break，那么循环就在break的位置直接结束。结束后程序执行循环后边的代码。 练习:找到1000~9999中第一个能够被13整除的数，打印出来123456789for x in range(1000,10000): if x%13==0: print(x) break for x in range(1,100): if x==50: break print(x) # 1 2 3 ... 49 用while循环实现：不断的让用户去输入数字，直到用户输入的数字是0为止。最后在打印之前输入的数的和。 input()函数：程序执行到input()函数的时候，程序就会停下来，等待用户从键盘输入并且以回车结束，然后才会往下执行。 注意：break只能写在循环中12345678sum1=0while True:num=int(input(&quot;&gt;&gt;&gt;&quot;)) # 获取键盘输入的内容，并且转换成int类型 sum1+=num # 将当次输入的数字加起来 if num==0: # 判断输入的数字是否是0，如果是就让循环结束 break print(num)print(sum1) for循环的特点：次数确定，可以在序列中取数据 while循环：循环次数不确定的（while True + break） randint(m,n):产生一个m到n的随机整数 产生随机数：random模块是python内置用来产生随机数的模块，里面提供了很多产生随机数的函数。 猜数字：随机生成一个整数。用户输入数字。如果用户输入的数字大于这个随机数就提示：“大了”;如果用户输入的数小于随机数就提示：“小了”。直到用户输入的数和这个随机数大小一样游戏结束。123456789101112131415161718import randomnum=random.randint(0,100) # 产生一个0到100的随机数n=0while True:num1=int(input(&quot;请输入你猜的数字：&quot;))n=n+1if num1&gt;num: print(&apos;大了&apos;)elif num1&lt;num: print(&apos;小了&apos;)else: print(&apos;恭喜你，猜对了！&apos;) print(&apos;一共猜了：%d次&apos;%(n),end=&apos; &apos;) if n&lt;=5: print(&apos;你太棒了，只猜了%d次就猜对了&apos;%(n)) else: print(&apos;下次加油！&apos;) break 2、continuecontinue:结束当次循环，进入下次循环12345for x in range(1,10): print(&apos;=&apos;) continue # 遇到continue就不再执行循环体后面的内容，直接进入下一次循环的判断 print(x)` 求1~100中所有奇数的和123456sum=0for x in range(1,100): if x%2==0: continue sum=sum+xprint(sum) 打印100~999中十位数上不是3的所有数：123456 for x in range(100,1000): if x//10%10==3: continue print(x) ``` 统计输入的数字中，偶数的个数。如果输入0，就结束。（必须使用continue） flag=True n=0 while True: num=int(input(‘请输入一个数：’)) # 输入数据 if num%2==1: # 判断是否是奇数 continue if num==0: flag=False n=n+1 print(n)12**else**python中循环语句后面可以加else语句。这个else语句会在循环结束后执行。 for 变量 in 序列： 循环体 else： 循环结束后会执行的语句块 1234567``` 1*2*3...*10 sum1=1 for x in range(1,11): sum1*=x else: print(sum1) 注意：如果再循环语句中使用break，那么else语句不会执行。（continue不存在这个问题） 123…*10，当乘积大于10000就不在执行12345678sum1=1for x in range(1,11): if sum1*x&gt;10000: break sum1*=xprint(sum1)else: print(sum1) # 如果在循环中执行了break，那么else中的语句不会执行 多重循环在循环体里面可以有其他的循环语句，结构为：123456789101112131415for 变量 in 序列： for 变量1 in 序列2： 循环体2 其它的循环语句for 变量 in 序列： 其他的循环语句1 while 条件语句： 循环体2 其他的循环语句2while 条件语句1： while 条件语句2： 循环体2 其他的循环语句2 例如：1234567891011121314151617181920212223242526272829如果n=5 打印112123123412345n=5for x in range(1,n+1): # 控制行数 for b in range(1,x+1): # 控制当前行的数值 print(b,end=&apos;&apos;) print() # 一行结束换行***************n=5for x in range(1,n+1): for b in range(x,n+1): print(&apos;*&apos;,end=&apos;&apos;) print()n=10for x in range(1,n+1): for b in range(x,n+1): print(&apos;*&apos;,end=&apos;&apos;) print() 参考了简书中某人的记录，但找不到具体是谁了。侵删。]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(3) python中变量与运算符]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E4%B8%AD%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[变量的命名规则字母，数字，下划线_和他们的组合注意：12345671、首字母不能为数字2、只有下划线_这一种特殊字符3、系统关键字不能作为变量名#True = 1 #报错can&apos;t assign to keyword4、变量是区分大小写的cat_name=1catName=1 #变量的两种命名方式 运算符python运算符有：算术运算符、比较运算符、赋值运算符、逻辑运算符、位运算符、成员运算符、身份运算符、运算符优先级 Python算术运算符1234567+ 加 - 两个对象相加 a + b 输出结果 31- 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -11* 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 210/ 除 - x 除以 y b / a 输出结果 2.1% 取模 - 返回除法的余数 b % a 输出结果 1** 幂 - 返回x的y次幂 a**b 为10的21次方// 取整除 - 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 Python比较运算符123456== 等于 - 比较对象是否相等 (a == b) 返回 False。!= 不等于 - 比较两个对象是否不相等 (a != b) 返回 True。&gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False。&lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。 (a &lt; b) 返回 True。&gt;= 大于等于 - 返回x是否大于等于y。 (a &gt;= b) 返回 False。&lt;= 小于等于 - 返回x是否小于等于y。 (a &lt;= b) 返回 True。 Python赋值运算符12345678= 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c+= 加法赋值运算符 c += a 等效于 c = c + a-= 减法赋值运算符 c -= a 等效于 c = c - a*= 乘法赋值运算符 c *= a 等效于 c = c * a/= 除法赋值运算符 c /= a 等效于 c = c / a%= 取模赋值运算符 c %= a 等效于 c = c % a**= 幂赋值运算符 c **= a 等效于 c = c ** a//= 取整除赋值运算符 c //= a 等效于 c = c // a Python位运算符 按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657下表中变量 a 为 60，b 为 13二进制格式如下：a = 0011 1100b = 0000 1101-----------------a&amp;b = 0000 1100a|b = 0011 1101a^b = 0011 0001~a = 1100 0011运算符 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100| 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。&lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由&quot;&lt;&lt;&quot;右边的数指定移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000&gt;&gt; 右移动运算符：把&quot;&gt;&gt;&quot;左边的运算数的各二进位全部右移若干位，&quot;&gt;&gt;&quot;右边的数指定移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111以下实例演示了Python所有位运算符的操作：实例(Python 3.0+) #!/usr/bin/python3 a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = 0 c = a &amp; b; # 12 = 0000 1100print (&quot;1 - c 的值为：&quot;, c) c = a | b; # 61 = 0011 1101 print (&quot;2 - c 的值为：&quot;, c) c = a ^ b; # 49 = 0011 0001print (&quot;3 - c 的值为：&quot;, c) c = ~a; # -61 = 1100 0011print (&quot;4 - c 的值为：&quot;, c) c = a &lt;&lt; 2; # 240 = 1111 0000print (&quot;5 - c 的值为：&quot;, c) c = a &gt;&gt; 2; # 15 = 0000 1111print (&quot;6 - c 的值为：&quot;, c)以上实例输出结果：1 - c 的值为： 122 - c 的值为： 613 - c 的值为： 494 - c 的值为： -615 - c 的值为： 2406 - c 的值为： 15 Python逻辑运算符123and x and y 布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。or x or y 布尔&quot;或&quot; - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。not not x 布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False Python成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。12in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 Python身份运算符身份运算符用于比较两个对象的存储单元123456789is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 Falseis not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。注： id() 函数用于获取对象内存地址。is 与 == 区别：is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。&gt;&gt;&gt;a = [1, 2, 3] &gt;&gt;&gt; b = a &gt;&gt;&gt; b is a True &gt;&gt;&gt; b == a True &gt;&gt;&gt; b = a[:] &gt;&gt;&gt; b is a False &gt;&gt;&gt; b == a True Python运算符优先级以下表格列出了从最高到最低优先级的所有运算符：12345678910111213** 指数 (最高优先级)~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)* / % // 乘，除，取模和取整除+ - 加法减法&gt;&gt; &lt;&lt; 右移，左移运算符&amp; 位 &apos;AND&apos;^ | 位运算符&lt;= &lt; &gt; &gt;= 比较运算符&lt;&gt; == != 等于运算符= %= /= //= -= += *= **= 赋值运算符is is not 身份运算符in not in 成员运算符and or not 逻辑运算符 一些杂项 `3+2-1 #4 同优先级 左集合c=a+b #先算a+b然后赋值给c 右集合not (1 or 2)+2==3 #True 建议括号只用来改变优先级关系]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(2) python基本数据类型总结]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[整数int与浮点数float整数运算永远是精确的，浮点数的运算可能会有四舍五入。2/2结果为1.0// 表示整除 2//2结果为13//2也是1 并不是四舍五入，而是只保留整数部分1.23x10^9和 12.3x10^8相等1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5进制python中默认为10进制。2进制用0b表示，例如0b10即为2。8进制用0o表示，例如0o10即为8。16进制用0x表示，例如0x10即为16。（8,9,a,b,c,d,e,f,0x10)1234bin() #转化为2进制oct() #转化为8进制int() #转化为10进制hex() #转化为16进制 布尔值bool123456bool()bool(0)bool(&apos;&apos;)bool([])bool(&#123;&#125;)bool(None) 只有bool(0)和bool()括号中为空才表示Fasle。bool(’0‘)等表示True 序列字符串 str 可用单引号，双引号或者三引号表示例如’str’ 或”str “或者’’’str’’’ 其中三引号常用方式如下123456&apos;&apos;&apos;line1line2 . .&apos;&apos;&apos; 在字符串前面加一个R/r 表示原始字符串1print(r&apos;\t\r&apos;) # \t\r 一些转义字符（特殊的字符）123456\n #换行 无法“看见”的字符\&apos; #单引号 与语言本身有冲突的字符\t #横向制表符\r #回车\n #换行\\ #表示\ 元组 tuple ( )与列表list [ ] 元组与列表在python中的唯一区别就是：元组是不可变的，列表是可变的。(元组和字符串是不可变的)12345678910111213141516a = &apos;hello&apos;a=a+&apos;world&apos;print(a) #&apos;helloworld&apos; a变成了一个新的字符串，而不是改变了字符串#列表可变b=[1,2,3]b.append(4)print(b) #[1,2,3,4]#改变的是列表不是元组c = (1,2,3,[4,5,[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]])c[3][2][1] = &apos;d&apos;c[3][0]=&apos;6&apos;c[3][1]=7#c[2]=8 #会报错，因为元组不能被改变&apos;tuple&apos; object does not support item assignmentprint(c) #(1, 2, 3, [&apos;6&apos;, 7, [&apos;a&apos;, &apos;d&apos;, &apos;c&apos;]]) 改变的是列表 而不是 元组 在你有一些不确定长度的相同类型队列的时候使用列表；在你提前知道元素数量的情况下使用元组，因为元素的位置很重要。123456789#元组(1,2,3) ((1,2,3),(4,&apos;hello&apos;,True))(1,2,[3,4],&#123;5,6&#125;,&#123;(1,2,3):10,&apos;hello&apos;:11,100:&apos;hello&apos;&#125;)() #空元组(1,) #一个元素的元组#列表[1,2,3][[1,2,3],[4,&apos;hello&apos;,True],(1,2,3),&#123;7,8&#125;&#123;(1,2,3):10,&apos;hello&apos;:11,100:&apos;hello&apos;&#125;] 序列可以进行加法，与整数相乘，切片操作123456789101112131415161718#与整数相乘&apos;python&apos;*3 # &apos;pythonpythonpython&apos;((1,2,3),(4,&apos;hello&apos;,True))*2 # ((1, 2, 3), (4, &apos;hello&apos;, True), (1, 2, 3), (4, &apos;hello&apos;, True))[[1,2,3],[4,&apos;hello&apos;,True],(1,2,3)]*2 #[[1, 2, 3], [4, &apos;hello&apos;, True], (1, 2, 3), [1, 2, 3], [4, &apos;hello&apos;, True], (1, 2, 3)]#同类型相加&apos;hello&apos;+&apos;world&apos; # &apos;helloword&apos;((1,2,3),(4,&apos;hello&apos;,True))+(7,8,9) #((1, 2, 3), (4, &apos;hello&apos;, True), 7, 8, 9)[[1,2,3],[4,&apos;hello&apos;,True],(1,2,3)]+[4,5,6] #[[1, 2, 3], [4, &apos;hello&apos;, True], (1, 2, 3), 4, 5, 6]#切片&apos;hello world&apos;[0] # &apos;h&apos; 从0开始&apos;hello world&apos;[-1] # &apos;d&apos; 从末尾往前数1&apos;hello world&apos;[1:4] # &apos;ell&apos; 从1开始，4前一位结束&apos;hello world&apos;[0:-2] # &apos;hello wor&apos; 从开头到末尾减去2位&apos;hello world&apos;[:-5] # &apos;hello &apos; 从开头到末尾减去5个字符 &apos;hello world&apos;[1:-2] #&apos;ello wor&apos; 从1到末尾减去2位&apos;hello world&apos;[6:100] # &apos;world&apos; 超过，从第6位取到末尾&apos;hello world&apos;[6:] # &apos;world&apos; 从第6位取得末尾&apos;hello world&apos;[-1:2] #&apos;’‘ 空字符串，不能这样做 集合set {}和字典dict {}集合和字典的特点是 无序，不重复set()表示空集合{} 表示空字典123- #可以用来求两个集合的差集+ #可以用来求两个集合的交集| #可以用来求两个集合的合集 字典是通过key访问value{key1:value1,key2:value2}key不能重复,类型为int,str，tuplevalue可以为任意数据]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(1) python]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2Fpython%2F</url>
    <content type="text"><![CDATA[编译型语言在程序执行之前，先会通过编译器对程序执行一个编译的过程，把程序转变成机器语言。运行时就不需要翻译，而直接执行就可以了。最典型的例子就是 C 语言。 解释型语言就没有这个编译的过程，而是在程序运行的时候，通过解释器对程序逐行作出解释，然后直接运行，最典型的例子是 Ruby。 Python 是一门先编译后解释的语言。 当 Python 程序运行时，编译的结果则是保存在位于内存中的 PyCodeObject 中，当 Python 程序运行结束时，Python 解释器则将 PyCodeObject 写回到 pyc 文件中。 当 Python 程序第二次运行时，首先程序会在硬盘中寻找 pyc 文件，如果找到，则直接载入，否则就重复上面的过程。 pyc 文件其实是 PyCodeObject 的一种持久化保存方式。 执行 Python 程序的三种方式：解释器、交互式运行、IDE运行]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
</search>
